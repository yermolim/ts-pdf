/**
 * Copyright (c) 2021-present yermolim (Volodymyr Yermolenko)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * FlateStream class is based on the corresponding one from PDF.js,
 * so the code of that class is also subject to the next license notice:
 * 
 * Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright 1996-2003 Glyph & Cog, LLC
 * 
 * The flate stream implementation contained in this file is a JavaScript port
 * of XPDF's implementation, made available under the Apache 2.0 open source
 * license.
 */

import { renderTextLayer, RenderingCancelledException, GlobalWorkerOptions, getDocument } from 'pdfjs-dist';
import Pako from 'pako';
import { v4 } from 'uuid';
import CryptoES from 'crypto-es';

var img$A = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/PCSiERUtRCy2iGKRgCiIpUQwTbRIIhi1SdY8hDyW3QQJtoKNRcBCtPFV+A+0FWwVBEERRGz8A74akfVOIkQkmWX2fpyZc5k5A85wTs9b7jHIF0pmJBTUFuNLmucFNz304kRL6JYxF52N0XJ83uFQ9TagerXe13R0rqYsHRztwpO6YZaEp4XD6yVD8bZwv55NrAofCvtNOaDwldKTdX5WnKnzu2IzFpkBp+qpZf5w8g/rWTMvPCrsy+fK+u951E28qcJCVOqgzCEsIoQIopGkzBo5SgSkFiSz5r6xmm+eonh0+RtUMMWRIStev6hl6ZqSmhY9JV+Oisr9f55WemK83t0bhLYn234bBs8OfFdt++vItr+PwfUIF4WGvyg5TX2IXm1ovgPo3oSzy4aW3IXzLRh4MBJmoia5ZDrTaXg9ha449N1Ax3I9q991Tu4htiFPdA17+zAi+7tXfgDAkGftS3qrhgAAAAlwSFlzAAALEwAACxMBAJqcGAAABNVJREFUeNrlW21T4jAQTkJxPI9BeXFGZ27u//8oP934QUcpMnIngjS3GxomhKRt0qSUmjmuRTD22X32NQklkcft7S3ZbreEU0o4vKdZRjhj4krhiiPj8Al8vv8Mvwc/Y3D/+voa9flojEnH4/EOGIBilu9kAJZJASj3tu9xuM7nc5/H4UVYaUjQQssFYOoOnJvg3NWFwcvw1hbAaDQSD4V/iZFmRpabT/b1RRaLhYsAjjAntW0o1zatojm8R5ZsNsIvLO/uxM8GT0+k1+sR2u/v5kGfoPgIfUiG9ZKkiolzg1BoMAHYUXP4x4W2rFp6eBCXpWWK6+trIRich4Y1q70QggsAZ958fpLlcll7LlVwg8GAXFxciGjh4QCtQkhC2STDMAavdDaLQigpUBlWszxMeoIP5wME1UEAabEzCjZeXl7E9ebmZucr3MBTPSxS0r3BXXIe+p3Bk7LQLTO6cwY/mkwKlWwVwGg6dfW4rdQ8LVGkUQBD8LQcPG1XaI8RY4oKrRoFEiVz64LNY7j8skQMZqR+Bx0eAp1MJsUCwMIGa/Iuenv5S5he2xmAtFccH2Z4+i+cE3hQ6O9MUyjWFkYBiHpepwcIY+GR4Y0NVIsFPv9bRs3P5/M/TItk6BBVpe4FwA3dG1ojDE4D+xIAagQPtUfhQ/b7/Z+6Q2RKGc0OanZN1DOPwkZqHyWN9yHYIMGrc1UBj+P5+fmvXjNQ5X1P0l+vt7GkXa/Xzlo3GejHx0cwzf+4uhKvKuD3YR00fmD7wOzLy0uyWq0smSBIyKeet3VwfVlgoj0OF/A43t/fjxgu8xzxf6bZOufcW2PYD2AG3+EqhFDgrf4sFwjDBgMzNDjqDBsTqjrG0OCNAgEGoOmzrZbz86IeniMTjjpHuWM8Bfg0TYlJrYzr1AhYA9jMwcaE2JrXkYnQz0ncYTIHExOaoP2RIxS9TD3+R+gBlDnGJsDbHCPjGuVx0aIpJjQNXo9uorNMNAZsIzZCDI6xUc3r0Q0ZQEuKjjirxzvqn4T2qu8R6xklFVcsH+lVz8cYjfe9bDYvwUcspclwODx2gm0CH7ufoC+lceEETwzeZvMxhKDXA6wpBpSBty2ohm6qUEPRx9qied/aoXYi1Cbau9YOznmAgQG0QoiiTYCvYv919h7gmgA31AasDZqP1VQpbPLAe9xpxtoGvkLt4CcAnf75e9ZG8GWUdxUCJkDUIpCQAuCmB67dydHmxPf4cnGMib6dDuj/ljMslAC46YFDFTZyTnVuNJEqTLi/v78qMgcWEnzMqs7CrlIhrNbrf/p6J+4wLQpxLmGwNVWd0VeMx78gmXo8qAGA/tggDcGAVoMXDEnTR70A2mgdL9ZV8JZkQKwSHTjI7wIebf/NsMWefRfwPdvO887TPq/7bUv9SdfBlx21oQ5gzw58JXb49hJIRwarCx631olzQ80nObgPuPY8SV3Nex5l8x6Q22N6uz+k0bQAQi+UVEaAJS1WdZ8AXhysDLSMn5zYBHmREOQub16whnfuAthrF3N2mp87EsmLQu+YHjex0JI3hJ3ayllWktmh/W8CLOUnocIcbj8VOzALDjyGKGbk8dxQh7SisEsepw0iDAkaXm8RTpJHT2hURyYEAldc8cGrbFXLe5Zf1c9ih9n/LqFyUTq2iTQAAAAASUVORK5CYII=";

var img$z = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAJT0lEQVR42uVbW2wUVRiec7bt0i2l3U7TAgajCFp8AoEIgjzZhCBqUB40qfdYL5V6wRASjAlKYoIgVsQLPGlMMJYEI4IhJfGBApogBB+o1hIvmBSyO7vbUrv3Gb9/ma1nTme7u7O7tV1PsswyOz0z//ffL8OUEi+v13sjDisYY0sMw2jB8SbdMJpxrp5z7qZrdF2P4hDijF3FNb8rnPcxwziPc2cCgcBfpXw+Voo96xsbV4OAjfjcqzB2SyGbGbo+AECOAqXuYDB4mk5NSQDq6uq8vKKiHUS3g+j5peCWCcYBPZHYPzQ0FJoSANTW1qqVlZVbINYdEOkaZRIWVGYE6vJBMpncCSCC/xUAroaGhg5wezvp8wTXJXVFOcsNoxff+6Djv+BzGURcGx4eHqELZs2aNRPg1cI+zMN/Wxjni/A3q7miLKX7TLB3AAS8oWnaR4TLpAGgqmpLUtc/w0Mvz3BJDIp6FOrwOb6fgCEbdnIfADwLh1YA1gZQ1uF7la1EKMr3FYw97vf7+0sOAB7qSYj7PhBfbfOzXzGMPYlE4mNwN1BMsTdV7XlI3MvEAxu1+Btq8QLA/qxUALjg0rrAiQ67m+P8WzOqqvYODg6OllL/m5uba+Lx+EtgwjYwwTPOUCrK+0FNeyVXlcgNgAUL3A2BQDfQv8/mhoch6p2l9tcZ4ou9AP5+G2/xVVBVH1YGBqJZuZoL8fXB4NcwUOskrkfgkjqA9pZwOJy3jjc2Ni6tcrsHqmtqqiPh8Hf5/n0kEhnC5wu3x+MDA+4BcyrGuMpYS3Uksix8ww2HlEAgWYgEkKU/LHMesvUXiF8f8vkuODJuqhqUPUdA0xx7JIB5RyKZPAKVmCtLJxi0cSJ14FnErGsc8br+M9P1VU6JhwdZZuc2vaq6xykAsP7nIPar8Gz9Enc3YN/djlQAnH8K+rVDJj7hdq8Z9vsHnRIPrvTg6wwbUVwxw+Ophzocd7J3NBoNIRr9Eh7oAaiAKu4LNbmEfX/KWQVMP39OdHUk9sR5xON/OhTTpbDcZ00gB7H3nAw+fU9I014tICS/CYw7Le5PXqrC5VoCSfk1FxVwmUFOtWTw1hdI/Imxm2Yg3nygV+pV9V2nACA0/h3Erkc8EhXuV4P7f2pHr8tG9DcBwaetT8U7Qn7/MacGD2LfaYp9yE78BaAHIb61EMuVENs6p+owOjo66PF4yNCKnmse9ryKPc9mVIFUtFVVNSAaKdOSPlio2DtKegpUBzDzCIz4euGUlkwkFoiZpEUkKKsTiaesi4Ich5wPCDofzubu7M6TOmAfx/k/ssVNuLcYmapI2V+ztQGUz1NKaxEPeAEnER5xnjzbdREyoml7ks3XZ/q9IYsrm8geID94W4oSO+He68YBQMUMSz5vGD6K7R2Kfc+/KDJ3PoFOhutedQqCy+V6j7YVDGIt/nlGBoClKjnW1ZVvYkMRmSn23kKivIwgNDTsyhcAn883AmZ2Sda2PW3/UgBQDU8qY8UQUHzkgPgTuYq1IxAY2+wEhFgs9iEOcUG1F0INVowBQAVMKYY+mk8+bxq8HwvlfKlAGBkZ8UP3v5Xs20YRgHstP16v5OTK+VtlwotBfDYQEONvz6vwwdjnUsyRihF4Kq+2lq4TuLgn50qtYbSWivgM+2kmBY/k6RJ7xKwQxrAFzJtDErBCCj5+1DTtWq4b49pPgMLJUhFvs6+K+30D4B/K0yWGoAbnJSm4q4I6NpbA4Hr1Np+VQKywZjKqQAWDyzkxaumY9DK2mFO7SrqsTynXxVifZOwXcerVSTr9S7nSD4IttCG9v5mbjUoRgMtlC0A8bknnDc6buVyeoo5NuQIAT3BNigi9PN2iTq90u6oc18js2desNpG7ufI/X9wcThhb1KgsV2JnXrlSK6l7hJtlKsWSLpbpQmpcK8UFQU5jKVLMPK9sw4DKyhslN3iVp2ZyrKulbAGQgj64wd84DSRJaeKiMrZ5FgAQV/dxcxpLTIZWly35un63JBEXyAiesdgFJAvmZEZZLSr6QrqXSEbxFKeqb2r6SjiPT2vZ+XvOWxWhCAxJv+jz+a5w89ejUj7QVn6JIGuT0v5jyhgiut4tGcJ11CUqmwBo5sxGILBWOn1oDIDUBKZhXBJ+rEoNJJXJqnS7X6SDEAH2Q/V/UASdMAzG9ksy8zINJE134lVVpWZrpyTh+wWjb6KSSOynXqD4tzSNNe1rAIZBE2NewfgNw/0dGAcAFQ1p/NTiNg1jmzmNNV1d382gYasU/HSJg5tcKhjsVKx9NJrD2ztdAYCf/8Ay0GkYPhiA3VLc8++iwWOavZX05f56VZ12BhHBXKcijfYh9n8dBn9IkojxMQMIPg1k7hSQiyY5Xznk958vysPZ9PyL2U+A4VuOG1B5X5wt7sU9qHxvZJSAtOpXMPaYZbCAMTdLJr+hAaQpr/dNTfOTuv61SDzVOROcP6HYvGxhWxKjqWsYxOelUHIu1OE4XGPTVCW+qampmcfjx/Gssy1i7nI9O+zzXbINkTNtRlPXNHgsgXBrNBY7WQxJoNE18zhaLM7DbfeCSQskP7gr6PcfzJgjTLQpTV3T4LEMAm5yiuYBnD4s6Tv2eDNllxjbUaj+0wAmi8dPjSNeUbrByC0T5ghZd6dJ8WCQQFgrIRtFgrFZ07R9U8Dav6PIL1Mg2QHxG/AtVhgAJgjeYPAgzd7ahFpHIMabQqHQH5Md5JCfl13dGOc1rS0b8encPweZDSQj4XD3DI+njkntdDzAbbAV7R6PhyPrOjc6OhorJeEU21dXV2/FfQ9C5G+3YcgucP45fEvklCbn+wCIEdpguT7O8IZYgAaSaCaHxlKKndJSVmcmNl4bozoCa98+kcErCgC0YAAXmrO3KzNcEqeZHBpLockMp+/4pd5F5LwV+zxq5vMVGS7tJT+fydUVHQAhYnwWbuQtxeYlJjHFSE1mcN5L/XlqUVOXlhqV6V4ddWyoaUF1e7N03QKWroGIL87iqfxI47eB6wcUh2+UsiIYI3pjdDNNYE5WVymV0iKro8RGju0nHYD0So2f0gSmrrfTHF5JCNf1fipmUD7v9F3EkgEg7klDiDSHR6NoNI1VILcvmgXMQ+kyVlEfttTiSqNoNI1FA0k0k0NjKTSZYQ4npF+fpxcygtSro3YVdWyoaUF1eypdl/L5/gF8P3SyE6no9QAAAABJRU5ErkJggg==";

var img$y = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAJeElEQVR42uVbbWxb1Rk+5zi2g+Mmvv4Q6QSMQVSWaRuqqNSVtf+oEC1lBdEfSFW3Pw0d0GVQ2FRpExKi0r74KhRE+QFslZhop2pQojKkaWKsq9SVov0hoqWgTqJN5OvrNGkcx/a5e96ba/fek2vHvrbT1LxSm+Te63PP+7zveb/NWZsplUr1l0qlH5qc32oyNsil/JYpxLVMSk0I0U3PSCnzTAgD98Zw7wvO2KfcND/B/WPpdPp8O/fH27FoPB5fjR/3S843CMa+08xaAGcUQIyYUh4yDOM4LplLEgAw3Qspb8dGh7DhFe0AFmufhqbsByqvAYyJJQGApml92NQuiGUY0u5li0DQikkuxF5ZLD4zMTFhXCkAuJZMbsdZ3YPfk7X2C8l9ApA+xO+j0JJRs1A4B7swOdXfP0kPRC9cWBYIBJbxYPAGbOgWZpqD4HItmFyJ24Eaa+uSsV9ndf1Ves+iAdCbSt3cJeUb+HVtlUeKYOKoaZp/grQ+8Culvr6+GIBZj3W2Aoy7cClY5dF/C85/DIN5uu0AQOoPmKXSfpzzqMdtA0dhbyGff2lqairdSrWPRqPJUCj0EON8mEyOx7G4BC3bAW040C4ABAzdb7GBxz1enoMEfsM5f07X9ck2u9Uojs/PpWnuhhAi8wwlY88bur6r3iNRLwCheCJByG6Zb5rNEWzoEaj5F2wRKRaLfRMAvAiBbPIA4bChaQ+wM2fyrQAgBMkfxos2KNdnwfwTmUxmL7uClEgkHoaNeAb7Cyu3jmY0bfNCIAQWAgiSfwuLb1ZU/gJU/g4wf7jJ2GH3NZHIh92RSG4ml/uXnzVyudyJnp6ekZKUm3AElzluDXRPT393ZmbmYK3giS+wwd+rZx4u7YwMBu+cGB8/2xTziQSWktN0jsmA4WdPRtd9u2V4jBvhKd5XgzAyyrAJw1UNWy1r78V8MBhc2yzzlZfbRoyYb3Yt2KAvw6HQOoD5mSLhn0GQ2xoCgPw8XN2rqtqT5MfHx8fYEqWxsbFxCOlO7PUrdyRmvpJMJlfUCwCnIAdScZ6n2YAQ97RK8u0k0gQzELgbBjrv1LSiaf7Ri1/hofrb50V4sPbw7yfYVUIT6fQpZKKPKoyuhsf4aU0jSIkNLOlpnP2U08/D2m9secoMI6hea8YIVknU/grDeI/zFaViccAZmgvFKu1yMk8RHgU57OqlneRpnLgjt/iF5xGw8nmktK6bCG8XO8JrJRmGcQ487FEM4iOUZM0DgIoZSj5vUGzPrnKC236B0maHQYyKrq6h+QBIOaQGEO1ObBbJNV6CHXveZfhMc6hs/0S5hqdEUAVKaVmHUKFQeMXKXSoI8JthIG93asD9its72up8/krS5OSkDg0fUQz+lgoAUsn0kF0dYB1GsGcHlCKG5doF1e2V0rWkMhbrPCKeShVAhBjA0b9OUNNCSXhONVtpXYqEYO6iZOykcnmNoI6Ncjb+yTqUoOkfuYTN+UpB7SrludFOBQDa/aliBwYF9eoUVDoWAFW4MIw3CqtR6QSgUDjXsRpgmv9TwuJrBXVpnRepY9OpAFBLTbkUE+UWdZnK7apOpIsXL0657b0IC/Y1J2ENJziIGpWdymxvb29UORJ5QZMZzovUpe1YabvrnERZcoOuKi+1qDsVALi9612AcD5GbtBV8bH6850LwC2KW/xS0ECS4iwHO9jmDSqAjAqaxlKc5bpGV43FYt9DZvUuVXq9qr2tpPI78D6aOOlqKA7gfK2iAacoDjjmQkWIlc6iYZ2q9Rf8dzeza2/tAsG1LufrEonEg/V+Fs8ug8+/Tbl8XNAcHo2iOW0DjaU0aF7fKr/Hc7OtZv4y8HXXLSDt9S6NMc3Praqx7R5GlIe3NrI5Q9efZNSjr2PTrWKeXgvhfVY3AJxvVf5+z06RrTTxkHIM7qKZnAYLDo+3AwSPzxtwX7dldD3eQAAUh7HfqABwqAIATWBaQ4iXKWgNJDVedWkpCF6fo8EMSP7jRtbp6uqinmDIoeJns+n0RxUA6JI1gek+YMM0kOQLBMaebRaEKpJf1Sjzy5cvpxmEYUX6+5k9NSIc7u81JV2M0zSWH8ll5qa0fINQec7Z4uZ8PZg/2eheZmZndyr9zkuyWKwIuwIAzd7S+KlSMNhNoydNgMAaBaF8nxqzjsEnww/zVPXF0f6VcoT2Ve0OA5k/MHcfLQKX+KJfA0btbsnYc/WC4LyOd19jb3hVIwZPUfW9ykBntlAo/M6V/Dn/yOfzM+FIZNJlMTlfEYlE0jSN5WcTM7nc+1izD2uusSV7XpnmUimLf+UiTVavMeBUi7RkcgjvfEIJBn4J6f9DyX3mhzWQBFnINY4P5oHk7Y0aIFe4nEg8C3V7tM7Hs7a1P+nrXanUraxYPO6sdgH4E1nDIJ5KLma9QmYaPLZmby9rQbhYKh3xaw9sUT7mdRwcGzyvuDpfzGuadgMWO6IwnwsIsU1lft4RKNP09HSmu6fnHNTjPkfYSWq7ASC8fQnk9zh0RyIxrPsDj7CW1s/i3jqovS/mo/39KVEq/R0A3qSo+Q64Z8+wOVBjs/9VN4tNJorF4o/C4fAR2Itsy0GYY/4/fiVvMS/Et13HXsp98HB7qiZyC6U5WiJxCA/dq6jrV12BwKZmbIKHJ8jC2mu+zzypPWPXKUbvXUj+Xi/Vr2UDXLxaU9eMHVVqa98ACMdg2B7yCwC5SCDwtDUuO+fqfDFP1t4yeArzsDd/y8TjW2oxX48GzNHAQFjT9T8jUNo8z9dK+Q5+7KTUcjFLO1aQAz+vamdF8sR8HePygfrElSnR1DXOroYXrlbrbEifH0SsQFnXx7CPhXYyTrF9MBx+DO88CM35vodA6Mz/BHuuax/cB/LbECK/XGXAWaeBJJrJobGUVjJOKS2yuh1sbgI06eFG6VsrD+PMv95QNcvPZmjwuGiabwoPS27TLM3k2GMpH9Bwgk81p7G9O6iYYUenoSoxxAny8/AgDXe2mxlNFTR7C0P2FPP4EpODSjSZQcMJdn9+lLq0lHmWe3XUsaGmBdXt7dL1IBUw8ZlVCxzTLDTuSQC8byFj1w4ALEJgpNH4KU1gVvkmWcvJ+oIFsjpKbJo9ai0bTqZKsjWBKeV2GkBqC+emeZaKGZTPt2qOqR1fnubWECLN4Um5sWkwTPNzKmBSDc8uYy3NL0/X8teUWdJAEs3k0FgKTWawueGEsK3SeTsDHKN2FXVsqGmBa8fbHV/8H2Qog/fmBwhzAAAAAElFTkSuQmCC";

var img$x = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JErEBymMIKKQQsXCgCiIpUTQRi1iBKM22c1LyGPZTZBgK9hYBCxEG1+F/0BbwVZBEBRBxMY/4KuRsN7JBhLEzDJ7P87MucycAfd8Rs9aLWOQzRXM8FwosBJdDXjf8NCDDz8DMd0yFpZmIzQd3w+4VL0Pql7N9/07OuIJSwdXm/CkbpgF4Wnh+c2CoXhX2K+nY3HhY+FRUw4ofKN0zeFXxSmHPxWbkfAMuFXPQKqBtQbW02ZWeER4MJsp6rXzqJt0JnLLS1L7ZPZjEWaOEAE0imyQoUBQak4y+983VvUtkhePLn+DEqY4UqTFOypqUbompCZFT8iXoaRy/5unlZwYd7p3hqD1xbY/hsC7B5Wybf+c2HblFDzPcJWr+/OS09SX6OW6NngEvm24uK5r2j5c7kDvkxEzY1XJI9OdTML7OXRFofsO2tecrGrrnD1CZEue6BYODmFY9vvWfwHle2f+inwUtgAAAAlwSFlzAAALEwAACxMBAJqcGAAACSJJREFUeNrlW1tsFGUUnvl3tyV1e5m90EIAMVSwPkhQE0Tqmz7ILRDhgYSAL1TkkqqoCVFDYiRRIgGL1QiJFyRGAwkqSlDeAJEEBd4od4IJ0trZbbutsN3d+f3Osltn/53ZnZ2d2a5xkma3c/nnnO/cz39Wllw+wuFwSyqVms9leTaXpDZZ0x7gjDXjc6LMWA3do3GekGS5D+d6ce26LEkXZM7PM8ZO9ff3/+kmfbIbiwYCgbn4WK7J8gImSQ8b3aNpmgQG874b3NeDa0e4ph2MRqOncYpXJQBgugFSXgtCO0DwTDeAxdqXgdQeoLIXYAxWBQCKojSCqM0QSydk2CBV4IBWxGA+XVoyuWNwcDA6XgDISii0Fra6Dd9DheiF5M4DpOP43gMt6eGJxE34hdhwS0uMbvDfvl3v8XjqZZ9vGgiaJXHeBi7bweQcXPYUWFvVJOmtAVX9hN5TMQAawuEZXk37HF/bTW5JgomjnPMvIa1jdqXU2NjYBGCewTqrAMazOOUzufVXJstr4DAvuw4ApL6Sp1J7YOd+g8tRmEJXIh7/cHh4uN9Jtff7/aGampr1iBad5HIMzGIEWrYO2rDfLQAYHN17IOBVg5ffgQTelWV5p6qqMZfDqh/m8xJC5xYIoS7PUUrSrqiqbrZqElYBqAkEg4TsinzXzI+AoI1Q8+tSBY+mpqb7AcBuCGSxAQiHooqyUrpyJe4EADWQ/CG8aIFwfhTMvxaJRLpKiWROa2YwGNwAH7ED9NUKl45GFGVpMRCKvUiG5L8RJQ+Vv+1hbDHU/TcHmbZNZygUejSZSh2GRkwW8oZvkS88V8gcWJHkZrvIPBa9wn2++RaY5w5mbQXXgvc/C7rmQzCXclBjbKkSDO60hSx5e8T4r0TmfT5fe19fX28FpF4y3c3NzRPjo6Mn8jJRztfAVPdZXojiPEsmz2Gher3ak+QH+/quuWzjZa2B3GE6JP+L3hxA+99ej2cONOWSFROQKcnRM08ODza/pEzmZd2fE/cZvg/R6Ab3eBZB6mPOj8JlkvN9RvwyA9Vfm5fhwdvD5s/YZN4KM3afNQahv/8cKtGXBUbnImK8WFCNqLBBMnMZISWsj/Own4U2mHej1C7pXeDnO5jDEt2pSCqZbNWn5rkagKpOzzxleJTkVAnzhdY1o2MT2b8+sKG2eN3QBNL1PEranItIbwtkeNxhdXccBOQAN8HDttzSlG+kIisPAGpmCPV8lHJ7qToPyyAjbH9AZbPOIfqZ19uRD4CmdQhwdhUobLhVopBJVhKEPLp6e3tH4Md25TzIeUf2eZbt4QnJQ4JK2nKZd6XfCEB1oFoCIZFIfJyuXcaekmfAQT6p14DlQtg76mQ975QWZNeJqGpJz8ViMRUafkRw+CvGANCESg/V1f5yVBHFiSipskEowLwl7YM/2y80MdKhXU737TVN33vXECtDJm2ssmwfHpkKF9sAFJB8UbooygGFSE6PkfOpjDYthILnXAk9PFP0jYhFCCqqCaLmWGDekhYgmRtCTfy7cHoeox0bwTZOOGX7RDRJ3chEimlNFggLzFvv6UnSyRxhy/IcRttVwn09Tpa4RipvpAlmmlEG83n0QrsvCH6gjdFenYBKj9PJiJkmZJl2iHkr9PQIjnE6o43KHAASiZtuxG8z5+eC5M1VgvM/BE1sZlADRX+SdmzcSmKsMuUG85niLiZoQAAJIJugP5ndrhovENxino6hoaFhQSNqmfQ/PxjUIqdvThuVbufylUibjY6Ghga/YAJJhrifk/TQLu14Me82CEKfk0zgLwqDOS1u2qKuJPNmNu8GCJD4VCE176UweF0IprPsJhp2mTcDwSxjtEsPAJglaMANRgNJQrBsKzfxsSN5u7VDiYlRmwBID6NpLCFYPuW25zWTeKm1Q8l5gCy3CxpAmz/sVA4qjM3RNw2dMgOrcd5q7VAqHcFgsB4x/zHh9GlGc3g0iqb3DTSWMt6ZYKHawWYaTDx5dSeuprvGmfBwRE8gzeSUYFfcSeZt1A6WmjQo8lYJ//841hKjIUT94jSQRDM5lZa8WyESCVAAiCwUADioR0pWFOUiGH9QpyJbI5HI2zZbULycyOF4DhIIvAGX/46Ot2vgrZW+sTGCaQIzN0Z00kCSjTjMpSo6Jk2aRINUnYL092TpZLrwt1coFwM0jVViTsCd6CI5edwdHd0k7HeOaMnkHl2b7N5Bs7c0fiqEny00cOBkYlRh1Z8C//amkP52m+4OA5n3pdx9tDqExN1OtMXG44CqdwkDnQOJRGJ7DiD6f4DMAM3eCr5gEY2i/ddAUEKhDhC2TEgGttIuUTHiGcIMtY/n6R6Mw2tOsJmFVRygpnB4tpRMntZ3u2D7ZwaiUeIpZaoB2Xtp8Dg9e/uvFtQ2KcotJ1Jh1yWvKNPA7Q8C83c8jK0WmTcDQEpPXTO2TmgmTAIIF2kUrVpt3t/SEoZEfgJTUwTHt1FVVcN2v2lPkKauafBYAGEmzeHpIoNcLT6AJO+Nx4+DxodyVFTTumG+n9q1T6YEgwdFZwKVuuX1eBbThGY1MJ+2eVJ7QfLwXYfB/DIj1S+qAVle01PXknRU0ITJAOFUUzC4vhq8fdrhCcwjmv0cCQRWFGLeuoduba1VVPVrmr3N84Ka9j0+NlFpWfEkB3E+L9RlJU/MWxiX91gryyKpu3fvHphQV6fghXPFPhvK5xfq6uqo6jo7MjKScDu399XWvoJ3HoBze8RAIN0QxvOg2RIdsg3kVyNF/ghmcJ/BZZUGkmgmR0w4yj2opPV6veukexOgeaV65lcrG2Dzn5Wyri0PHgqFZiY5/wJ294TJLaM0k5MZSzlGwwk21ZzG9p6mZkamnq8xdFRIcijOm4U6t7I0RrO3CJXUMwgUuC9Fkxk0nJDZn++hXVqqPLN7dbRjQ5sW1LfPtK7bqIGJZx4vYqYDmb5FdzFn51qaipxAofFTmsA0+SWZ4wdlqVTVUWFTrqk5lsRQJzk9galpaxEtWt0p7/g1amZQPV/uL0bdLFTk9BAizeFp2sKyweD8KjUwqYc30N9/UqrWH08XitdUWdJAEs3k0FgKTWbgMwxf4M2E0ji+R2ivjraraMeGNi1w6bTb+cU/7fBoL+/5UFUAAAAASUVORK5CYII=";

var img$w = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/N4piFBEtRCxSRLFQCApiKRFMoxYxgq8mu24SIRuX3Q0itoKNRcBCtPFV+A+0FWwVBEERRGz8A74akfVOVohIMsvs/Tgz5zJzBrTJvGG59TGwCp6TTMQjc/MLkcYXQmiE6aQ9bbj21MxEiprj8446VW8HVa/a+6qO8LLpGlDXJDxi2I4nPCY8uebZireFO41celn4UHjAkQMKXyldD/hZcTbgd8VOKjkOmuoZyf5h/Q8bOccS7heOWvmi8XsedZMWszA7I7VbZg8uSRLEiaBTZIU8HoNSC5JZdV+s7JtmVTyG/G3WccSRJSfeAVGL0tWUmhHdlC/Pusr9f55uZngo6N4Sh4Yn33/rhcYd+C75/teR738fQ+gRLgoV/6rkNPoheqmiRQ+gbRPOLiuavgvnW9D1YKeddFkKydQyGXg9hdZ56LiB5sUgq991Tu4htSFPdA17+9An+9uWfgCZXmfbLPy9EwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAtBJREFUeNrlWwtuwjAMra2cALj/CWFHWLYiQKGLEzu282GRqiFo3bznT23PhY1Yl8vl/vd6vW6VFTf5AitZp/P5JQsByPMoHEABr12oAE/d21IWG0+gTuywYrLx2OumR8sOSnmg3LwaONcFiqZT0j4jBngAhoZYVDX/HLbQCfgRWJT6MkVGycefn0tEQO5HS7YJWWwCanI5+y8REKxUu99UEEhzsQO0hFOKK5GFrdrfhT2PQU+RJiVVCdA8WkYA0O4DPTdrHUg5AKUk4AhNzURy0DIqDH4uJB/3sH+mAt+fVPg7Ri+Nx5bonpFtIscrFeZkfFGxeSs5pLLQGfww2Vy3xIXAu9wDO2xMY7bgTQJODF5EQi4Q59zg+B1ODt7FElIS4HQ+v/34dbv1Ah8NrqleW+t14OSad7cEXAi8Cwm4GHgVCRbl8Azgm0igiqagBf/rR+BZCVaKGaor/ZY2l/aEC2reNCaE9LGXtrgy1diM4KuW8Lt/YPcDMqayAniVO+CiZm/mDvhB4JtIwA8DLyYBt3++Qmsw6bUa8wq2FeOoRoTjErkw9io6ZgR/dwGLVHMl8Mf+BzIaCCtYQvOTC5m9tJlJUD22JdVg1h0etQKsCP7lAtyO6mSWYJKwoaQWn4gEs2wVGxOOkSSYpuqaVHgECeZ1ingqy3BTUXl+E/gU3z4aYFEM9bAEc/B38wdonxLrSIJreW5ZDnuQYAaecm3UChjQNDG7B/m/QcoNJiDBXDZ22CiMluM6K1wQDoqgaqb12mMdS/6hcINlFqZDz9z3hVYnIcUVtg9dZmNyveZ+e4En3xpLL+aAfp43G0Fdp8UVsSCOKKWzEyKcbtAKbpAL4hwMotfmDF6vE78252mJr1RYo+G9KfpojHIOiYuwjlalNI3LCwYopFle1ChAky2GI7iOSc4xz+/SVK0+BrlEPH6HwgyR1MebSOBOqVHf/wB4polu0KoYHQAAAABJRU5ErkJggg==";

var img$v = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAZdJREFUeNrtW1GywiAMZDOeQHv/E9Z3hBenf05ttZAACSQz/lQHdjcJCRVSCgsLm9nQcC62iA3GSDfHCcOkm2CGI+JVsKMDeTQcq/oA7H0OVASmvb5UmQ8VwPSsLGghABvoKdRwwCl5NTxwTF4FF5yTF+MjJ/uIrmWQjZMXYSXnnhdjo8Lc8mRcqhg7834RdkqTGw2S+8VYaeDcv8SJBvR+tRTwZphdgEtpQJPkvygCMHIaRB8QAoQAIUAIEAKEAOUvFDxugCICfgiAgfmiNAKG3R/cpAPcH4/093wePte0szmOnuc4jTQ2QHuy2uSV5oA0AvibMDVIC+a4nLLTV4GS8zrWq0QW5tsMTl6W5fCLdV1/pgCclcQsbJswqBFWxsjjnfDHIvj+8CxUHETCpQMSW8hLvDjEEZm9kzX+G2Qv5LUaGD759CAvwrFxj4OSFUuOi6OyJOjhkRGiGqGuTl6SApKFcKjj8j2rgakLEy2FMHtlpqYYri5NaYlh59rcvn38Z7sbQgK+9v4fv0+TG+V635N5xt7MXlrTY+62KCOPAAAAAElFTkSuQmCC";

var img$u = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/EyXigxSxELFIEcXCoCiIWEkEbaJFEsFXk6x5CHksuxsk2Ao2FoKFaOOr8B9oK9gqCIIiiNj4B3w1EtY72UCCJLPM3o8zcy4zZ8AVzmo5s3UUcnnLiMyF/EvLK37POy58eBhhKq6Z+nx0NkbT8fNIi6oPQdWr+b6Go3M9aWrQ0i48oemGJTwtHN60dMW7wj1aJr4ufCI8bMgBhW+VnnD4TXHa4S/FRiwyAy7V05+u40QdaxkjJzwkHMhli1r1POomXcn8YlRqn8x+TCLMEcJPgiIbZLEISs1LZo19oxXfAgXxaPLXKWGII01GvMOiFqVrUmpK9KR8WUoq9/95mqnxMad7VwjaXm37cwA8+1Des+3fU9sun4H7Ba7zNX9Bcpr8Fn2vpgWOwbsNlzc1LXEAVzvQ+6zHjXhFcst0pVLwcQHdy+C7h45VJ6vqOudPENuSJ7qDwyMYlP3etT9GwWgrP+9tUQAAAAlwSFlzAAALEwAACxMBAJqcGAAACRlJREFUeNrlW1toHFUYnjm7my3rJs3s7DaJ1FoxtMYHS0Wo1fgg6IO9eEH7IJTqS2LVlnoHQRGEgrdijVYxffBWRLFYL7VEBR+s1kLViCAGW6tUsE3c2c092ezsHL9/uklmzs7sJdnZWfFAyXZm9sz5v/9+WVnyeCUSidZcLnctl+U1XJI6ZMO4hDPWgr/LZMYa6BmD86wky0O4Noh7f8iS9KvM+U+MsWPJZPKsl+eTvdg0Foutw587DFnewCTpcqdnDMOQQGDBZ4fnBnDvCDeMg+l0+jgu8boEAEQ3gctdOGg3DrzKC2Cx90kg1QtU9gOMkboAQFGUpTjUw2DLLvCwSarBglSMQX16DF3fMzIykvYLAFmJx7ugq7vxOV7svODcTwDpa3wegJQM8Gz2DOzC2Hhr6xg9ED13rjEQCDTKodAKHGi1xHkHqOwEkWtxO1Bkb82QpCeHNe11ek/NAGhKJC4NGsab+Njp8ogOIvo45++AW18ulEtLly5tBjA3Yp+tAOMmXAq5PPodk+W7YDBPeg4AuH4nz+V6oedRh9tpqEJPNpN5ZXx8PFlNsY9Go/GGhob74C12kclxUIsJSNl2SMMBrwBgMHTP4gCPOLx8Chx4RpblFzVNG/PYrUahPg/AdT4OJkQKDKUk7U1r2sPlqkS5ADTEVJWQ3VJomvkRHGgHxPwPqYarubn5YgDwMhiy2QGEQ2lFuVM6dSpTDQAawPlDeNEG4foMiH80lUr1SD4uVVXvh43Yg/OFhVt9KUW5tRQIpQCQwfn3Rc5D5M8FGNsMcf9eqoMVj8ev1HO5TyERFwpxw0eIF24vpg6BEsHN80C2S9j0FA+Frk8nk79IdbImJyfPhsPhD/FxA+yQOsc9Wb5sSSSiTE9N9VUsAWTt4ePfFYkPhUKdQ0NDg1IdrpaWlmWZmZmjBZEo53dBVd8uGwDy80zX+7FRo1XswflrR4aGTkt1vBA7rETM8K1VHXD2yWAgsBZxwm8Frs0JFApyrMSTwYPO31zvxNOCN/qTBwKbwPU540fuUuf8bSd6mYPodxVEeLD2MHgnitoLVeW1JLTY+0aSyX5kog8KhK6Dx7i3qApQYgPDcRLWI2H189CfjeUeJqVpco2Jl/FOt0TtY6jDzZZLqZyut1tDc7sEIKuzEk8RHgU5lXDCa0lw2L/Y+3aS/lu/jtziMUcVMPN5pLS2mwhvFxLheQVCpfsiBjgDGnbbU1O+g5KsAgComCHk82mK7Uu9xE3kEZzwWhBfSuXgtl+itNliEKMsGOwuBMAwugW56ik3sXE6BJA2D41/vhFPa3BwcAJ2bK/N8HHePWv/2GwNTwgespTSVnJIOgzEzbGS5Rfx88RkXzNzl/kQ8VIYyGusEnCH4Pb6FpLPI9CQq2kTqkE8rbGxMQ0SfkQw+FvmADCETA/Z1YGFcsxNEioFoVrEW/KCA0IRw3Ttslm3Nwxr7d2Ar4wvttjoRAAB4yYlXhI/6+WAQsqWAHJ+EaOmhZDw9C+W+FKGsdbEm99PpUaRE/8gXF7PqGMj6MbRarkuN3Vwc5FeEW9xed/YmC3Laxm1q4TnBqrpv51E3kkSvCY+L92/Cnagg1GvTkClqgCUYxhrQbwTc2EYVzJqVNoAyGbPeBHGVuoivUiq4N3+EiSxhUEMFOtF6th4lciUS5RXGSW11AQJiCEAZEusF2fbVX6B4GU6PTo6Oi5IRJhJ//PFIBa2ujk1Kv2q5HhdT2hqaooKKqAz+H1b0ENdWr+I9xoEoc5JKvAPuUFbiZta1LUk3k3nvQABHL9ICM0HyQ3aKj5mf77GxNeqqAIAVgsS8CejgSTBWXb4wfmF5g4Vrg4BkAFG01iCs7zOL7GvNHeoOA6Q5U5BAvplbN4GpP8W0mEVGeGwX5UcL6JDVVUbsSmlw0FLbnAxozk8GkWz2gYaS/GzjFWtoorA7RutxOPC72bVOO8ejggPb/WLeK/Ka0jytgr//2yuJEZDiDbjwNhNNJPjF/HVdpEIgGLYaKMAwME5AGgC0xxCnF8hcyDJR+JLfb8SwxgMBqkn2GAR8dPDyeQ3cwDQJXMC0+4jdtFAkp/EV8NFtrW10SDVLoH7vVK+XM8s7m+/kC7GaBrLb+IXaxinZ2Z2Cv3OCUPXey1lsvOLZm9p/FRA+XEaOHDb3E0MvUppy6ko28CJxZZDtZ8Qwt99rt1hIPOCZO+jReASXy52IJErXrfHy4kgLaLeIwx0Dmez2edsgFj/Q8EPzd4KtmATjaKVw5VazAaUk0PQUuLxbty8TQgGnqIukZD7FGaN0CuykOstX8wAyWtA7I//hSJHcyKxRtL149ZqF3T/xHA6TTTlXCVg9lkaPDZnb+elIKzncoeL2YN6WYqirAC1hwXipwKMbROJdwNAMqeuGdsuFBPaYCQ/p1G0eiU+2tqagFX+HEQtFwzfDk3THMv9roOS01NTPy+JRJqhI1db0kdV1/VbwuHw4UwmM1xvnGe53Fdg1GU2tTeMffBwu11rBKWqSIqqHhSNCUTq72AgsLlebIKp8yT2Audhuz5NpVK3OYl+URWw0mpOXUtSn6AOFwKEY82qep/vnIe1Nw2eQDy82RepWGxLMeLLkYDzq709rGjae7ABtxb4WsP4BH92UmpZS8LNIAd+vsDVzXKeiC9jXD5QnuNN5aanpz+gwWO8cJ1YZ0P6fE8kEqGs68eJiYmsl4RTbB8Khx/COz+AcbvCgSGk83fjzGWdQ14A8tsQIr8KNbjA4bZGA0k0kyMGHItdlNIiq9sunZ8ALUjV879auR86/0Yl+y4ockMOsErn/C1m8RDCmqGZnPxYypc0nLBAMaexvRuomJHP5xscDRWCHPLzbq6u6gDM2kKavYXffVpy+BGTZeVoMoOGE/L9+QHq0lLmOduro44NNS2obp8vXXdQARPfuaqEmg5TeAuA95Uydl4AYC5EhwqNn9IEpssvyaq+KEqlrI4Sm8WqWtWSFxo/NScwDaML3qLdE8o5P03FDMrnqzHHVFUArHuaQ4g0h2cYGxcNBue/UwGTanj5MlZ9/ni6mL+mzJIGkmgmh8ZSaDIDfxOwBcG8K83gc4p6ddSuoo4NNS1w67jX8cW/7UTXYK9/2wQAAAAASUVORK5CYII=";

var img$t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZG9S0JRGMZ/adGX4VBDRIODRYOCGERjGNRiDWrQ16LXezVQu9yrRLQGLQ1BQ9TS19B/UGvQWhAERRDR0j/Q1xJye48KSui5nPv+eM55Xs55DriiOS1vt4cgXyhasdmIb3Fp2df5jpsh+gnTndRscy4+k6Dl+HmkTdWHoOrVel/T0ZvWbQ3auoQnNNMqCk8JRzeKpuJd4QEtm0wLnwgHLDmg8K3SU1V+U5yp8pdiKxGbBpfq6cs0cKqBtayVFx4T9udzJa12HnUTj15YiEsdkjmMTYxZIvhIUWKNHEWCUguSWXNfqOKbZ108mvxNNrHEkSEr3oCoJemqSzVE1+XLsaly/5+nbYyHq909Eeh4dZzPEejch/Ke4/yeOk75DNwvcF2o+9clp8lv0ffqmv8YvNtweVPXUgdwtQODz2bSSlYkt0yXYcDHBfQtQf899KxUs6qtc/4EiS15ojs4PIJR2e9d/QMO/2gR3i+r3wAAAAlwSFlzAAALEwAACxMBAJqcGAAABZ9JREFUeNrlW2tv2zYUJWkpH7YsieUYaICi2P7/XyqwYeiHBvEjTryiqWNx99JixlyREimSsrYRcGVHNqtzeHhfJDnL3JbLJTsej0xyziR85nXNpBDqyuGKrZZwB+6/3cPvwd8EvF+tVlmfj+fotKqqEzAAJRzfqQGs0AQY713fk3DdbrejESBDyUHQapQ7wMQ27Jth3wnJ4A7w3gqZz+fqofBHgo3T6mb61K+vbLfbefNnw1R0gPdSgp7H3Gfk8D2q5HBQdmH/4YP62+XXr2w2mzFelqd+0CYYNoI2rbBZUYSCb2EqPH8cbisAhIQXjpZzlD5/Vpe9o4vr62tFDPbDh08r2XWzsEwJGUMCfvHw8sL2+3201E3iLi8v2cXFhfIWqcC7FBBMgrLU6MbgtVmvs8x7Tah2q3XjJgeA530EhJGAUgcCNv7GKKo9PDyo683NzclWRID3sfLeHU2oBT0zT93hvwk863PdTUTHhxqYKYCfLxadA+UkYH57a1rcqZPgHHluhObeBFyBpZVgaQPC5knLHj3GLQ6oLwGFO56fGglecx6xvDo8hrBKf3gCNVmDh0AXi0U3AZjYYE4emUVO0trrH2F47VYAyt4INTHCgx/8NjESvMHDgH6qyYBibmElQOXzVB5ABsTjv4cqoVos5Fjgq5Osrc+x3W7/FCR3QINoquCNAGmp3kBs/8vQ6QBWNykJNlIRPOQenbIvy/JnahCFkUaLdzk7oXq9Xj+HFlaaEVFM40NXFsMzFLzZlw94bPf393/RnIEbn4WWP3V7mNKGVpccvlamHHkE7gv+Dcvh0AqPVCXLGQkCQ0Py+dVqldQmuH4XAh7b8/NzS+G6QqX+rTnNcIcPGj6csBQtQklIBd6wZ7SIcSIACwzCUuCIaS4l+BrG1OCthIAC1NQ/kphfdtXwApXQqhw1hvEc4DebDbMNq5BUGglr+q7p4FJC7pGnyJTrzx222aaDTQljyL5lCFUtk/p/nr7Q02cYxwDvMoxCEslL6jMzKmFs8NS7qcoyIwo4tgshSZWQ8nuhjXo3pQAaAerlqnORkFP2T09PLUWMtZ452SaoLHChMmcbGgekaFdXV+0pQP0+LRiMCT43CXS6qylA3SAuUY8J3jXnc5BA8wFhc4P8DOBdJKQuqnBL0ie4JRU+x8gPzR2iAyFOAUdmgjGyD80dguMAmwKoYcA0kZaOxyxm+OYOoQ3XBGw+X+A+vL7S8diVnFRFlc4iD3zGnWbC5R7OBX5o7tBLAJV/81nY0kScBrgn51zgU7tIDIC4gxBFAEqBkqA2JAWSbNsfFF3JaXsL9QoxjAXdTgcKf2y24ApnJQgYWi6XvjKQ5gOmTmyMeMGcIl5KuLu7+6lrOgjT/dXt1HgfAj5nVmfrDwnpI+H7jx/f6Hon7jC1Bn5zcBWc5M8wNX7d7XZ/hIBnefcPef+fVVV9BBf65Z2RB/ljgbStAARsMKO9w8TAd/Xfeh4A+qW14kUqXu/uYjm8TjwK5yaBGj9cJXISgO2xf6fnVLbNBZGA09mUvpMAnSY6VoemtmfQiwTEMnPtPHdEYbYFkqlumOwlAQd0PWQP8/yf9XjpeE2pWZ9RL4OziNH7T2+V/d9vlhaxHaHE+mSWo+HS9ty+/SbIOxSxLKrDS2Bl8YHKssQ9OVmBQ2yP4e3bIY2O5/Q671CkkL2Otg4QSSIRGG3RgCO2YUqLWd0LgOeM+Zwh8iKhSD7nYVRKSKXVrtNmhGwBiK/MdfY20OhwFnhoKpnBM0fopqnH6ZqDPk2m1+pwdFFFvDl3pIIXQ96RFreThOiDk/pom8chpmRNz//AqWY9OJns6CwSoXZgdhx4jHdwUk2HwBOj6eXdG0E2x2mTkNGAxtdjhpPk2QMa05ApQnAE8SQogmqqz/q9aK7mvRwnxs32N2D2E/TuYxaGAAAAAElFTkSuQmCC";

var img$s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/YyTBBykUEbHYwoiFAVEQS4mgjVrECEZtkk02EbKbZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9YwIJorPM3o8zcy4zZ8A3k9dN1z8MplV0YtNRbTGxpAVe8NNNB0HCSd21Z+en4vw7Pu9oUvU2onr9v+/P0ZbOuDo0BYXHdNspCk8Iz6wVbcVbwl16LpkWPhQecuSAwldKT1X5WXG2yu+KnXhsEnyqp5Zt4FQD6znHFB4U7jfzJb12HnWT9oy1MC+1V2YfLjGmiaKRosQqeYpEpFqS2d++4R/fHAXx6PK3KeOII0tOvEOilqRrRqoheka+PGWV++88XWN0pNq9PQotT573FobADlS2Pe/ryPMqx9D8CBdW3V+QnMY/RN+ua/0HENqAs8u6ltqF803oebCTTvJHapbpMwx4PYWOBHTeQOtyNavaOif3EF+XJ7qGvX0YkP2hlW/cxWf6XLNyeQAAAAlwSFlzAAALEwAACxMBAJqcGAAAAJpJREFUeNrt1TESxCAIBdCw97+z2+1slQmgNHmv9guS0VwXAAAAAADAS8TDdauYq2Qna6WbyeSz2claWza92yObnaz1aACrcZXW4LVd3SsfGw7/v9fpw++oFZUBRGNIcfhtyGajFUg2ls1O1fqt/TRe3mhkd/+uy31+DjeWycVwD1sGMPH1T+55O4AoNlbJTdYCAAAAAAAAXugLTOAcJH5aTj8AAAAASUVORK5CYII=";

var img$r = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABbmlDQ1BpY2MAACiRdZG9S0JRGMZ/amGY4VBDRIODhYRCFERjGORiDWqQ1aLXr8CPy71KSGvQ0iA0RC19Df0HtQatBUFQBBEt/QN9LSG392RghJ7Lue+P55zn5ZzngD1S0Ipm1zgUSxUjGg55lxLLXucLDly4GcOf1Ex9PjYXp+P4vMOm6m1Q9eq8r+3oTWdMDWw9wlOablSEZ4Qj6xVd8bbwgJZPpoUPhQOGHFD4SumpJj8rzjX5XbERj86CXfX05v5w6g9reaMo7Bf2FQtV7fc86ibuTGkxJnVI5jAmUcKE8JKiyhoFKgSlliSz9r7xH98CZfFo8tepYYgjR168AVGr0jUjNSt6Rr4CNZX7/zzN7OREs7s7BN1PlvU2As4daNQt6+vIshrH4HiEi1LLX5acpj9Er7c03wF4NuHssqWlduF8CwYf9KSR/JEcMu3ZLLyeQl8C+m/AtdLM6nedk3uIb8gTXcPePozKfs/qNw5zaBHJcPVKAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIUlEQVR42u1bPY7UMBS2PZYQotmdTMMhqFhKGsR23IN6F1pEg7bj5xZUnICSluEAXIBmnEkFQsomPId45bGcxEnsTJ4nT7I0cX7s73u/diaUNMhms7H2F2VJ+kgqhK3b9hBqu3CdJM5jMUobz+12O2s/dwWOXRQukwgeO/AuIhg5caFd2m/ynZHiHAN8aLsNG58Y+KSiMLQRwWwnYwDvaiEnEQOkQp3T4Ny0PyY75be3JNvvD7CZz+MhJ+CDUFvhVRQFYYw1Fj7qHnlNl3DMpt23KrUGQUyAlcZdNOsqR7EAWd/rawTz2GEtMWitYLMa7sOMhpIwh2egcQEzGPsAj4oAPZv4Ao9yMdQGXsULmSajJMAFfN8swWIDH6ULhAKPgoCQ4FEGQZ/gnSrBOe4N+AKP0gJ8gkdHgG/wzouhMXsCvlwoBHg0FhAKPAoCQoJHnQYXAhwspnRYFPEYtdrHbRYXWAhYCFgIWAhYCDhhGV0H5Hn+iDF2Qyh9UedgGmqy6yT5/xanLL+lafpMDu/DAkqjmYNWr5NUU+/aVaOUfqnBi4NJhgIvhdKnSZK8HPioA7zjXYCxz/WvxDpZ3+DvOKBfZxED9kK8BZN87zJpX+DlsGB9PychQNbV8rW0anJzRG/VNWn6OgQJlvv3MIfHMKf17LKAbxJs9wH456D5H7NNgxUJhHwYS0KD5i98gw9SB4B5vhpDgpbq/mqavwTwWzSFUE0C6UuCOl8UxR8I8/e0gBcEfNBKUBZEBSEfXUnQ+6Gwul9r/sJnwAtSCXZsmV/nUDwBy1e1Zn8BuIct12fQztTvkJqfbC2QCXGtLKEDPKnBZ7Xmz6NZDOkk2ERahpHqtmQimWw1KEkAJ/9kr6Yry8hgFfUkNHi9qKua2RFSoGy+aiIBRr4UQnyPfj9AkmA3kOnBH21DRKZIsIR34Pu/pwx4gwg4O/c/N5k6V5S+4avVAzjcHvODLdtncyUEortgoP/fHrtIbLNwgTkJ07XdxlSM2pfYedcNNoKwAzfSb3+tH+sv9q6FjosoxS5fjg7xf8wWYLo0HeI7GAloimX/ANBjieJDfrkhAAAAAElFTkSuQmCC";

var img$q = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB30lEQVR42u2bzXKDIBCAw+ql6cnqpQ/Q93+f9gF60aan9GKwmkqHsXZA5Wd3YWcyySFO+D4WCLKKU+R4qush5u/DKfHIAlIXIFIDXs45eQhkAYlHiaUhTdMMcvgZniDcTE397Xb9vFweKQgoFfwU+ue1kFJ+AcDDf6J+RQKcqWRAv+cikyhqc4Ax71WPT73Pbg746Lpd/0uO7iVIrwIuNlJkBIyrhJddJBkBbdt62UIDp7Qf5xExL5PvLAXYwM+rxDM7AbbwLIeAL3gSAnzCoxfgGx61gBDwaAWEgkcpICQ8OgGh4VEJiAGPRkAseBQCPMF3JAQo+LV7e3vh9esGKd9M3xeppT2Kk6GYY/5PBiwb47sBmOCDZwA2eCsBVVW9Tg0fX63TsadNfLHgrQQIgBebHtza8+pQIyb81iFQc0n7YHMAdnivAijAexNABd6LAErwzgVQg3cqgCK8MwFU4Z0IoAx/WAB1+EMCOMBvEqAfOXOB3yRAHTlzgne6DOrwy3IW9gKWPa+Xs7AXQDHt9ThcJ7h2p8eiglPMdYF85oCpfvf+ble+OpDMAFNx8o7f7tELGHv2WhbF2SQGisJYv7soh+9JZICp3p565EdmsoDEQ8R+dpfSwUgeAlkAw/gGgdL3j4c6UpkAAAAASUVORK5CYII=";

var img$p = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR42u2bMW/EIAyFA7qla5Ol///HdUm6dguFKlQuBwnh7ADKs5TlTsrxPp6NAZ16H0czCMTXsijO90mNUw83DwC4OwAV5hZ37rYWoV6kAAAAAAAAAAAAAAAAAAAAAADcMh6CO63F7iwnkR2cUmqe57YcEIq3zyg4cWaapnYARM7rRjtLYupXY9ggaAHxzqKDtSgbAXdIkwBqqgK4QryP8J3OBe6xLjBVAFwpnjoh9rmDUJoOuhfxqXTwTiitCbon8WE6ROrCaQi6N/GxdFjX9XtzwWkIukS8/cHPmuKfnKD1W6kTdMnM2x/8qC0+VhNIPciGoEts7+nb75ro53cm4nCJ3L0ZkrqRvWSXRwokBZR9M9SzeJoOR82SziHYe5C6kA/A2cZB8E/PsXfh+zgqLt4+DgIl2cotsivEdizJlD0aZ84ymOy/G5nd5FhyJukQwHby8td60jW3hULpxP8Wu605O+vQrEaIQqDtZ20nePG+OStJz+xW+MkJpP2s4QQqvmTmizZDUSdsg7jSCVzii7bDHkK4PF5VEzjFFx+IOAip/lsSArf4YgCxZkl6iZQQ/zKAVJ/AnQ5S4lkA0Jog3Msv3OK5HBBdHZjj300TZxvOdjcoCYHrjlHMAT0HAAAAAAAAAAAAAAAAAAAAANwzFP47jBQAgFvHDyRnPtj60cBDAAAAAElFTkSuQmCC";

var img$o = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAeNJREFUeNrlm2uOwjAMhDsWJ4De/4bsEfD+WGm3QqTNw54460hIBbWNP2ec2G3Alq/p4RhIDP/jgczwmRyghd9NQ0AbzkUEeAtD1MBAzIIf6VwdjAUbvqdTJUgWLPjWztQAQAlO0JZ7wgAeTnMIvOFrOlFSzFr0oz3Xw/qGrNi1shWB4Hv7HrJVAiYvICjm9EQNkjJf2WGiUgSFv7LHLERlW6+Zzk8IPPotyVO3nRKkYhuBG7JTiDl+yLpBssV8rQMQHN5UQp6TX/TQgqw8ehY2SmD5U5psydst0JJVM9urgVo1ogKmld+SGT6CA6bCz3bAdPiSAzQL/CwFWD/4HHYAFpU9VlPACLyyQ4CVx09Pu+XEEA0MD28FRBp5ZSiAqYJReDDmgH+zzrc6wEIFVvCUx/S1D0SUHK+0dxRiMLIMeHoq3PoqWo3A6XPHaP6NzX/vkOvuMa809JNj0OFc9xXq1jByq+wSc00pV9knWM0g+77/fjkeTzAOMxKlCApgQzfPAbUZngaGLucB98fDKr3F26ck8VD1AIzga64L+cpdnOCXaZIZ/swBKeBLDkgD/8kBqeDfHZAO/uiAlPBX9TxKNcJL/y75ej5nFk5uq0CajVKXD0UrKsTlQ+AoV9afF8PwfwNGBXNgWGrhCQAAAABJRU5ErkJggg==";

var img$n = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZE9S8NQFIbfpkpFqx3qIMUhQxWHFoqCOEoFu1SHtoJVl+Q2aYQkDUmKFFfBxaHgILr4NfgPdBVcFQRBEURc/AN+LVLiuU2hRdoTbs7De897uPdcQMjqzHD6UoBhunYukxZXi2ti6B0BxDACAVGJOdZSfrGAnvHzSNUUD0neq3dd1xgqKQ4DAgPEs8yyXeJ54uyWa3HeIx5lmlQiPiFO2HRA4luuyz6/cS77/MXZLuQWAIH3FMsdLHcw02yDeIo4buhV1joPv0lYMVfylGO0xuEghwzSECGjik3ocJGkbNLMuvtSTd8yKuRh9LdQg02OMjTyJkitUleFskq6Qp+OGp/7/3k66sy03z2cBvpfPe9zAgjtA4265/2eel7jDAi+ANdm21+hOc19k15va/FjILIDXN60NfkAuNoFxp4tyZaaUpCWoKrAxwUwXASi98Dguj+r1j7On4DCNj3RHXB4BExSfWTjD603Z+Sp2ztrAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGklEQVR42uVbC47jIAytESeY6f1P2NkjLCOqInmoP5g4BChSpLZJAT8/G9sQuDHtfr+Tv/9P6WZp/35+tP6lDsEyXgBg7z0eD3qAVsE9AWgU/s8cOQG+vr+bAOCAiK2Cn9CS4TnwGrTIWYAItw9voGmfo56DJlI1DnD38jx75qGxOvcZRwuuCV++V888zaCmLyUkvlc+S0BE6uZBtBMDKHjYbvnMzVG6Rz0bvbSaByWo+0frR0GQWCSZicSE0Kv93Fm5mAl10V/4PSkrSGpRkgrAUXoatWbq8yVA8ujfFQBOg56UbxXQCoIXACytvUHwBjkepffL+Q0PYGqQseaxw5WWyScDcmyPr6uEYOzdnT3YcTcxwMsBtsTlXv1aVoJwpv0bNH16tDl8FThTmwygXeYSBtn61YAmLn6YlgFW0Bg/UgueatMYWQ+AWRiFQZjSBOql6kwneWlF6MyaA8E+6EqHtUleEQUeMD2ofcJH1QRPS4cno7tp/NjoMGbSIljpL4EfPo3ybwzAOzd5aRC0DSOTllEgBEPykBSAlmzBkjkhILyWJLb2Vy7qP54heW89oGu/rgiEKskiRdGETyurBUr7L08L0sA9FdhpTYBaZopmpMKjBwjO+5KiuVD9xVYPSuzXTRdAtdQRc90TnyMIBxBetuHib+jQxjYgPNnQ68m3igOsjm0nEALl4Q2BzvIgRC3Qwaewciu5A9pzr4sM65nAQRYszYioxPzqQUXsDzJbOMZMDwAX6GQB6vM522WDStKzdYt1HlCzQNrBXZEROAxuDYS2YUGtrAwGmw1+SmsNhdMm2n87Wxha1/PdvH/xa8GQg69eEL3ufMBszg+zPBjD2jRwgmfavv7CxC7rvqbcgA89E4cKYQNfkCTlDt0XmGDZezNt1QmuGBgJwvNvjeE/t5Siy3ncq/f9LcJTrA1Wp7GAQ2SFJ0+ItGx5C0XQNJPmhYIuiG+Otm5P9QzQypwjpmSlPR4TNDoTr6iRA40+ak/l95QD1+RaemdIE96UDqMDCUuBYBW+lhM0O1VC4nQl/SkW1MJrcvwCJhH28gf87HUAAAAASUVORK5CYII=";

var img$m = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/o6JoJIIWIhZbqFhEEAWxlAimUYsYwahNsskmwm6y7CZIsBVsLAIWoo2vwn+grWCrIAiKIGLjH/DVSFjvGCFBkllm78eZOZeZM+CbM3XLbRkDK5t3IuGQthxb0dpeaaEbP5ME4rprzy/ORmk4vu5pUvVuVPVqvK/u6EymXB2a2oUnddvJC08Lz23kbcU7wr16Jp4UPhIOOnJA4WulJyr8ojhd4Q/FTjQyAz7VU0vXcKKG9YxjCY8ID1pmQf87j7qJP5VdWpTaL3MAlwhhQmgkKLCOSZ5RqVnJrL5v7Ne3QE48uvxtijjiSJMRb1DUgnRNSTVET8lnUlS5/8/TNSbGK939IWh99rz3IWjbhXLJ876PPa98As1PcJmt+nOS09Sn6KWqNngIgS04v6pqiT242Ia+RzvuxH+lZpk+w4C3M+iKQc8tdKxWsvpb5/QBopvyRDewfwDDsj+w9gMBwWgLeGpB4gAAAAlwSFlzAAALEwAACxMBAJqcGAAABX1JREFUeNrlW21P4zgQtt0EcRwC2lJpkU6n+/+/aT+cTvthEdBS6B3Q0vhmjF2ZiZ3YiZ3SrrXdpKR188w88+qYs8xjNpux7XbLJOdMwnteVUwKoY4cjjgqCVfg+u4afg7+JuD8/v4+6/3xHJNOJpMPYABKeD5TAVhhBGCd+z4n4bhYLLrcjmzCylOCVlpuANN34NwM5w4XhmzD21sA4/FY3RT+kmDDjEqbT/X+zpbLZYwAapiL3jaktc1DNIfnyJLNRvmF1bdv6m/nP3+y0WjEeFl+zIM+wfIRdBiGjYoixMSlQyg8mQD8qCX8k0pbXi19/64OK88Ul5eXSjA4D09rVjshJBcAzrx5e2Or1ar3XLbgzs/P2cnJiYoWHRygVwhFKpsUGMbgNX94yEIoI1ATVisdJjuCT+cDFNVBAPNmZ5Rs3N3dqePV1dWHr4gDz2lY5Oz4hozJefivDJ61hW6T0R0y+PF02qhkrwDG19exHvdLap63KNIpgAvwtBI87bHQHiPGNSo0NAoUVuZ2DDaP4fLdEzGEk/pH6PAQ6HQ6bRYAFjZYkx+jtzdfwvTazwCkveX4MMOjXzgk8KDQPyuiUKwtnAJQ9TylBwhj2SHDmziolgu8/i2n5heLxT+CRDJ0iLZSdwKQju4N7xEGrxP7EgDqBA+1R+NNlmX5O3WIwiqjxaeanYj6oUNhY7SPksbzFGww4O25QsDjuL29/ZfWDNx6PzL0p/U2lrTr9Tpa6y4DfXl5Sab5387O1CsE/C6sg8Y/2T4w+/T0lL2+vnoyQZBQl3re18HtygIX7XHEgMfx/PxcY7jJc9T/FbF1KWVnjWE/QDh8R6wQUoH3+jMtEIENBuFocPQZPiaEOsbU4J0CAQag6YstyfllUw8vkgm1zpF2jPsAP5/PmUutQlJqJKwBfObgY0JuzVNkKvRLlne4zMHFhCFoX3OEqpdJ43+GHkCbYxwCvM8xCkkoj4sWQzFhaPA0uqnOMiMM2GZshDgc46Cap9FNMYD21s1y1QBCGJz2T09PNUbsq+3TqZ7PMQSlBS5U5hw+mzfgM5bS7OLiom4CNO7ThsGQ4HP3E6i5KxOgYRCXqIcE77P5HEKg9YBwhUG+B/C+BdXUTRXuKPoEd5TC+9B819qhdyLEKeCEXeFY2sfWDtF5gIsB1DFgmZiiE9w1wwutHWIHrgm4Yr7AH2xrHQ/dyUnVVGls8sB7fNJM+MLDvsAH1A7dBEDpr98LV5mIZoDP5OwLfJNj7CIETIC4RyBKAEgFKgT1QFKkkF033LuTQ+bE9/iKcYwFfZwOGP6oGSa8nSCQ0Gw2C6WBdN1wqsLGzGnPjSYSwoSbm5uzJnMQdvir6qXxKgZ8zqrOw65WIbyu1//R9U58wtSZ+I1hMk7qZzCNv5bL5d9fvapz+orJ5A8IoT8+OXmgPzZI6wxAwJZkTHQ4VPCKIfP5DxrhNqTj9ekqtsOrSJv/quA9yYBaJfIKAMdj+4LoQYJHc7ap7xWAKRM9q0MHC37ke/Lcm4XVv3CYtNcK7bLUr6KCBd71+vJDbehoKomP1uGF9gQ8YPmvAJ76AEnOg8AjxdpolinJsU208yhaNN2qebV5Cbws3lBZlvhMTlbgkNtjervbpJFKADxACP5HznXE2EAmiYLAbIsmHH0HlrRY1b0BeM5Ysj1EBQHY3+ZBKyWU0uqpU60hVwISSnNTveVyOoUDaJLwZmvoSvfjTM/B7CYza3WoXWQR1/uOVPJi0Tunx+URoc/5WbO1LWATU9LMDu0/hanxiPjfqAgUhHoCs2HDY4piBs0hYMdoEgG48oLw7Evv8e0tDA0aX48ZdpJnT2hsR6YEghrEnaAISnefzbnQR/taxx3jweN/nwXieSq4/nsAAAAASUVORK5CYII=";

var img$l = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZG9S0JRGMZ/adGX4VBDRIODRYOCGERjGNRiDWrQ16LXezVQu9yrRLQGLQ1BQ9TS19B/UGvQWhAERRDR0j/Q1xJye48KSui5nPv+eM55Xs55DriiOS1vt4cgXyhasdmIb3Fp2df5jpsh+gnTndRscy4+k6Dl+HmkTdWHoOrVel/T0ZvWbQ3auoQnNNMqCk8JRzeKpuJd4QEtm0wLnwgHLDmg8K3SU1V+U5yp8pdiKxGbBpfq6cs0cKqBtayVFx4T9udzJa12HnUTj15YiEsdkjmMTYxZIvhIUWKNHEWCUguSWXNfqOKbZ108mvxNNrHEkSEr3oCoJemqSzVE1+XLsaly/5+nbYyHq909Eeh4dZzPEejch/Ke4/yeOk75DNwvcF2o+9clp8lv0ffqmv8YvNtweVPXUgdwtQODz2bSSlYkt0yXYcDHBfQtQf899KxUs6qtc/4EiS15ojs4PIJR2e9d/QMO/2gR3i+r3wAAAAlwSFlzAAALEwAACxMBAJqcGAAAAvVJREFUeNrtW01y0zAYtRQPadzpkEQ5AwcoXcCGHSdgxTFaTtA9tGy5BxumnemCbXoD9mwsJ6sYZlqLT0EeUiNZ/pHj2P40o3HGcWS99733SXJk4hnKYrHQnk+E2B4jzr1DKXPGtkdKiPGaMAy150c64EEQGBsS6hjHca1Ow31ePhuPf0yOjye/4viuTlsT1V+SQ4DEJOtms3lyntgi3oQCIGIrOEx3z0F7pEkFmBRB9y1XxthZFrwsM8au27APsUXf5J2q4EE/NzoClL0+rzg/d3U/m6oltlHqD92XWb/U9TwAXMLHoyRJfoJfTzTReDUOgueQE765uKfsv6ymnCa/G+lYchn1FDzkjlsJXiWrkxxJvnZJginA6fnGc4BMeAB+qWS/zk2woAyVmM6njF256oMMqCmoJKsAl9FXkV9W/X3ieddrzi+qev3h8dFbr1a519IijetqgchHKXiIbGwb7nTnpRKgHVGaOBiqZaXULvBGLCAjL0e2v6ld/IaOTIqM9abvgYRPRQCntUyhTYCHTtz8MxkZl5noGK67sJFQtVDH4E+V7Gd1ZnlGEubzj3X7mFULrSMfDfjborKuRAIhH1yQ4FwBKuHd1418GyRQB7J/kQXuAryNBFg7XB4EAUKIt02BN7TH1azpvea6dEK1PwI451+Ahe9Ngde0y+B+X4H4dzrwW1C0OCzfQd8eoih6s4+la84k6jCGwS4WJGDoBFhzgOtnA6gAJKBjFjA9cOiLNdACSAAS0K+yOy0WBRZFfh+jWmZtgBZAApAAJAAJQAKQgGGvBrN/Bz158Cg3IO3+Y3RI2+MqFoEKQAJKECAlL/ffpbXoBoku5YDWFyzpRsfBWCCbSNtMrJgDkAAkAAlAAoa+FhhWxDMvVfhl3rJACyABAyRgOpv1mgD5vsB/+2PDMOxlYtBh9VvqiKchvR0L6KKtY6qP0ZfYfdsPum4HWzBJlajX2Va/74mOqaSBHfwwWMn/XVZA1tKkine6SIApl/0BVV9uhgTVncEAAAAASUVORK5CYII=";

var img$k = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAIkklEQVR42uVbWYwTZRz/vm96YOku207r7hK8IgHXBw3GBI/VxEQfBFGM8mBCxBdWEAheaHwwJiYknhFX0YgPXsR4EFFBsmpijAKSeGBMDBtBNJggu3baLnt0u53O5+8/duvM19lDaJd2/L+0OzM7M//79z/KWY0pmUy2FYvFqyXnl0rGOrhlXSCFaMXn2VyIEF1jSVlgnPfjWB/O/cYZO8Sl/FEIsT+VSv1Zy/fjtbhpPB5fjI/bLc6XCMYu9rrGsiwGBiu+e1zXi3N7pGXtyGQyB3BI1qUAwHQztLwaL9qFF15QC8Hi3ochqW2QyqsQxkBdCCAWi83BSz0AtWyEDpvZDBCsYhDu022Z5rMDAwOZMyUAHkskVsNXN+N7YrL3heZ+hJC+wvdeWEmvLBSOIS4MDrW1DdIF0RMnmjRNa+LB4Ll4oYVMyg5w2QkmF+G0Nsm9DYuxR7OG8Qo9Z8YE0JxMXhiwrNfxtXOCS0ww0SOlfAva+vxUtTRnzpwWCOYG3GclhHEjDgUnuPQbwfkqBMzDNRcAtH6HLBa3wc+jHqczcIXuQj7/4tDQUKqaZh+NRhOhUOgeZIuNFHI83GIYVrYG1rC9VgIQCHRP4gUe9Hh4Dhp4gnP+nGEYgzVOq1G4z71InY9ACZGKQMnYloxhPDBdl5iuAEJxXSfJrqgMzXIPXmg9zPw3NoPU0tJyHgTwAhSyzEMIOzOx2B3syJF8NQQQguZ34kFLlONjYH5TOp3uZmeQdF1fhxjxLN4vrJzqScdiy6cSwlQC4ND8u6rmYfInNCGWwdy/Y3VAiUTiMrNY3AWLmKvghg+BF26bzB20KcDN05DsauWmR2QweF0mlfqZ1QmNjIz8GQ6HP8DXJYhDell7nF80KxKJjeZyPf/ZAijaI8e/rTIfDAY7+/v7+1gdUmtr69n5sbGvK5ColKvgqm9OWwCU54VpHsSNmpxmD81fPdDff5TVMQE7nA/MsM/pDnj3kYCmLQJO+KUitXkJhUCOk3kKePD5m+udeSJko9+lpt0ErZeDH6VLU8o3vfjVPEy/C2axTjGh+2FCO1mDUH5k5EQ4EjHAx1KHqc+LRCJ/5XK5byd0ASpsEDgOI3oknXkezC9lDUjg5yO4w82OQ+miac53QnO3SaCqczJPCI9ADmtc2kD+70xsqC0e8owBdj2PktZ1EvB2phFeNQkY4Bh42OwuTeV6KrIqBEDNDKWezxC2Zw1OSNvPU9nsCIhREQh0VQrAsroUPN1d68JmJqivr28YcWyLK/BJ2TUe/3i5h8f5Acc1hbF8fm61S9ozRU1NTXowFDpOdY1D4Z1wkX3jFnC7kvZ6/MI80eDgoAGG9ygBf0XZBSyl0kN1tZ35jBDPtitNDDu1c7tvb1nO3ruFXJk43WZjvRFlOUgh7QJ/Up4jaGihFDwH/ca8jYDS6ZOoib9XDl8paGKj+MbXzKcEf9/rUjbniwSNq5Trev0qAFj3ISUOdAia1SlS8a0AVOUiMJ4vaFDpEkChcMy3FiDlHwosbg3ADGLMMZikiY1nFNV12UjMpg2jotlDIzWhaU4LiAMai1nOi8bHVX6kkydPDikWERbsf04CZuHqm9Og0q/MNjc3R5UgaAbg/wR6yiMmmtLiIzUdn2o4bbv7nOQCf1EadLW4aUTtVwuAxs9RGj59lAZdHR97Pu9fASxULOB3QQtJSrLs8HHM61AE0itoG0tJltf4lXuU/Z2KBRzkiUSiHYjouFIO66gIs35iXtf1JiA5KocDjtrgPEF7eLSK5owNtJbiQxh8g5N5HPjV7hqX0sMe5eKVvhMA5yuVvz8plci2KexwBQchbqSdHB8BoLhzTFYSwI6yAGgD015C/JeC9kKSTygQCKxljo4wTPxoNpXaWxYAHbI3MN05YiMtJDU68+3t7YRyNyra38ZKK7fCkf5epXLRWQHTNlajC2B0bGyDMu8ctkyzrOxycTw6Opo/a/bs2fCVax0NgyvC4fDb+Xy+IVNiPB6fh4D+HgBPyIF0t2Sz2V3llOcCCqb5DHPP0SJIiS80cOTvVhY6s4VC4SnnNa4FCWh6NByJDLoiJucLIpFISl0sqHcqLXpsUsDAwwB4Xyq1T2XVGNd1ipBXOv4xD0leBdD0QyMw35JMXspM84Cz2wXf/zabyRBPRRezXpCZFo/t3dt/rSBsFou7aQGp7jUfi50LbncrzOc0Ie5UmZ9IAMzeuhZijdJMaAdA+pRW0eqV+WhbWxK57VMwNU+p+9cbhuHZ7p9wUXI0l/tpViTSAh+5wlE+6qZp3oLMsLveMgNpXhSLX0BRF7nc3rK2AuhtnrBHMFUXKabrO3DRre6K2Toe0LRl9RITbJ8ns1c0j9i1K51O3+pl+pO6gJNXe+uasR7FHeZCCPtbdP2Mw2WK9nbAU5i3GPssHY+vmIz56VjAPzR/fjhmGO8gBiyvyLWW9TE+NlBpOeMgB3letc6y5on5aazLa9N6WjpdBFJ8nxaP8cDFSltpIdDW3cAKVHX9MDw8XKg1tg+Gw/fjme8juF3ioRDy+bvwztN6D34Kkr8TEPkluMFsj9MGLSQBbb1MaynVLmlR1a2BxO9jHj/SKv1qZR18/rX/ct9T6vUnEokFppRvCEeGUGiMdnJKaymf03LCKZo5re1dT82MEjoNeQYqgBzK8xOluqoLYDwW6rq+Fnn3cebxIyYHFWkzg5YTSvP5XprSUuU5PqujiQ0NLahvX2pdd1ADE/9z+RRumoXFPQYBb50q2NVCADYBHcZo/ZQ2MCf4JVnViVAqzH0rFTan62pVG3fR+qm9gWlZq5Et5temvJNHqZlB9Xy19phqMe/jQGVX2Xt4lrX0tIUh5a/UwKQeXqmNVZ8/np4sX1NlSQtJtJNDaym0mYHPJGJBoJRK8/ieplkdjatoYkNDC5w6UGt88TeBNfhPMH+OaQAAAABJRU5ErkJggg==";

var img$j = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/EyXigxSxELFIEcXCoCiIWEkEbaJFEsFXk6x5CHksuxsk2Ao2FoKFaOOr8B9oK9gqCIIiiNj4B3w1EtY72UCCJLPM3o8zcy4zZ8AVzmo5s3UUcnnLiMyF/EvLK37POy58eBhhKq6Z+nx0NkbT8fNIi6oPQdWr+b6Go3M9aWrQ0i48oemGJTwtHN60dMW7wj1aJr4ufCI8bMgBhW+VnnD4TXHa4S/FRiwyAy7V05+u40QdaxkjJzwkHMhli1r1POomXcn8YlRqn8x+TCLMEcJPgiIbZLEISs1LZo19oxXfAgXxaPLXKWGII01GvMOiFqVrUmpK9KR8WUoq9/95mqnxMad7VwjaXm37cwA8+1Des+3fU9sun4H7Ba7zNX9Bcpr8Fn2vpgWOwbsNlzc1LXEAVzvQ+6zHjXhFcst0pVLwcQHdy+C7h45VJ6vqOudPENuSJ7qDwyMYlP3etT9GwWgrP+9tUQAAAAlwSFlzAAALEwAACxMBAJqcGAAACZpJREFUeNrNW11sHNUVvnN31xtt145nZxfbiL+KQHAfioIqpYT0oVJ5ICEUVPKAFEFf7AZIlLa0lZBaVaoUqX+o1DStGh7a0qhqRVRKoZEpUh8KhUi0BFWqsEhIUCqR2N3ZtWM79npn5/Y7w665e3d2/nbG3itZO56Znbnnu+fnO+ee1VjCo1QqjTYajbuEpt0uGBvXbPuTgvMRfF6jcT5A99hC1JmmzeHcLK5d0Bh7VxPiHc75G+Vy+VKS89OSeGihUNiJjwdtTdvDGfuU2z22bTMI2HHsct8Mrp0Stn2yWq2exinRlwBA6CGs8gQmOokJ35oEsHj2WSB1HKg8CzAW+gIAXde3YlJPYFmOYA2H2AYMaMUizGfKtqynFhYWqpsFgKYXixOw1aM4LnrNFyv3DkD6O45noCUzol6/CL+wuDQ6ukg35C9fHkylUoNaJnMDJrSdCTEOKXdDyB24nPJ4tmkz9p150/wlvWfDABgqlW5O2/avcbi7yy0WhJgWQvwWq/Vq1FXaunXrMIC5G885ADDuwalMl1vf5Jr2CBzm2cQBwKo/JBqN47DzvMvlKkxhql6r/Wxpaakcp9rn8/niwMDAY4gWR8jluJjFMrTsILThRFIAcDi6H2AC33B5+QpW4Puapv3ENM3FhMNqHubzVYTOJ7EIuQ5HydjTVdN8IqhJBAVgoGAYhOz+TtcsTmFCh6DmF9gGjuHh4RsBwDNYkH0uILxQ1fWH2LlztTgAGMDKv4AX7VHOr0H4b1YqlSm2icMwjMfhI57C/LLKpemKrt/vB4IfABpW/g/qykPlL6c43wd1/yfrg1EsFu+wGo2XoBHXKrzhT+ALX/Iyh5QPufkRkJ1QHnpOZDKfr5bL/2F9Mq5evXopm83+EYd74IeM9dXTtNu25HL66srKdGgNIG+PGP87VfhMJrN7bm5ulvXhGBkZuaa2tvZaBxMV4hGY6nOBAaA4zy3rDB40KKs9Vv6uhbm586yPB7jDTeAM/5DNAXO/mk6ldoAnvNcR2txAIZIjC08ODzZ/X78LTwPR6AORSt2LVV93fhQuLSGec5OXu6j+RAfDg7eHw3vL018YxoYK6vW+hXL5DDLRrymC7kTEeNTTBCixgeM4C+9RkuM87Gdv0MlUTHPDhe/2TsjzIszhPvnWhmVtk6l5uwYgq5OFJ4ZHJCfMZJLWhJDPP0z2L38ducW3XE3AyeeR0rZdBL2NwvCSBIFWG/OiP9H6Aw9wvRcc4CKuH21PTcUhSrI6AKBihpLPV4nbB5lQF3KSFOlhLlWhrlUihO2fUtosOcQ8T6cnOwGw7UnliVNBExs3EIC0owkb7RzVMTs7uww/9nSb4xNisuX/eKuGp5CHOqW0UVQzYcrLotQE6/X6L5zc5WOKeDMc5C5ZAx5Uwt50lHweRCNWnyB/L6rwNBYXF01o+CnF4e9fB8BWMj1kVyd6dVK9ghBSeF/Vgz87oRQxnNCuOXV725Zr7zZiZbHXYqObwARMNy3x4hVeAOB5geyOohxQqLQlgEJcz2nTQkl4zvQqvJ9jDANcL6rfNp9K5Qpy4n8pp+/ktGOj2MZrccfsoCGyCzg9qb5Cel5ve7Cm7eC0XaXcNxOn53ZT+W6aQIDJfz5RRQtiTop2v6v4gXFOe3UKKrECENUx+ql+WOHdFheO8SZOG5VtANTrF5OI4WEmHIfXd9UAIf6raOIIhxro8knasUmSx8chfMTVd7bUFA0ogADyLfLJ1nbVZoIQlyap48qVK0uKRmR5P1VzklJ9z8gAtWirm9NG5Wbk80mqfmsMDQ3lFROw0oj7RHrWt5hol5Y0LcJK+U6wh8ywZ+GbqfCgYgL/ozDYVuKmLeogDtXtnFcNYBNCnls+cL1CzWcpDF5QjGx7D+9wBaGb8H48PwzXDwjAdkUDPuDUkKQEy/Ee39MGgpfwQeYcc0FlXAFkhlM3lhIsPxdkYlE0oYvwws/u4yqvIe3frWjAGQ0PHwMj+lBJhw1khPMxVGe6Oq+gqh9Xyd0wjEG8jNLhtJQb3MipD49a0WTfQG0pQQhJAPsUEa9pMUcRWu27ZeFx4n2natwMD6eUmw+E8S0+mhI2l/cMeVFBQJJ3QPn/L+slMWpCbJsB5/dQT04IahoKBC9QwlaMAhKgAia4VwHg5DoA1IHpNCF+PDJOQ1I4fh4IBB+N0IJGizCOMZ1O057ggKTi5+fL5dfXAXDskTow22PEEWpISgKEsKoftbxGY2xsjFjuEWX1j7d8EJfC37NKuligbqwImVoU4uJLdaNWm1fX1g4r+53LtmUdl8pkHw3qvaX2UwXlJ6nhwCcU9gxCUKoblhIXCoXrYNrfVujvsa67w0Dmx6x9Hy2HkPhM2AmFASEs1VXNwYsbQNWnlIbO+Xq9/sM2QOR/iPxQ763iC+6lVjQ/r6yqYosneAkYlee3hPYSXi8WJ/HwBxQy8F3aJfKL4RzCkIe8U/piDUjuwoTf7qHYIZJKctQxXCrdzizrtFztgu2/NV+tkkwNXxKDyd5iNRrUJPUJ6QGXYE+7qAeH9fHQdf0GQU1SjF0nzX0lxfkdpml2VLx5F9WkHyYcVIoJY3CSr1ArWr8Knx8dLUHNXpGFbzq+Q27COwWgruFjZeXfW3K5YajIZ6X00bAs64vZbPblWq02328rzxuNv2Ghbmsze9s+hgh3NGpay3XDOKk6E6jUh+lUal8vPiF2m7ftl9WVh+96qVKpPKDava8JyLI6XdeMTSvmcC1AeGPYMB7b9JWHt3ccniI8otlfK4XCfi/hgxOWbduyumn+Hj7g/o5Ya9t/xsdhSi03UnCH5CDOd4S61sqT8AHa5VPBAm+lsbq6+jw1HuOFO9U6G9Lnr+RyOcq63l5eXq4nKThx+0w2+3W883k4t0+7LAjZ/Jcx50Dz0CIg/zAo8s/lECkNkxqSqCdHJRy9DkppkdUdZB91gHZw8OavVh6Hzf8qVBISkdTcagnxGy5FCGWsUU9Osy3lVWpOiKjm1Lb3BSpmNPP5AVdHBZKDOP9wt1AXOwAtX0i9t4i732MuP2KSRoM6M6g5obk/P0O7tJR5tvbqaMeGNi2obt8sXY9TARPf+YyPmc4TvQXAx/ycXRIAOAPZok7tp9SB2eWXZLEPSmkpq6PEpldTi42PU/up04Fp2xOIFtsSkVyI81TMoHw+jj6mWAGQn+k0IVIfnm3v7RkMId6nAibV8JplrP788bRXvKbMkhqSqCeH2lKoMwOfJfiCdDOU1nBcob062q6iHRvatMCl00nzi/8Dx0Tcgl7ehnwAAAAASUVORK5CYII=";

var img$i = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAaNJREFUeNrlm0sOgzAMRHHEEbj/CbmDq7Ko2opWxBk79pBNuwCTN/4lCshSc+jbfxkxJMXhhzmEAH6IRUjgzTxCBG9iaoXhBSBW+gi4Aq8jbELiebMIQhL2ZhGEBN58rxDBm2wIGXy3LSGE77LZSOEv399I4S8viORm8GlqQDR8qjaYBn5GDZie8zMjIEXOzxIgJXyUAGnhIwRIDe8tQHp4TwFKwHsJUAbeQ4BS8GgBysEjBSgJf2pk27bjd993evjnWL/B7+J5xGaoPPxLAIP3KeCtEUADfxg+8/6fAkgF3xsBdPCnAvzwPiX8Rxsk8Tz8bDAzPOStkdUw8dnwipxf73l7NnjxqgG6+AwFpSKsQDYQQEl49EqwHPw/g8iXEhHwbmsCj91gGfgeAQSYDqneS2oArym4jWqkWM2hZmgV+F8PUcM1iLDXGWnSgMKhcj60RvTsBTwLni6ThjhOxgIf3iHWIFFTwp89VIPAU8BbIqDiV2bDAngfoU8VVYInqdkiKmpTolnTCXEuUBbeskTtTZ30RTRqpZa2eyA/R6FvmZTjAXQIhaMv+ge0AAAAAElFTkSuQmCC";

var img$h = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAIPUlEQVR42uVbW2wUVRg+c/ZSUrelsxfaGkQNDVgfJKgJAuVNg1yDER5ICPrSigJWQU1INCYmJEokQLEQIPHKgwYSULABeQPEJijwRiPXYKK07uz2Kt3uzhy/f90uM2dnt6XdbXfH87LbmdOZ83///bIKK/AKhUI1uq4vFIoyRzBWrxjG44LzanxOUzj30h5DiDhTlC5c68S9WwpjVxUhrnDOL4TD4b8KeT6lEA/1+/3z8LHaUJSlnLEn7fYYhsFAYMZ3m30duNcmDONoNBptxyVRlACA6EpwuREHbcKBZxUCWDz7GpA6CFQOAYyeogBAVdWpONRWsKUZPKxkE7AgFX1QnxYjkdjZ09MTnSwAFDUYbISubsf3YK7zgnNXANJZfO+AlHSIePwO7EJff01NH23w3b1b4XK5KhSPZwYONJsJUQ8qG0DkXNx25Xi2ZjD2QbemHaD3TBgAlaHQTLdhfImvDVm2JEDEKSHEN+DWmbFyaerUqVUA5gU8Zx3AWIJLnixbf+GK8goM5rWCAwCurxW6fhB67rO5HYUqtMRjsc/6+/vD+RR7n88X9Hq9b8BbNJPJsVGLAUjZBkjD4UIBwGHoPsEB3rF5+T1w4GNFUXZpmtZXYLfqg/q8Bde5DUwozzCUjO2OatrW0arEaAHw+gMBQnZNpmkWbTjQJoj5LTaBq6qq6lEAsBcMWWEDwrGoqq5l16/H8gGAF5w/hhctla4Pgfh3I5FIC5vEFQgENsJG7MT5yqRbpyKqumokEEYCQAHnv5M5D5G/6+J8BcT91zHHDYGAJaCJaNqYPVIwGHw6oesnIBEPS3HDccQLL+dSBz5CcLNDJh4PvS48noXjIT7fC9b/Es61EIz53cI9zlepgcCunIYtl7WXDR4R7/F4Gnq6um6yIluwQbfLvN5FGSAw9iYYuf6BACA/D1d3QBZ7w+NZ3NXV1cmKdHV2dnaBSYtx1j+tkZjYDzWZNVoAFApyoE8VZoMHnV9ZjJy3kwThci2HgU4bP3KXCSG+tqOX24h+Y0aEB2sPnb/ISmT1hMOXkYm+LRE6Dx7j9ZxegBIbBDPXoPshs5+Hq1uW95Q5j14gR6L2PQzhSvNr9ESizhyaWyUAWZ2ZeIrwKMhhpbs2g4Z/zLgjt3jPVgWS+TxSWstNhLcTHeHlcyEGuAMatksGcRMlWRkAUDFDyuejFNuzEl9w23sobTYZRB93u5syATCMJimebil0YjNBrnEAdmy3xfAJ0TRs//hwDU8qY8UppWUOWfF4fH8yd0kjoMyEgVxgloDVkts7le98fjJXX1+fBglvkwz+mjQAhpTpIbs6zBy2YM8OS0WMpGvnVLeXStcGlbGY8xbRpJsSpTqo/nROTQsp4bk83kprMS4Ec73IiX+TLs/n1LGRdOMcc+iCpJ+3MFtR5nJqV0n7OpwKAKT7qmQH6jn16iRUHAuAzFwYxsc4NSotAMTjdxwrAUL8IYXF1W6IgcpMjUnq2Iwmeyt0djhuo2eTXVJLjbtcZgnwIwDkU8ybhttVTly9vb39kkSUcfY/XxxiYambU6PSqcRWVlb6JCOYcEP/KehJt5ioS4uP8Gh0qtgrQhncttY5SQX+JjdoqfJSi9qpEgCOPyIVfDrJDVoqPsn+vHMBmC1JwG1OA0mSs6x3sM2rlwDp4DSNJTnLRU6lHml/gyQBlykOuGBBhfO55qKhU1YgEKiAz39GutzOaQ6PRtHMtoHGUhwYBhNNbtOFG8mqcco9tEmb1zkOAEVZJ/39YypFTqaJRyU1WEIzOQ4KgPww9sskAI6mAaAJzOQQ4v3lSQ4kOWS53W7qCXpNIn6zOxw+nwaALiUnMK0+opkGkkqd+NraWopymyXuH2SpkVtucn+HKF00R6s0jVXqAAwODW2W+p0DRiKRZnYaAJq9pfFTqWCwDS7xsVIlnqq+UO33pfC3NWt3GMh8yqx9tHK4xL0lbPlbpIHO7ng8vsMCiPkPINNNs7eSLVhOo2ilRrwaDDbB8r8kBQMfUpdIyn0ys0akqmQh55v+MQYkF9A0Vimkw1Wh0ByWSLSbq13Q/Yvd0SjRpGeVgOG9NHicnL29LwVlCV0/WQr2QFXVGaD2pET8PRfn62XiswHAklPXnG+Qigm1MJKnq6urpxUr8b6amhDE6jSImi4Zvk2aptmW+7PWBGnqmgaPJRBmxYaGzhWjJBDn3bHYWZzxCYvaG0ZrJBL5PGuVKNdDaeqaBo9lECAJP9N4arEQTzovcCaZeNiuE3DvzTmLJCM+va6uzB+NHse3F6WHx5Bfb4Gk7Jtsay90fY9c3oc3+6lbVVeOd1g6DYKqad/S7G2GrzWMH/CxmVLLCQ9y4OczXF2K8xG/f81oxuVdo3pbJKIPDg4emVJeruKF86Sy0mykz6+Vl5dT1nVpYGAgXujY3lNWtgXvPALj9pQNQ1rBjFdx5lGdQxkD8usRIu+DyD1kc1ujgSSayZEDjnyktMjqNrD/JkAzUvXUr1Y2wuB98SDPHVPwQYPHCSG+ggV9LsuWIZrJSY2lnKHhhDGKOY3tPU/FjFQ+77XbR0EO+flsri7vAAw7BJq9hZf4iNn8iMm0dJrMoOGEVH++g7q0lHkO9+qoY0NNC6rbp0rX9VTAxP88O4KadlN4C4Bb7YKcQgOQXIgJVBo/pQnMLL8ky/uiKJWyOkpsxqtqeYu/qZKcnMA0jEYaQCpMeiduUjGD8vl8zTEVoh+nJIcQaQ7PMJaNGwwhblABk2p4qTJWcf54Ope/psySBpJoJofGUmgyA58h2AJ3ypXG8D1CvTpqV1HHhpoWuNVe6PjiX7rk5GR8PE/UAAAAAElFTkSuQmCC";

var img$g = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAA0dJREFUeNrlWwmO5CAMjBEv2On/v7BnnjDeZhUkixgfQELIIkXqzgG4XD64YKuU1+vF3v9F3Dzl5/vbVX9PewGg+uz9frP3wduxskMVAdHSlgeImgB/vr5MANTqid6OGAoK92GbXLKcGYgwuH7sfH55iZr2a9TrBAmkdjxsrPkYrZ70LLUZBwpes3vUQCjbSv+5zpf05YSkz/JvCYjAPRykdZCcX6vtWjTrqTOeZPtgZMIQQDTFSUwIrdpPlY2IHFqnRxauzrDNKzhKwz2hPFxA/22UL7AI6AVhJgOGULrXVOJoRK8UvhY2c4zXwuQ/BqTcnl53FHB09KCgTDeBGsPOYl5pNuHJmr7ECVobKqnXo+GRoIWRdmUNU/m9VhBGmkeYaecjtcy9Lw2oLgWgFq8/93BPpNjrrDR5ehRwJDBIQDqFlXGG8C3ffDqMwrfQCkLs7fBVmaLSD2wF4w5jAahcbpB306qaDAfi5SZAhfl0SJoqB6pdmt9bTWYTpt1cANxlQLSDAJY5hV1g1TSWHg5z5qL4iQNgkU4rJ9oI2gZrsjEJiEx70VSSj/i8BwcG5I8lBBWAblO0PlJHGYzCl0B0aarQWjVR2jUJLSGucKTDw2BTZrYLBVR4ia4EHI+tm/xEdpKB0z7pJAidw22tYosCOcxkzaT/QrzGM+21IW3WzAVcY4Fi4hFmaN0DAuMzDiXtJ6D7CMIIGq1W6ORvaNDGY0BIV2ik5CNAYBlgsfMngRA4D+9IdJYHIQqJDmSvSUseO5Clp+Fr/5ebQCcLlmZEVHJ+0NYLqT9IbKkx5vYA1BKdJMCoFZ0losCIQc+yJsCxgNuadsMJEbvGSRpsTYQew4LDstgHjOpo8H8p1lQYH6L9w4auYI3nT/P+2a8FxxgcFwcBe0zgUc6Psjw401q8sINn2r5+YOIpcV9TbqD7e5hNhfAAX4CScmNHpbCA3auHt1QnuGJiJAhfPzVGP7ZMRe9bVuCsjY5nCM+xNnidxgIOsSo8e2DCsuQtTILinTQvTOiCeHLUujzV0oCVOT2m5KU9bRM0OjNH1NiGZm21V84LgybX0itDmvCu4bB19+YKiyKS8KWcoNmpkhLjTPpzLCiF1+T4C+eX+V1keq0EAAAAAElFTkSuQmCC";

var img$f = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAbhJREFUeNrtWgFqwzAM9Jm+YM3/X5juCdPooFA8Z7MdSZbkCEohtFi6O8lSUEqXXba0waBPpOkfDAev4uPNcOBLpADN9hOOWEcUAKjRJ5V6AEPBY0ZRhDHWW/8HTwDQSR9EQYAxyauDAKOsq4EAw6yrgAAngYuBAKNyV5sZ4IR1MSXAafBsIMBx8CwgZOaucsZscerMbMEJofNJCgBKNm0IhByA/VMg5CDsD4OQA7E/BEIOxr7qLYCVAAjJPncj5LE4NgFADuVPlwKYAPDIflfBjqgA4lJAFPaXrwHgAgAR0ckr5/8KKYCrBvxjt055/UL0435Pn49Hqj3ntKMz3p5X5b9t28/3vu/dCmguemWw3MEPnoESiBcYowroclDCOM4oFRGlBgyP673LCXACAErGa/ZUQfhb4Kj4RboG6Uw9GNnPcbteW0uH/P6w8oNQs38tHTCAMDyyf0Ty8q1wS3NBDZ+ZChj24xk7BmUmMplx3v/cTmmxDMn8r/YBjf01Jkm6J90glQJW1CFCkoVl6fAAaIBkYlV2Fkgh31bbKhxl+/hFdtcFMtA8Cl+tcAsAf71RsW6efVezb/4DdiZjsxv1AAAAAElFTkSuQmCC";

var img$e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAa1JREFUeNrtmoFqAyEMhv2lT7De+z/hdY+wjA4GxXkjphqTaKAUpOWSL380eqa0bdvSBoM+kaZ/MBy8io83w4EvUQI02084yjqiACCmTyrzAQwFjxmTIoxlnfs/eAJAb/owFAKMSV4dAoxmXQ0CDGddBQKcBD4MAozKXW3PACdZH6YEOA2+G4TsvL2GsCyHAMCkvcXUZZCMbKvFE6PFIzFVCNEANEOICKAJQlQAbAg5LW4bwAawjmElALQVsAHwlvu8svw5AChNfHE5uwRIStWL/PckGBAArQ6gebO3fAncGuX1h+jH/Z4+H49UG+9pV894Ga/K/ziOn+/zPJsVwD4rKIPtHbzwGShB/MKQKqDJwRHW4xmlIqLMAeI+pfVyApwAQJnxmj1VEH4VuJr8Ii2D9M58ILmf4/Z6ba0c8utg5Qcej83RUg4QEIbH7F8leflWmNNcEOMzUwFiP56xQyizITuznut/b6e0soyR9V/tA5j9NSZJuqXcMKoErKhjSJIsXJYOD0ADkomrsrMgRb7kYaRuyvbxi+y+J8kAeyu8W2EOgP9OVKybZ9/V7BsoanMeq391+AAAAABJRU5ErkJggg==";

var img$d = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAhtJREFUeNrtW21uwyAMjREnWHv/E6brDrDGC1MzZQiCCWAMwVL+NCH2e/iLQGHyyP1+R9fvC+IkVRSA9948z86bQAXeOgE+IoAKvBcCbCLUdHGB0Oz7YidFVn22jiLg3noOsWlO4NzyJhaOiFCu2e8BPDXhXyIHGE/whZmWPvt2voiR79dr+no+/2GzPV6XNCBHgnOV3WVZJqWUt+xtY8wzIdEtu3aOnkSnzmCqh8Q2OgY0ZWazEVBbPh+Pw/sft1uS18D6ArQUUpKg1H44aLuN94wvoWCHibbt8msBVcLNJIdAdBL0ZHmyIlcVObsYOkp4W7K0nwkl0WZCgAKeKwS6Ad8EASXBN10FcoAfjZDxAMNkJJtdNULboN/LZif0vNCL4gF/FzgGdR0Ctu26oKJuW+HLrwUGAYOAjuRsEuSqAiDRAzhLII4QEEgAZw8AUnPAaIQGAb0QsP/iErvL0qLYGPVVgPtI0JdzeWtLXcccLRtJcBAwCOifAOqR2RbFhW0clfUx09thSR9GHRrQOhGhkIYzsX90PG23T5+VuPW9SOlaqX1NkePy+y22zeCc4G0dWb8HbIzkrALG8FRPyEmkK6S9Z4VzEZFCQk7w5P8MZRAM5Rvm94TLoEASkMvekiXuLAjktLV0jY8Fg9x2cjQ5VFBYw0auLi8EDmvZx9nmokTbuPt8lGZXjYUOSrKp5koPBdlSlYSqX6B+AGDuGPLVCsLeAAAAAElFTkSuQmCC";

var img$c = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAhRJREFUeNrtW1tywyAMtBhO0OT+J3SaHqAxMZ2446qINwQBmvFPbAy7rB4YAgth1+tVmX7flFpaNQFA3lvX1XgTfIFzJ4AiAnyB90IAJkIsgxu4Zp/ynRTb+8N9FAH36seKTdYEXttexIKNCGGa/R7A+wb8IWKAVgLlZrL12cfxIsS+H4/l637/gw0rXpYcQI4AZ0q727YtQggy7R1t9DMuk5ylnaMmkakzmKqQ0EJHg/aZ2WwEvNs+bzfr/Y/LJUk1sL9AoQ59gmCr9bBz7BhvjJZUw4IJHtvwawFRQmYtu0BwECSivHdHpiwSuxiyBbwjWOJnXEGUjQv4gK/lAt2AZ0FASfCss0AO8LMQ0grQTAay2VUhdDT6uTA7rucbvXwU8HuBoVHXLoDHLgt21G0pPPxaYBIwCejIYoNgrSwALSqgZgpU0wUaJKBmDQCtxoBZCE0CeiHg/MUldJeFo2GMchTgFAlyOMmjLXUZcrRsBsFJwCSgfwJ8j8xyNBO2eVSWYqa3w5IURulqwJ0Il0tDjO+fDhr9Iwfv0xt2nZJijKtq9a1rko7Ln7bTlAk8ATwZvOW9+T44uJSAT3PsMwKeg8uWXWwqcCkAuzR5VpgIGjHjbSKtev9nKAIMJIB/e4CFDDMKHIGXLITYgM/9PYAV8JwuUKofdgpgBbzGYohFCS1HBV5KAewWTnJU4KkDVz2A1/YE9TAKPpdsqQcAAAAASUVORK5CYII=";

var img$b = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcmlDQ1BpY2MAACiRdZE9S8NQFIbftkpFWwrqIOKQoYpCC0VBHKWCXapDW8GqS3KbtEKShpsUKa6Ci0PBQXTxa/Af6Cq4KgiCIoi4+Af8WqTEc5tCi7Qn3JyH9573cO+5gD+tM8PuSQCG6fBMKimt5tek4Dt8GEQYQ5iSmW0tZRdz6Bo/j1RN8RAXvbrXdYyBgmozwNdHPMss7hDPE6e3HEvwHvEwK8kF4hPiGKcDEt8KXfH4TXDR4y/BPJdZAPyip1RsY6WNWYkbxJPEUUOvsOZ5xE1CqrmSpTxKaww2MkghCQkKKtiEDgdxyibNrLMv0fAto0weRn8LVXByFFEib4zUCnVVKWukq/TpqIq5/5+nrc1Me91DSaD31XU/x4HgPlCvue7vqevWz4DAC3BttvxlmtPcN+m1lhY9BiI7wOVNS1MOgKtdYOTZkrnckAK0/JoGfFwA4TwwdA/0r3uzau7j/AnIbdMT3QGHR8AE1Uc2/gDt82gCvNGYhAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAcpJREFUeNrtWwFuwyAMjBEPWNf8/4XpugesoWMKUppBYidQ5cAnVZWaRtGdDxscoC6Bvu9d7PfRue6sMETJa8MwRC8Slzi6ACkhiEu8FgGWQpiucdBW9FNj5wiWzyvxjOk5/muVm30n8Xfjl8NfkNeEMLHo10Cem/CbyAHeCZMb/sGePfqTfXfh5/Hovu/3F25Lx9ujiURad6WIld1xHDtjTLLshXv8f7Zgka2dY04ClQNCxDmR5eL0Dvi63Vavf16vh1xjzzy13YKUPPQQWFaDHOShBJjX8VzkIRdDa+RDvvBlskoBOOSlVcLURr7KIVCKPIQAJclDJsGc5FkzwdBUqJE8pANykocTIDd59mKI2zIv0Q8oSR7GAaXIQwhQkjx0GVQBGI5xjEWRrTGqkmGjQ0AFUAFUABVABVAB2sXmRMi3pEbnSDLJyNm3h3MAEvnsAqCRZw0Bb/l5Q2THjg1qaghoFVABVAAVQAVQAVQAFUCCI9thxYSJXj5WcspCHaACNNgP+LhcTr+gySqAX/nNX2nP99ujI/aaX3NAbAPDkQ0RSNFfPTUWbkA/QLUVTNoT9RpOj+rJ0aUDJE5AdkDy8LRECEQBUrnsCeUexwK5uUFRAAAAAElFTkSuQmCC";

var img$a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAMtJREFUeNrt2kEKgzAQBVAjnqDm/ifUHqHpsigKgkYa5/2dWRjnOQkE0nUiEjlpZ7xEqTcFKn6z5j76EggPMJzYJ1pJ0QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACB4hrMveI1j957nzfErszfH1vjtHbAu9uria84x1PrAGqkxR/g94Mg1uafdEXJNDgAAAAAAAAAAAACAY6fBogMAxDoOP7nt01GARXLOi+dP+V+fPv1KmqbJEjgNsP77LaXlb78tX1rgGEFVOtioAAAAAElFTkSuQmCC";

var img$9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAZBJREFUeNrtmlGOwyAMRDOoJ9jm/idM9wjrzVZaKWpDoBI2YzBSf6oqeB5jjGmWZfKBDnMKU0wgEd0tPpAKN4sTDsSrxgqyPDffH2AoHp2eYwqgddDqEEAs3gQCyMWrPz85KbHUZVA6VxewOsDFSOTWV392UrAkW3Nl6gCL5grMKSDsK94aAAhSIKpAACADIF7yvxUAeM3/SAFFAOIltRKLFXvNqZkCwr76sQc0BgBv9rdwgDDbP1Ig2uFwQAAIAI46QZU5wgEOdmzEHuAEgOV/BMJk0VxAFu8eQA3Auq6nlH/k/evvx+Ptu6/7van6mjkS8jy2bUMVgJzwKwCvAbYWXzvHFYAcCNQKLwGg2NBQnxH/IKavAiitfi53vIySttuowo86dgjZ0okzQqOIP7ggW0qn2AP2BX1+sifB4w9GW/2Ss3FiC4zshteUjzK4n6jk7Jg5w/g7TWLheNNr2AsRfgBajYunFOh1qdG9BYgUCAABIADcPuymnsPLrVCuAQoHXABAafWd3gNM0+x9PH4BvDJ3ZJJMpIIAAAAASUVORK5CYII=";

var img$8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/YyTBBykUEbHYwoiFAVEQS4mgjVrECEZtkk02EbKbZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9YwIJorPM3o8zcy4zZ8A3k9dN1z8MplV0YtNRbTGxpAVe8NNNB0HCSd21Z+en4vw7Pu9oUvU2onr9v+/P0ZbOuDo0BYXHdNspCk8Iz6wVbcVbwl16LpkWPhQecuSAwldKT1X5WXG2yu+KnXhsEnyqp5Zt4FQD6znHFB4U7jfzJb12HnWT9oy1MC+1V2YfLjGmiaKRosQqeYpEpFqS2d++4R/fHAXx6PK3KeOII0tOvEOilqRrRqoheka+PGWV++88XWN0pNq9PQotT573FobADlS2Pe/ryPMqx9D8CBdW3V+QnMY/RN+ua/0HENqAs8u6ltqF803oebCTTvJHapbpMwx4PYWOBHTeQOtyNavaOif3EF+XJ7qGvX0YkP2hlW/cxWf6XLNyeQAAAAlwSFlzAAALEwAACxMBAJqcGAAAADdJREFUeNrt1LERAAAEA0DsvzO9EfjvUsrlRAAAAAAAAABwX67c3+6u7wtQgC8AAAAAAAAAwH0DNkcBCEXoxRkAAAAASUVORK5CYII=";

var img$7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/xmiESWEhLO5iyAKJkqVGscFiZpTBZu51Z0bNx+3eO2myVTYWykJsfC38B2yVLaUUKcnGP+BrI13vMVMzyZzbue+v55zn7ZzngG8mY2Qd/zBkc64dmQ5rC/FFLfCCn27aGCKYMBxrNjoVo+b4vKNO1dtB1av2vn9H84rpGFDXKDxmWLYrPCE8s+ZaireEO4x0YkX4UHjAlgMKXyldL/Gz4lSJ3xXbscgk+FRPLVXFehUbaTsr3C8cymYKRvk86iYtZm4+KrVLZg8OEaYJo6FTYJUMLoNSc5LZ/77hX98cefEY8rcoYosjRVq8A6IWpKspNSm6KV+Gosr9b55OcnSk1L0lDA1PnvfWC4Ed+N72vK8jz/s+hvpHuMhV/HnJafxD9O2KFjqA1g04u6xo+i6cb0Lng5WwE79SvUxfMgmvpxCMQ/sNNC2Vsiqvc3IPsXV5omvY24c+2d+6/AMRKmgSy8M37AAAAAlwSFlzAAALEwAACxMBAJqcGAAAAV1JREFUeNrtmgEKgzAMRRvJCab3P6HuCOtU5nBdY61iqcn/UJBN0f9qkxTjHARBkGGR9EfXdT72+8v7as00JNpxfd/TLgCS8bsDkEDQXuNaAIQgGsSAxOxLa+cuSnljrcbXPkYI02EUBMUIaTG/eguWwz+vJmLAOKHziAZO7bOf8mY+CwCAdQBszXBYyfLB0rbWephKLAFf8QR7xIACAGquE7KfjUvdCGkQAAAAADRVgnoKoecwuGlYLYSWi+bxaFufc36lY1Mfj99BkYtI+RLwKISQBQAAAADgZBAslQmo1jegVBr0WAKVAihVB1DNMYAsvwFIg2oAjLuj9U5JveHQI1sxLkEw920w7CTjnNYyBEEAAAD9APa2zN5RMW9olZXIKGyWjHrk1AWae4V/dnQ5a3+rryjzK9PpUjZV6Ei6pF3+avNX3INDIpqzQGxJs3SCNhCae6AhCIKgo3oDRfKqQh1Aqh4AAAAASUVORK5CYII=";

var img$6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABbmlDQ1BpY2MAACiRdZE7SwNBFIW/JEpEE1JoIZIihYqFgiiIpUTQRi1iBF/N7uYlZDfLboKIrWBjIViINr4K/4G2gq2CICiCiI1/wFcjst5JAgmSzDJ7P87MucycAf9M3jDdlmEwraKTmI7HFpeWY8E3WogSIoxPM1x7dn4qSdPx/YBP1fsh1av5voajI5V2DfC1CY8ZtlMUnhCeWS/aineEu4yclhI+Fh505IDCN0rXK/yqOFvhT8VOMjEJftUzlq1jvY6NnGMKDwj3mvmSUT2PukkobS3MS+2RGcUlwTRxYuiUWCNPkSGplmTW2Ddc9s1REI8hf5sNHHFkyYl3UNSSdE1LzYieli/Phsr9f55uZnSk0j0Uh9YXz/vog+Ae/O563s+J5/2eQuAZrqyavyA5jX+JvlvTeo8gsgUX1zVN34fLbeh+sjVHK0sBmf5MBt7PIbwEnXfQvlLJqrrO2SMkN+WJbuHgEPplf2T1D6TFZ+Dpj8jzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJUlEQVR42u2b6wrCMAyFF9kTuL3/q0YUlDIQrGnatPkOFPZDluY0l7NQty05pHjWCfbo9nKd6KCa4pY9BSAgOwF7w7zTRrmrRIAjzvN8rSsB0rP1VFZ86RUBUqwIbc91L+8ooAtkdv4ZBUQABEAAn8Ot8KsS1Ei+946ASJ/dSgoMIECipf8+ed2pxv04hhdB2iAEQEAcjCiCLbWAGGwsIYTUYAMhtIIQEoMN8Qjv6woHhBBtEAIgYCUhZO4gTISoAXMLIfNe0k2E6AIQAAFT6ADLoGMJHaDOzqMDousAy6Cjai/p5gHlFTlSAAJsbVD/+E24lBBH52ts6ijfI6SAjrTLJanOJyeBokBSnvi36/IAUATD/3fQxXdJ6vyHBHRA9hQA2fEADxYsjjbR70EAAAAASUVORK5CYII=";

var img$5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAZ1JREFUeNrtmw1uwyAMhTHiBGvuf8K03QHWMDE1UkehgEMSDO+TKlX5IXnG2E4gpCJM0xTcvlirWkUTRffN8xzcTrnCpRsgZgjKFd6LAVIeAQAYCzrjon7APTMgmdZ7KDc7hfh5PNT3/f7W3mpw99/seQM1ejeUdpdlUVrraNpbz3HHpDQZyeO3Rk1ifJfweyzVg1s9pLTQcaJjPcuOAUeKKOV2vX7c/3W5bPIa8htIXfBJq/VwMqv5ejm+ZBsOC8X3ptXg6D3cTFJhx60Dsi8UyiLcSvBTwFtjV2lMEzMEcsQfNQS6ES/CAHuKF50FaohHIeQ8wAkutGZXhRCnrraN/4o00imWbqgQAgCAoRk+C1BH4lmaNIYACiEAhub16ah0lkW6XocZRXjMCNzZ4aOyQPWo/jalzpgYbeoFxxacdgmVILXYuO1BPHcIdMPfEAgZoNdlpCGteBiKWaY3L4hpNKkTpBsiFeOKl8s7Xhca1Zqjq1Xa5i6ZXzuWFQMY02lyXoi0tI53Dw/w9ZjYAb3VB/hCBAAAAAAAgH/8Ah3f3c5J52vwAAAAAElFTkSuQmCC";

var img$4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAgVJREFUeNrtWwtuwyAMxREnWLn/Cdt1B1hDSzemyoNiKFADthSpSiDhPX/5FFREjDHB+7u1iqtsANFnx+MxeB+owEcnIEYEUIHPQgAmwvfgi6qt3ClbFfyP1ajFZXkCNCUz1BYccGMpqpHYFAGshJqdQvJ9uaiv8/nf+zzh7rduOYAa2g2l3X3f1bZt0bTn+7g2KUx6ZP+tUZNobBJYYykNvmohuYWOAx3TbHEQ7AkiVz5Pp6fPPw6Hl6wGbi+w6IOULMC1eEqOHeMtsSXOlWP22KQSbGFmnF2AUglSojz5Q6EsUloJPgt4PljiNqkgOowLUMBPOxlqBX4IAlqCHzoL1AAvhZCzAMdkJptTFUK+0/3C7KTaM70oFvB3hRZFp3YBVWlFiHM1KHMBIUAIEALqzQbfnAmAqwX0SoNWXIApAb3qAOAcA2BlC5A0OA0BjysuubssIwrGqFcBHiNBL2fyaEsdjDG28wkNNuL2J+SU2PJZ4GYGsCp4hx1Ce38MY0LJumXQ58UFMAGU3dtMTVmm5h60dJ3qkOEOFv0GrsCDvpSj9ceDRr+7SrbxbDEaA3AVSz0y7xVbFAPQdlpr8H0XHDJPb/QCX80CMB4da0BwiaE0T/7PUKFG3m65PUvhqeYOyxdCI7oAcHnZ0Omv1oCHJ6HGYOcqhFYjYWNG5PDCdjosEpEraP7o1MFLlvgAAAAASUVORK5CYII=";

var img$3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAALNJREFUeNrt2zEOgCAMAEAw/v/L1Qc4FSWNvSaORLjS6gBjiN4x7yc6Axzdd0B7gDMzKCJmyXqeMz7fAVUXn52bHgBAE9zffJ5qNdPA3uhHSiCZ7VjJ3FefvcxczuSLR5Vf6NUEKAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPDj2HJlJnOkddcBzKPi4lfGKQEAxQCytbyrB7g3qAQACNE5LgqdKICszpBUAAAAAElFTkSuQmCC";

var img$2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JMaIRlJoISKaQsVCQRTEUiKYRi1iBF9Ndt0kwiYuuwkitoKNhWAh2vgq/AfaCrYKgqAIIjb+AV+NhPVOVkiQOMvs/Tgz5zJzBvyTpp5z6gYhly/YiXgsOje/EA29EqSeEJ10pXTHmpqZSPLv+LrHp+rdgOr1/76ao2nZcHTwNQiP6JZdEB4TnlwrWIq3hVv1bGpZ+Ei435YDCl8rXfP4RXHG4w/FdjIxDn7VM5qpYq2K9aydE+4T7s6ZRf33POomYSM/OyO1XWYHDgnixIiiUWQFkwIDUvOSWW3fYNk3zap4dPlbrGOLI0NWvP2iFqWrITUtuiGfybrK/W+eTnp4yOsejkHw2XXfeyC0C6Ud1/0+dt3SCQSe4DJf8a9KTqOfou9UtO5DiGzC+VVF0/bgYgvaHq2UnSpLAZn+dBrezqB5HlpuoXHRy+p3ndMHSG7IE93A/gH0yv7I0g/RtGf1H+H7WwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAPxJREFUeNrtmm0OgyAQRB3TE1Tvf1WaNmlCE4NCW77mkfDHRbP7nF1AXBbzpsL7wizxaKLgi2Ja3VMAAO4Abo2KT+ilHtkpYN/3V/8GgH40lf5DeaqlAEW9h2kv25e3CpgFnIN/qgAFAAAAbIdbtNCLL6QAANgNerX7tlEESQEAAAAAAAAAADwBsBAiBQAAAAAAAAAAAAAAAAAAAAAAAACwOxmKf5FDAQColwKhYEyVT2TqJPhm/lED3AGooxrQyje/dUC8FtDFt6YJ7UnD2cnN6PbL5I7Gj25PXggGZUA5spkeggyD/4h9zZHLhPYkAJ08ZHR7sgbMOO8f2h90sy2pSZTVdgAAAABJRU5ErkJggg==";

var img$1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAMpJREFUeNrtmksKgDAMBY30BNr7n7B3iCgo4kbwl+CbAZdCM77E+uk6AABh7OJ5/pd67EfFX6qpV4t8rXU5ZAXIJ2CfhJkSNHw8yzySboE5Bf0DV9sCa7i9lvJR5DPuZWgBBARG2bOshRZAgDhFreBhHBmCtAACEIAABABocrYRciEXdhTggoEwboPqAuRnAAAzIAReiHAbRAACEIAABMQj92Vo/4scCUAAAngWoAVogbjIp1ibJS3+tfWt+4DWGi0gmQBmAAAAwMYEsvUT/L18rywAAAAASUVORK5CYII=";

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZHNK0RRGMZ/M4gYUSwk6S6GKFOiZKlRZoPFGGWwuffOnRk1M273zqTJVtlYTFmIja+F/4CtsqWUIiXZ+Ad8bTRd7zFqJHNu576/nnOet3OeA/7pjJl164chm8s70UhYW4gvao3P1NNDO4P06qZrz8xNxag5Pm7xqXoTUr1q7/t3tCQs1wRfk/CYaTt54Qnh6bW8rXhLuNNM6wnhA+EhRw4ofKl0o8JPilMVflPsxKKT4Fc9tdQvNn6xmXaywgPCwWymYP6cR90kYOXm56R2y+zBJUqEMBoGBVbIkCckNSeZ/e8b/vbNsioeU/42RRxxpEiLd0jUgnS1pCZFt+TLUFS5/83TTY6OVLoHwtDw6HmvfdC4DeWS530eel75COoe4DxX9a9KTuPvopeqWnAf2jbg9KKqGTtwtgld97bu6N9SnUx/MgkvJ9Aah45raF6qZPWzzvEdxNblia5gdw/6ZX/b8hco4WgdZKtgqgAAAAlwSFlzAAALEwAACxMBAJqcGAAAANNJREFUeNrt2tEKwyAMhWEz9gSr7/+qjg0GvZ3dVMwX8K6F5OfkRFtLSR7R+V7bpZ7YqPiumm7ZWwCA7ADuk8ynreJH6RRQa32vKwDiR6P0H8qLUQqI01ph7H2dy0cFpkDm4l8qoAAAAHAcnhFtlVy0AABOg7nicRxMUAsAAAAAAAAAQE4ANkJaAAAAAAAAAAAAAAAAAAAAAAAA0v0ZOl+RowAAxrVA63hmyCeyWKT4afnxgOwAYiEPmJVbvn3A1evyQmxogi1r/ZG4eCYIAA+w2SpPUykQkfN9GyAAAAAASUVORK5CYII=";

const geometricIcons = {
    square: `<img src="${img$a}"/>`,
    circle: `<img src="${img$v}"/>`,
    line: `<img src="${img$m}"/>`,
    arrow: `<img src="${img$A}"/>`,
    polyline: `<img src="${img$e}"/>`,
    polygon: `<img src="${img$f}"/>`,
};
const textIcons = {
    note: `<img src="${img$c}"/>`,
    freeText: `<img src="${img$5}"/>`,
    freeTextCallout: `<img src="${img$4}"/>`,
    strikeout: `<img src="${img$1}"/>`,
    squiggly: `<img src="${img$2}"/>`,
    underline: `<img src="${img}"/>`,
    highlight: `<img src="${img$3}"/>`,
};
const lineTypeIcons = {
    straight: `<img src="${img$8}"/>`,
    cloudy: `<img src="${img$s}"/>`,
};
const html = `
  <div id="main-container" class="hide-previewer disabled" 
    ondragstart="return false;" ondrop="return false;">
    <div id="viewer"></div>
    <div id="previewer"></div>
    <div id="top-panel"> 
      <div class="subpanel panel-item">
        <div id="toggle-previewer" class="panel-button panel-item">
          <img src="${img$b}"/>
        </div> 
      </div>
      <div id="modes" class="subpanel panel-item">
        <div id="button-mode-text" class="panel-button panel-item">
          <img src="${img$w}"/>
        </div> 
        <div id="button-mode-hand" class="panel-button panel-item">
          <img src="${img$n}"/>
        </div> 
        <div id="button-mode-annotation" class="panel-button panel-item">
          <img src="${img$d}"/>
        </div> 
        <div class="panel-v-separator margin-s-5 panel-item"></div>
        <div id="button-open-file" class="panel-button panel-item">
          <img src="${img$l}"/>
        </div> 
        <div id="button-save-file" class="panel-button panel-item">
          <img src="${img$r}"/>
        </div> 
        <div id="button-close-file" class="panel-button panel-item">
          <img src="${img$t}"/>
        </div> 
      </div>
    </div>
    <div id="bottom-panel">
      <div id="paginator" class="subpanel panel-item">
        <div id="paginator-prev" class="panel-button">
          <img src="${img$z}"/>
        </div>
        <div id="paginator-next" class="panel-button">
          <img src="${img$y}"/>
        </div>
        <input id="paginator-input" type="text">
        <span>&nbsp/&nbsp</span>
        <span id="paginator-total">0</span>
      </div>
      <div class="panel-v-separator panel-item"></div>
      <div id="zoomer" class="subpanel panel-item">
        <div id="zoom-out" class="panel-button">
          <img src="${img$k}"/>
        </div>
        <div id="zoom-in" class="panel-button">
          <img src="${img$h}"/>
        </div>
        <div id="zoom-fit-viewer" class="panel-button">
          <img src="${img$p}"/>
        </div>
        <div id="zoom-fit-page" class="panel-button">
          <img src="${img$q}"/>
        </div>
      </div>
    </div>
    <div id="annotation-panel">
      <div class="annotation-panel-row">
        <div id="button-annotation-edit-text" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$7}"/>
        </div> 
        <div id="button-annotation-delete" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$u}"/>
        </div> 
        <div id="button-annotation-mode-select" 
          class="panel-button annotation-panel-item">
          <img src="${img$g}"/>
        </div> 
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-stamp-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$x}"/>
        </div> 
        <div id="button-annotation-stamp-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$u}"/>
        </div>
        <div id="button-annotation-stamp-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-mode-stamp" 
          class="panel-button annotation-panel-item">
          <img src="${img$9}"/>
        </div> 
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-pen-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$x}"/>
        </div> 
        <div id="button-annotation-pen-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$u}"/>
        </div> 
        <div id="button-annotation-pen-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-mode-pen" 
          class="panel-button annotation-panel-item">
          <img src="${img$i}"/>
        </div> 
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-geometric-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$x}"/>
        </div> 
        <div id="button-annotation-geometric-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$u}"/>
        </div> 
        <div id="button-annotation-geometric-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-mode-geometric" 
          class="panel-button annotation-panel-item">
          <img src="${img$o}"/>
        </div>
      </div>
      <div class="annotation-panel-row">
        <div id="button-annotation-text-undo" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$x}"/>
        </div> 
        <div id="button-annotation-text-clear" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$u}"/>
        </div> 
        <div id="button-annotation-text-save" 
          class="panel-button annotation-panel-subitem">
          <img src="${img$j}"/>
        </div> 
        <div id="button-annotation-mode-text" 
          class="panel-button annotation-panel-item">
          <img src="${img$6}"/>
        </div>
      </div>
    </div>

    <div id="focused-annotation-panel">
      <p id="focused-annotation-author" class="line-clamp"></p>
      <p id="focused-annotation-date" class="line-clamp"></p>
      <p id="focused-annotation-text" class="line-clamp"></p>
    </div>

    <input id="open-file-input" type="file">
  </div>
`;
const passwordDialogHtml = `
    <div class="form">
      <input id="password-input" type="password" maxlength="127"/>
      <div class="buttons">
        <div id="password-ok" class="panel-button">
          <img src="${img$j}"/>
        </div>
        <div id="password-cancel" class="panel-button">
          <img src="${img$u}"/>
        </div>
      </div>
    </div>
`;
const textDialogHtml = `
    <div class="form">
      <textarea id="text-input" maxlength="1024"></textarea>
      <div class="buttons">
        <div id="text-ok" class="panel-button">
          <img src="${img$j}"/>
        </div>
        <div id="text-cancel" class="panel-button">
          <img src="${img$u}"/>
        </div>
      </div>
    </div>
`;

const styles = `
<style>
  :host {
    --tspdf-color-primary-final: var(--tspdf-color-primary, rgba(40,40,40,1));
    --tspdf-color-primary-tr-final: var(--tspdf-color-primary-tr, rgba(40,40,40,0.9));
    --tspdf-color-secondary-final: var(--tspdf-color-secondary, rgba(60,60,60,1));
    --tspdf-color-secondary-tr-final: var(--tspdf-color-secondary-tr, rgba(60,60,60,0.9));
    --tspdf-color-accent-final: var(--tspdf-color-accent, rgba(96,96,96,1));
    --tspdf-color-shadow-final: var(--tspdf-color-shadow, rgba(0,0,0,0.75));
    --tspdf-color-bg-final: var(--tspdf-color-bg, rgba(128,128,128,1));
    --tspdf-color-fg-primary-final: var(--tspdf-color-fg-primary, rgba(255,255,255,1));
    --tspdf-color-fg-secondary-final: var(--tspdf-color-fg-secondary, rgba(187,187,187,1));
    --tspdf-color-fg-accent-final: var(--tspdf-color-fg-accent, rgba(255,255,255,1));
    --tspdf-color-text-selection-final: var(--tspdf-color-text-selection, rgba(104,104,128,0.3));
  }

  .disabled {
    pointer-events: none;
  }

  .relative {
    position: relative;
  }
  .absolute {
    position: absolute;
  }
  .abs-stretch {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
  }
  .abs-topleft {
    position: absolute;
    left: 0;
    top: 0;
  }
  .stretch {
    width: 100%;
    height: 100%;
  }
  
  .no-margin {
    margin: 0;
  }
  .no-padding {
    padding: 0;
  }
  .margin-s-5 {
    margin: 0 5px;
  }

  .line-clamp {
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical; 
    overflow: hidden; 
  }

  #main-container {
    box-sizing: border-box;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: stretch;
    align-items: stretch;
    width: 100%;
    height: 100%;
    background: var(--tspdf-color-bg-final);
  }

  #top-panel {
    position: relative;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
    width: 100%;
    height: 50px;
    background: var(--tspdf-color-primary-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
    z-index: 1;
    transition: height 0.25s ease-out 0.1s;
  }
  .hide-panels #top-panel {
    height: 0;
    transition: height 0.25s ease-in 0.2s;
  }

  #bottom-panel {
    position: absolute;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 160px);
    bottom: 20px;
    width: 320px;
    height: 50px;  
    background: var(--tspdf-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
    z-index: 1;
    transition: height 0.25s ease-out, bottom 0.1s linear 0.25s;
  }
  .hide-panels #bottom-panel {
    bottom: 0;
    height: 0;
    transition: bottom 0.1s linear 0.1s, height 0.25s ease-in 0.2s;
  }

  #focused-annotation-panel {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: stretch;
    flex-grow: 0;
    flex-shrink: 0;
    left: 20px;
    top: 80px;
    width: 240px;
    height: 84px; 
    padding: 18px;
    border-radius: 18px;
    background: var(--tspdf-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }
  .mobile #focused-annotation-panel {
    width: 150px;
  }
  .annotation-focused #focused-annotation-panel {
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  #focused-annotation-panel p {
    margin: 0;
    padding: 0;
    line-height: 16px;
    font-size: 12px;
    font-family: sans-serif;
    color: var(--tspdf-color-fg-primary-final);
  }
  
  #annotation-panel {
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-end;
    flex-grow: 1;
    flex-shrink: 1;
    top: 80px;
    right: 20px;
    z-index: -5;
    transition: z-index 0s linear 0.25s;
    pointer-events: none;
  }
  .mode-annotation #annotation-panel {
    z-index: 1;
  }
  
  .annotation-panel-row {      
      display: flex;
      flex-direction: row;
      justify-content: flex-end;
      align-items: center;
      flex-grow: 1;
      flex-shrink: 1;
    }

  .annotation-panel-item {
    margin: 3px;
    cursor: default;      
    opacity: 0;
    background: var(--tspdf-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
    pointer-events: all;
  }    
  .mode-annotation .annotation-panel-item { 
    cursor: pointer;
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }

  .annotation-panel-subitem {
    margin: 3px;    
    background: var(--tspdf-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
    pointer-events: all;
  }  
  :not(.annotation-selected) #button-annotation-edit-text,
  :not(.annotation-selected) #button-annotation-delete,
  :not(.stamp-annotator-data-undoable) #button-annotation-stamp-undo,
  :not(.stamp-annotator-data-clearable) #button-annotation-stamp-clear,
  :not(.stamp-annotator-data-saveable) #button-annotation-stamp-save,
  :not(.pen-annotator-data-undoable) #button-annotation-pen-undo,
  :not(.pen-annotator-data-clearable) #button-annotation-pen-clear,
  :not(.pen-annotator-data-saveable) #button-annotation-pen-save,
  :not(.text-annotator-data-undoable) #button-annotation-text-undo,
  :not(.text-annotator-data-clearable) #button-annotation-text-clear,
  :not(.text-annotator-data-saveable) #button-annotation-text-save,
  :not(.geom-annotator-data-undoable) #button-annotation-geometric-undo,
  :not(.geom-annotator-data-clearable) #button-annotation-geometric-clear,
  :not(.geom-annotator-data-saveable) #button-annotation-geometric-save {
    cursor: default;      
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }
  .annotation-selected #button-annotation-edit-text,
  .annotation-selected #button-annotation-delete,
  .stamp-annotator-data-undoable #button-annotation-stamp-undo,
  .stamp-annotator-data-clearable #button-annotation-stamp-clear,
  .stamp-annotator-data-saveable #button-annotation-stamp-save,
  .pen-annotator-data-undoable #button-annotation-pen-undo,
  .pen-annotator-data-clearable #button-annotation-pen-clear,
  .pen-annotator-data-saveable #button-annotation-pen-save,
  .text-annotator-data-undoable #button-annotation-text-undo,
  .text-annotator-data-clearable #button-annotation-text-clear,
  .text-annotator-data-saveable #button-annotation-text-save,
  .geom-annotator-data-undoable #button-annotation-geometric-undo,
  .geom-annotator-data-clearable #button-annotation-geometric-clear,
  .geom-annotator-data-saveable #button-annotation-geometric-save { 
    cursor: pointer;
    opacity: 100;
    transform: scale(1);    
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }

  .panel-v-separator {
    width: 1px;
    height: 30px;
    background-color: var(--tspdf-color-fg-secondary-final);
  }

  .panel-button {
    cursor: pointer;
    user-select: none;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 36px;
    height: 36px;
    border-radius: 50%;
  }
  .panel-button:hover,
  .panel-button.on {
    background-color: var(--tspdf-color-accent-final);
  }
  .panel-button img {
    width: 20px;
    height: 20px;
    filter: invert() opacity(0.5) drop-shadow(0 0 0 var(--tspdf-color-fg-primary-final)) saturate(1000%);
  }  
  .panel-button:hover img,
  .panel-button.on img {
    filter: invert() opacity(0.5) drop-shadow(0 0 0 var(--tspdf-color-fg-accent-final)) saturate(1000%);
  }  
  .disabled .panel-button img,
  .panel-button.disabled img {
    filter: invert() opacity(0.2) drop-shadow(0 0 0 var(--tspdf-color-fg-primary-final)) saturate(1000%);
  }  
  .context-menu-content .panel-button {
    margin: 1px;
  }
  
  .subpanel {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    margin: 0 4px;
  }    
  
  .panel-item {
    transform: scale(1);
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  .hide-panels .panel-item {
    cursor: default;      
    opacity: 0;
    transform: scale(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }

  #paginator {  
    user-select: none;
    font-family: sans-serif;
    font-size: 16px;
    color: var(--tspdf-color-fg-primary-final);
  }
  #paginator-input {
    text-align: center; 
    font-size: 16px;
    width: 30px;
    height: 30px;
    margin: 2px;
    padding: 0;
    outline: none;
    border: none;
    color: var(--tspdf-color-fg-primary-final);
    background-color: var(--tspdf-color-primary-final);
  }
  #paginator-total {
    margin: 4px;
  }

  #toggle-previewer {
    margin: 4px;
  }
    
  #previewer {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    overflow-y: auto;
    left: 0;
    top: 50px;
    bottom: 0;
    width: 160px; 
    padding-top: 0px;
    background: var(--tspdf-color-secondary-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
    z-index: 1;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, width 0.25s ease-out;
  } 
  .hide-panels #previewer {
    top: 0;
    padding-top: 50px;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
  }   
  .mobile #previewer {
    background: var(--tspdf-color-secondary-tr-final);
  } 
  .hide-previewer #previewer {
    width: 0;
    transition: width 0.25s ease-in 0.1s;
  }
  #previewer .page-preview {      
    transform: scaleX(1);
    transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
  }
  .hide-previewer #previewer .page-preview {
    opacity: 0;
    transform: scaleX(0);
    transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
  }

  #viewer {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    overflow: auto;
    left: 160px;
    right: 0;
    top: 50px;
    bottom: 0;
    padding-top: 0;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-out;
  }
  #viewer.dialog-shown {
    overflow: hidden;
  }
  .mode-hand #viewer {
    cursor: grab !important;
    user-select: none !important;
  }
  .hide-panels #viewer {
    top: 0;
    padding-top: 50px;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
  }      
  .hide-panels.mobile #viewer,
  .hide-panels.hide-previewer #viewer {
    top: 0;
    padding-top: 50px;
    left: 0;
    transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s, left 0.25s ease-in;
  }   
  .mobile #viewer,
  .hide-previewer #viewer {
    top: 50px;
    padding-top: 0px;
    left: 0;
    transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-in;
  }
  
  #annotation-overlay-container {
    position: absolute;
    top: 0; 
    right: 0;
    bottom: 0;
    left: 0; 
    margin-top: 0;
    transition: margin-top 0.25s ease-out 0.1s;
  }
  .hide-panels #annotation-overlay-container {
    margin-top: 50px;
    transition: margin-top 0.25s ease-in 0.2s;
  }
  .mode-text-markup #annotation-overlay-container {
    pointer-events: none;
  }
  
  #annotation-overlay {
    position: absolute;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    touch-action: none;
  }

  .page {    
    position: relative;
    display: flex;
    flex-grow: 0;
    flex-shrink: 0;
    margin: 10px auto;
    background-color: white;
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
  }
  .page-preview {   
    cursor: pointer; 
    position: relative;
    display: flex;
    flex-grow: 0;
    flex-shrink: 0;
    margin: 0 auto;
    background-color: white;
    background-clip: content-box;
    border-style: solid;
    border-width: 10px 10px 20px 10px;
    border-color: transparent;
  }
  .page-preview:hover,
  .page-preview.current {
    border-color: var(--tspdf-color-accent-final);
  }
  .page-preview::after {
    display: inline-block;
    position: absolute;
    top: calc(100% + 3px);
    width: 100%;
    text-align: center;
    font-family: sans-serif;
    font-size: 14px;
    line-height: 1;
    color: var(--tspdf-color-fg-primary-final);
    content: attr(data-page-number) " ";
  }

  .page-canvas {
    background-color: white;
  } 
  
  .page-text {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
    overflow: hidden;
    line-height: 1;
  }
  .page-text span {
    cursor: text;
    position: absolute;
    white-space: pre;
    color: transparent;
    transform-origin: 0% 0%;
  }
  .page-text ::selection {
    background: var(--tspdf-color-text-selection-final);
  }
  .mode-hand .page-text span {
    cursor: grab;
  }
  .dummy-corner {    
    position: absolute;
    width: 0;
    height: 0;
  }
  .dummy-corner.bl {
    bottom: 0;
    left: 0;
  }
  .dummy-corner.br {
    bottom: 0;
    right: 0;
  }
  .dummy-corner.tr {
    top: 0;
    right: 0;
  }
  .dummy-corner.tl {
    top: 0;
    left: 0;
  }
  
  .page-annotations {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  .mode-text-markup .page-annotations,
  .mode-text .page-annotations,
  .mode-hand .page-annotations {
    pointer-events: none;
  }
  .page-annotations svg {    
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
  }

  .full-size-dialog {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: var(--tspdf-color-secondary-tr-final);
    z-index: 2;
  }

  #password-dialog .form {
    position: absolute;
    display: flex;
    flex-direction: row;
    justify-content: stretch;
    align-items: stretch;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 160px);
    top: calc(50% - 25px);
    width: 320px;
    height: 50px;
    background: var(--tspdf-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
  }
  #password-dialog input {
    width: 220px;
    margin: 10px 0 10px 10px;
    padding: 5px;
    font-size: 16px;
    outline: none;
    border: none;
    color: var(--tspdf-color-fg-primary-final);
    background-color: var(--tspdf-color-primary-final);
  }
  #password-dialog input::placeholder {
    font-size: 14px;
    font-style: italic;
    color: var(--tspdf-color-fg-primary-final);
  }
  #password-dialog .buttons {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    flex-grow: 1;
    flex-shrink: 1;
    width: 100px;
  } 
  
  #text-dialog .form {
    box-sizing: border-box;
    position: absolute;
    display: flex;
    flex-direction: column;
    justify-content: stretch;
    align-items: stretch;
    flex-grow: 0;
    flex-shrink: 0;
    left: calc(50% - 160px);
    top: calc(50% - 120px);
    width: 320px;
    height: 240px;
    padding: 5px;
    background: var(--tspdf-color-primary-tr-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
  }
  #text-dialog textarea {
    height: 100%;
    margin: 0 0 5px 0;
    padding: 5px;
    font-size: 14px;
    resize: none;
    outline: none;
    border: none;
    color: var(--tspdf-color-fg-primary-final);
    background-color: var(--tspdf-color-primary-final);
  }
  #text-dialog textarea::placeholder {
    font-size: 14px;
    font-style: italic;
    color: var(--tspdf-color-fg-primary-final);
  }
  #text-dialog .buttons {
    display: flex;
    flex-direction: row;
    justify-content: flex-end;
    align-items: center;
    flex-grow: 1;
    flex-shrink: 1;
  } 

  .svg-annotation {
    cursor: pointer;
  }     
  .out .svg-annotation {
    cursor: not-allowed;
  }
  .svg-annot-rect,
  .svg-annot-box {
    fill: none;
  }
  .mode-annotation .svg-annotation.selected {
    cursor: grab;
  } 
  .mode-annotation .svg-annotation.selected .svg-annot-rect,
  .mode-annotation .svg-annotation.selected .svg-annot-box {
    stroke: var(--tspdf-color-secondary-tr-final);
    stroke-dasharray: 3 3;
  }   
  .mode-annotation .svg-annotation.focused .svg-annot-box {
    stroke: var(--tspdf-color-fg-accent);
    stroke-dasharray: 3 0;
  } 
  .mode-annotation .svg-annotation.selected .svg-annot-handle-scale,
  .mode-annotation .svg-annotation.selected .svg-annot-handle-rotation {
    r: 8;
    fill: var(--tspdf-color-primary-final);
    cursor: pointer;
  }
  .mode-annotation .svg-annotation.selected .svg-annot-rotation {
    fill: none;
    cursor: pointer;
  }
  .mode-annotation .svg-annotation.selected .svg-annot-rotation .circle {
    r: 25;
  }
  .mode-annotation .svg-annotation.selected .svg-annot-rotation .dashed {
    stroke: var(--tspdf-color-secondary-tr-final);
    stroke-dasharray: 3 3;
  }

  #context-menu {
    box-sizing: border-box;
    position: absolute;
    z-index: 2;
    min-width: 50px;
    min-height: 50px;
    max-height: 300px;
    padding: 5px;
    background: var(--tspdf-color-secondary-tr-final);
    box-shadow: 0 0 10px var(--tspdf-color-shadow-final);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    overflow-y: auto;
  }
  .context-menu-content {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-grow: 1;
    flex-shrink: 0;
  }
  .context-menu-content.row {
    flex-direction: row;
  }
  .context-menu-content.column {
    flex-direction: column;
  }
  .context-menu-color-icon {
    width: 20px;
    height: 20px;
    border-radius: 12px;
    border-width: 2px;
    border-style: solid;
    border-color: var(--tspdf-color-fg-secondary-final);
  }
  .context-menu-stamp-select-button {
    box-sizing: border-box;
    cursor: pointer;
    user-select: none;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
    height: 36px;
    padding: 0 5px;
    border-radius: 5px;
    font-family: sans-serif;
    font-size: 16px;
    color: var(--tspdf-color-fg-primary-final); 
  }
  .context-menu-stamp-select-button:hover {
    background-color: var(--tspdf-color-accent-final);
  }
  .context-menu-slider {
    -webkit-appearance: none;
    appearance: none;
    outline: none;
    margin: 10px;
    height: 5px;
    border-radius: 5px;
    cursor: pointer;
    background-color: var(--tspdf-color-fg-secondary-final);
  }
  .context-menu-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    outline: none;
    width: 20px;
    height: 20px;
    border-radius: 10px;
    cursor: pointer;
    background-color: var(--tspdf-color-accent-final);
  }
  .context-menu-slider::-moz-range-thumb {
    outline: none; 
    width: 20px;
    height: 20px;
    border-radius: 10px;
    cursor: pointer;
    background-color: var(--tspdf-color-accent-final);
  }

  #open-file-input {
    position: absolute;
    opacity: 0;
    z-index: -10;
  }
  #button-open-file {
    pointer-events: auto !important;
  }
  .disabled #button-open-file img {
    filter: invert() opacity(0.5) drop-shadow(0 0 0 var(--tspdf-color-fg-primary-final)) saturate(1000%);
  }
</style>
`;

function clamp(v, min, max) {
    return Math.max(min, Math.min(v, max));
}
class Vec2 {
    constructor(x = 0, y = 0) {
        this.length = 2;
        this.x = x;
        this.y = y;
    }
    static multiplyByScalar(v, s) {
        return new Vec2(v.x * s, v.y * s);
    }
    static addScalar(v, s) {
        return new Vec2(v.x + s, v.y + s);
    }
    static normalize(v) {
        return new Vec2().setFromVec2(v).normalize();
    }
    static add(v1, v2) {
        return new Vec2(v1.x + v2.x, v1.y + v2.y);
    }
    static substract(v1, v2) {
        return new Vec2(v1.x - v2.x, v1.y - v2.y);
    }
    static dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }
    static applyMat3(v, m) {
        return v.clone().applyMat3(m);
    }
    static lerp(v1, v2, t) {
        return v1.clone().lerp(v2, t);
    }
    static rotate(v, center, theta) {
        return v.clone().rotate(center, theta);
    }
    static equals(v1, v2, precision = 6) {
        return v1.equals(v2);
    }
    static getDistance(v1, v2) {
        const x = v2.x - v1.x;
        const y = v2.y - v1.y;
        return Math.sqrt(x * x + y * y);
    }
    clone() {
        return new Vec2(this.x, this.y);
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setFromVec2(vec2) {
        this.x = vec2.x;
        this.y = vec2.y;
        return this;
    }
    multiplyByScalar(s) {
        this.x *= s;
        this.y *= s;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    getMagnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    normalize() {
        const m = this.getMagnitude();
        if (m) {
            this.x /= m;
            this.y /= m;
        }
        return this;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    substract(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    dotProduct(v) {
        return Vec2.dotProduct(this, v);
    }
    applyMat3(m) {
        if (m.length !== 9) {
            throw new Error("Matrix must contain 9 elements");
        }
        const { x, y } = this;
        const [x_x, x_y, , y_x, y_y, , z_x, z_y,] = m;
        this.x = x * x_x + y * y_x + z_x;
        this.y = x * x_y + y * y_y + z_y;
        return this;
    }
    lerp(v, t) {
        this.x += t * (v.x - this.x);
        this.y += t * (v.y - this.y);
        return this;
    }
    rotate(center, theta) {
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
    equals(v, precision = 6) {
        return +this.x.toFixed(precision) === +v.x.toFixed(precision)
            && +this.y.toFixed(precision) === +v.y.toFixed(precision);
    }
    truncate(decimalDigits = 5) {
        this.x = +this.x.toFixed(decimalDigits);
        this.y = +this.y.toFixed(decimalDigits);
        return this;
    }
    toArray() {
        return [this.x, this.y];
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
    }
}
class Vec3 {
    constructor(x = 0, y = 0, z = 0) {
        this.length = 3;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static multiplyByScalar(v, s) {
        return new Vec3(v.x * s, v.y * s, v.z * s);
    }
    static addScalar(v, s) {
        return new Vec3(v.x + s, v.y + s, v.z + s);
    }
    static normalize(v) {
        return new Vec3().setFromVec3(v).normalize();
    }
    static add(v1, v2) {
        return new Vec3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
    }
    static substract(v1, v2) {
        return new Vec3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    }
    static dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    }
    static crossProduct(v1, v2) {
        return new Vec3(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
    }
    static onVector(v1, v2) {
        return v1.clone().onVector(v2);
    }
    static onPlane(v, planeNormal) {
        return v.clone().onPlane(planeNormal);
    }
    static applyMat3(v, m) {
        return v.clone().applyMat3(m);
    }
    static lerp(v1, v2, t) {
        return v1.clone().lerp(v2, t);
    }
    static equals(v1, v2, precision = 6) {
        if (!v1) {
            return false;
        }
        return v1.equals(v2, precision);
    }
    static getDistance(v1, v2) {
        const x = v2.x - v1.x;
        const y = v2.y - v1.y;
        const z = v2.z - v1.z;
        return Math.sqrt(x * x + y * y + z * z);
    }
    static getAngle(v1, v2) {
        return v1.getAngle(v2);
    }
    clone() {
        return new Vec3(this.x, this.y, this.z);
    }
    set(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setFromVec3(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    multiplyByScalar(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    getMagnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    getAngle(v) {
        const d = this.getMagnitude() * v.getMagnitude();
        if (!d) {
            return Math.PI / 2;
        }
        const cos = this.dotProduct(v) / d;
        return Math.acos(clamp(cos, -1, 1));
    }
    normalize() {
        const m = this.getMagnitude();
        if (m) {
            this.x /= m;
            this.y /= m;
            this.z /= m;
        }
        return this;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    substract(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    dotProduct(v) {
        return Vec3.dotProduct(this, v);
    }
    crossProduct(v) {
        this.x = this.y * v.z - this.z * v.y;
        this.y = this.z * v.x - this.x * v.z;
        this.z = this.x * v.y - this.y * v.x;
        return this;
    }
    onVector(v) {
        const magnitude = this.getMagnitude();
        if (!magnitude) {
            return this.set(0, 0, 0);
        }
        return v.clone().multiplyByScalar(v.clone().dotProduct(this) / (magnitude * magnitude));
    }
    onPlane(planeNormal) {
        return this.substract(this.clone().onVector(planeNormal));
    }
    applyMat3(m) {
        if (m.length !== 9) {
            throw new Error("Matrix must contain 9 elements");
        }
        const { x, y, z } = this;
        const [x_x, x_y, x_z, y_x, y_y, y_z, z_x, z_y, z_z] = m;
        this.x = x * x_x + y * y_x + z * z_x;
        this.y = x * x_y + y * y_y + z * z_y;
        this.z = x * x_z + y * y_z + z * z_z;
        return this;
    }
    lerp(v, t) {
        this.x += t * (v.x - this.x);
        this.y += t * (v.y - this.y);
        this.z += t * (v.z - this.z);
        return this;
    }
    equals(v, precision = 6) {
        if (!v) {
            return false;
        }
        return +this.x.toFixed(precision) === +v.x.toFixed(precision)
            && +this.y.toFixed(precision) === +v.y.toFixed(precision)
            && +this.z.toFixed(precision) === +v.z.toFixed(precision);
    }
    toArray() {
        return [this.x, this.y, this.z];
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
    }
}
class Mat3 {
    constructor() {
        this.length = 9;
        this._matrix = new Array(this.length);
        this._matrix[0] = 1;
        this._matrix[1] = 0;
        this._matrix[2] = 0;
        this._matrix[3] = 0;
        this._matrix[4] = 1;
        this._matrix[5] = 0;
        this._matrix[6] = 0;
        this._matrix[7] = 0;
        this._matrix[8] = 1;
    }
    get x_x() {
        return this._matrix[0];
    }
    get x_y() {
        return this._matrix[1];
    }
    get x_z() {
        return this._matrix[2];
    }
    get y_x() {
        return this._matrix[3];
    }
    get y_y() {
        return this._matrix[4];
    }
    get y_z() {
        return this._matrix[5];
    }
    get z_x() {
        return this._matrix[6];
    }
    get z_y() {
        return this._matrix[7];
    }
    get z_z() {
        return this._matrix[8];
    }
    static fromMat3(m) {
        return new Mat3().setFromMat3(m);
    }
    static multiply(m1, m2) {
        const [a11, a12, a13, a21, a22, a23, a31, a32, a33] = m1._matrix;
        const [b11, b12, b13, b21, b22, b23, b31, b32, b33] = m2._matrix;
        const m = new Mat3();
        m.set(a11 * b11 + a12 * b21 + a13 * b31, a11 * b12 + a12 * b22 + a13 * b32, a11 * b13 + a12 * b23 + a13 * b33, a21 * b11 + a22 * b21 + a23 * b31, a21 * b12 + a22 * b22 + a23 * b32, a21 * b13 + a22 * b23 + a23 * b33, a31 * b11 + a32 * b21 + a33 * b31, a31 * b12 + a32 * b22 + a33 * b32, a31 * b13 + a32 * b23 + a33 * b33);
        return m;
    }
    static multiplyScalar(m, s) {
        const res = new Mat3();
        for (let i = 0; i < this.length; i++) {
            res._matrix[i] = m._matrix[i] * s;
        }
        return res;
    }
    static transpose(m) {
        const res = new Mat3();
        res.set(m.x_x, m.y_x, m.z_x, m.x_y, m.y_y, m.z_y, m.x_z, m.y_z, m.z_z);
        return res;
    }
    static invert(m) {
        const mTemp = new Mat3();
        mTemp.set(m.y_y * m.z_z - m.z_y * m.y_z, m.y_x * m.z_z - m.z_x * m.y_z, m.y_x * m.z_y - m.z_x * m.y_y, m.x_y * m.z_z - m.z_y * m.x_z, m.x_x * m.z_z - m.z_x * m.x_z, m.x_x * m.z_y - m.z_x * m.x_y, m.x_y * m.y_z - m.y_y * m.x_z, m.x_x * m.y_z - m.y_x * m.x_z, m.x_x * m.y_y - m.y_x * m.x_y);
        mTemp.set(mTemp.x_x, -mTemp.x_y, mTemp.x_z, -mTemp.y_x, mTemp.y_y, -mTemp.y_z, mTemp.z_x, -mTemp.z_y, mTemp.z_z);
        const det = m.x_x * mTemp.x_x + m.x_y * mTemp.x_y + m.x_z * mTemp.x_z;
        const inversed = new Mat3();
        if (!det) {
            inversed.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        else {
            const detInv = 1 / det;
            inversed.set(detInv * mTemp.x_x, detInv * mTemp.y_x, detInv * mTemp.z_x, detInv * mTemp.x_y, detInv * mTemp.y_y, detInv * mTemp.z_y, detInv * mTemp.x_z, detInv * mTemp.y_z, detInv * mTemp.z_z);
        }
        return inversed;
    }
    static buildScale(x, y = undefined) {
        y !== null && y !== void 0 ? y : (y = x);
        return new Mat3().set(x, 0, 0, 0, y, 0, 0, 0, 1);
    }
    static buildRotation(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        return new Mat3().set(c, -s, 0, s, c, 0, 0, 0, 1);
    }
    static buildTranslate(x, y) {
        return new Mat3().set(1, 0, 0, 0, 1, 0, x, y, 1);
    }
    static equals(m1, m2, precision = 6) {
        return m1.equals(m2, precision);
    }
    clone() {
        return new Mat3().set(this.x_x, this.x_y, this.x_z, this.y_x, this.y_y, this.y_z, this.z_x, this.z_y, this.z_z);
    }
    set(x_x, x_y, x_z, y_x, y_y, y_z, z_x, z_y, z_z) {
        this._matrix[0] = x_x;
        this._matrix[1] = x_y;
        this._matrix[2] = x_z;
        this._matrix[3] = y_x;
        this._matrix[4] = y_y;
        this._matrix[5] = y_z;
        this._matrix[6] = z_x;
        this._matrix[7] = z_y;
        this._matrix[8] = z_z;
        return this;
    }
    reset() {
        this._matrix[0] = 1;
        this._matrix[1] = 0;
        this._matrix[2] = 0;
        this._matrix[3] = 0;
        this._matrix[4] = 1;
        this._matrix[5] = 0;
        this._matrix[6] = 0;
        this._matrix[7] = 0;
        this._matrix[8] = 1;
        return this;
    }
    setFromMat3(m) {
        for (let i = 0; i < this.length; i++) {
            this._matrix[i] = m._matrix[i];
        }
        return this;
    }
    multiply(m) {
        const [a11, a12, a13, a21, a22, a23, a31, a32, a33] = this._matrix;
        const [b11, b12, b13, b21, b22, b23, b31, b32, b33] = m._matrix;
        this._matrix[0] = a11 * b11 + a12 * b21 + a13 * b31;
        this._matrix[1] = a11 * b12 + a12 * b22 + a13 * b32;
        this._matrix[2] = a11 * b13 + a12 * b23 + a13 * b33;
        this._matrix[3] = a21 * b11 + a22 * b21 + a23 * b31;
        this._matrix[4] = a21 * b12 + a22 * b22 + a23 * b32;
        this._matrix[5] = a21 * b13 + a22 * b23 + a23 * b33;
        this._matrix[6] = a31 * b11 + a32 * b21 + a33 * b31;
        this._matrix[7] = a31 * b12 + a32 * b22 + a33 * b32;
        this._matrix[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        for (let i = 0; i < this.length; i++) {
            this._matrix[i] *= s;
        }
        return this;
    }
    transpose() {
        const temp = new Mat3().setFromMat3(this);
        this.set(temp.x_x, temp.y_x, temp.z_x, temp.x_y, temp.y_y, temp.z_y, temp.x_z, temp.y_z, temp.z_z);
        return this;
    }
    invert() {
        const mTemp = new Mat3();
        mTemp.set(this.y_y * this.z_z - this.z_y * this.y_z, this.y_x * this.z_z - this.z_x * this.y_z, this.y_x * this.z_y - this.z_x * this.y_y, this.x_y * this.z_z - this.z_y * this.x_z, this.x_x * this.z_z - this.z_x * this.x_z, this.x_x * this.z_y - this.z_x * this.x_y, this.x_y * this.y_z - this.y_y * this.x_z, this.x_x * this.y_z - this.y_x * this.x_z, this.x_x * this.y_y - this.y_x * this.x_y);
        mTemp.set(mTemp.x_x, -mTemp.x_y, mTemp.x_z, -mTemp.y_x, mTemp.y_y, -mTemp.y_z, mTemp.z_x, -mTemp.z_y, mTemp.z_z);
        const det = this.x_x * mTemp.x_x + this.x_y * mTemp.x_y + this.x_z * mTemp.x_z;
        if (!det) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        else {
            const detInv = 1 / det;
            this.set(detInv * mTemp.x_x, detInv * mTemp.y_x, detInv * mTemp.z_x, detInv * mTemp.x_y, detInv * mTemp.y_y, detInv * mTemp.z_y, detInv * mTemp.x_z, detInv * mTemp.y_z, detInv * mTemp.z_z);
        }
        return this;
    }
    getDeterminant() {
        const [a, b, c, d, e, f, g, h, i] = this._matrix;
        return a * e * i - a * f * h + b * f * g - b * d * i + c * d * h - c * e * g;
    }
    getTRS() {
        const t = new Vec2(this.z_x, this.z_y);
        const s_x = Math.sqrt(this.x_x * this.x_x + this.x_y * this.x_y);
        const s_y = Math.sqrt(this.y_x * this.y_x + this.y_y * this.y_y);
        const s = new Vec2(s_x, s_y);
        const sign = Math.atan(-this.x_y / this.x_x);
        const angle = Math.acos(this.x_x / s_x);
        let r;
        if ((angle > Math.PI / 2 && sign > 0)
            || (angle < Math.PI / 2 && sign < 0)) {
            r = 2 * Math.PI - angle;
        }
        else {
            r = angle;
        }
        return { t, r, s };
    }
    equals(m, precision = 6) {
        for (let i = 0; i < this.length; i++) {
            if (+this._matrix[i].toFixed(precision) !== +m._matrix[i].toFixed(precision)) {
                return false;
            }
        }
        return true;
    }
    applyScaling(x, y = undefined) {
        const m = Mat3.buildScale(x, y);
        return this.multiply(m);
    }
    applyTranslation(x, y) {
        const m = Mat3.buildTranslate(x, y);
        return this.multiply(m);
    }
    applyRotation(theta) {
        const m = Mat3.buildRotation(theta);
        return this.multiply(m);
    }
    toArray() {
        return this._matrix.slice();
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toIntShortArray() {
        return new Int32Array([
            this._matrix[0],
            this._matrix[1],
            this._matrix[3],
            this._matrix[4],
            this._matrix[6],
            this._matrix[7],
        ]);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    toFloatShortArray() {
        return new Float32Array([
            +(this._matrix[0].toFixed(5)),
            +(this._matrix[1].toFixed(5)),
            +(this._matrix[3].toFixed(5)),
            +(this._matrix[4].toFixed(5)),
            +(this._matrix[6].toFixed(5)),
            +(this._matrix[7].toFixed(5)),
        ]);
    }
    *[Symbol.iterator]() {
        for (let i = 0; i < 9; i++) {
            yield this._matrix[i];
        }
    }
}
function mat3From4Vec2(aMin, aMax, bMin, bMax, noRotation = false) {
    const mat = new Mat3();
    mat.applyTranslation(-aMin.x, -aMin.y);
    const aLen = Vec2.substract(aMax, aMin).getMagnitude();
    const bLen = Vec2.substract(bMax, bMin).getMagnitude();
    const scale = bLen / aLen;
    mat.applyScaling(scale);
    if (!noRotation) {
        const aTheta = Math.atan2(aMax.y - aMin.y, aMax.x - aMin.x);
        const bTheta = Math.atan2(bMax.y - bMin.y, bMax.x - bMin.x);
        const rotation = aTheta - bTheta;
        mat.applyRotation(rotation);
    }
    mat.applyTranslation(bMin.x, bMin.y);
    return mat;
}
function vecMinMax(...values) {
    const min = new Vec2(Math.min(...values.map(x => x.x)), Math.min(...values.map(x => x.y)));
    const max = new Vec2(Math.max(...values.map(x => x.x)), Math.max(...values.map(x => x.y)));
    return { min, max };
}
function getDistance(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
}

function getNextNode(node) {
    if (node.hasChildNodes()) {
        return node.firstChild;
    }
    else {
        while (node && !node.nextSibling) {
            node = node.parentNode;
        }
        if (!node) {
            return null;
        }
        return node.nextSibling;
    }
}
function getRangeNodes(range) {
    let node = range.startContainer;
    const endNode = range.endContainer;
    if (node === endNode) {
        return [node];
    }
    const rangeNodes = [];
    while (node && node !== endNode) {
        rangeNodes.push(node = getNextNode(node));
    }
    node = range.startContainer;
    while (node && node !== range.commonAncestorContainer) {
        rangeNodes.unshift(node);
        node = node.parentNode;
    }
    return rangeNodes;
}
function getSelectionInfosFromRangeSpans(range) {
    var _a;
    const textNodes = getRangeNodes(range).filter(x => x.nodeType === 3);
    const selectionInfos = [];
    for (let i = 0; i < textNodes.length; i++) {
        const node = textNodes[i];
        const textContent = node.textContent;
        if (!textContent) {
            continue;
        }
        const textLength = ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0;
        let startOffset = 0;
        let endOffset = textLength;
        if (i === 0) {
            startOffset = range.startOffset;
        }
        if (i === textNodes.length - 1) {
            endOffset = range.endOffset;
        }
        const text = textContent.slice(startOffset, endOffset);
        if (!text) {
            continue;
        }
        const parent = node.parentElement;
        if (!parent || parent.tagName.toLowerCase() !== "span") {
            continue;
        }
        const dummies = parent.querySelectorAll(".dummy-corner");
        if (dummies.length !== 4) {
            continue;
        }
        const spanBlVec = new Vec2();
        const spanBrVec = new Vec2();
        const spanTrVec = new Vec2();
        const spanTlVec = new Vec2();
        dummies.forEach(dummy => {
            const { x, y } = dummy.getBoundingClientRect();
            if (dummy.classList.contains("bl")) {
                spanBlVec.set(x, y);
            }
            else if (dummy.classList.contains("br")) {
                spanBrVec.set(x, y);
            }
            else if (dummy.classList.contains("tr")) {
                spanTrVec.set(x, y);
            }
            else if (dummy.classList.contains("tl")) {
                spanTlVec.set(x, y);
            }
        });
        const startOffsetRelative = startOffset / textLength;
        const endOffsetRelative = endOffset / textLength;
        const spanBottomVec = Vec2.substract(spanBrVec, spanBlVec);
        const spanTopVec = Vec2.substract(spanTrVec, spanTlVec);
        const selectionBlVec = Vec2.add(spanBlVec, Vec2.multiplyByScalar(spanBottomVec, startOffsetRelative));
        const selectionBrVec = Vec2.add(spanBlVec, Vec2.multiplyByScalar(spanBottomVec, endOffsetRelative));
        const selectionTrVec = Vec2.add(spanTlVec, Vec2.multiplyByScalar(spanTopVec, endOffsetRelative));
        const selectionTlVec = Vec2.add(spanTlVec, Vec2.multiplyByScalar(spanTopVec, startOffsetRelative));
        selectionInfos.push({
            text,
            bottomLeft: selectionBlVec,
            bottomRight: selectionBrVec,
            topRight: selectionTrVec,
            topLeft: selectionTlVec,
        });
    }
    return selectionInfos;
}
function getSelectionInfosFromSelection(selection) {
    const selectionRange = selection.getRangeAt(0);
    return getSelectionInfosFromRangeSpans(selectionRange);
}

class ElementEventService {
    constructor(container) {
        this._eventMap = new Map();
        if (!container) {
            throw new Error("Container is not defined");
        }
        const element = document.createElement("div");
        element.style.position = "absolute";
        element.style.width = "0";
        element.style.height = "0";
        element.style.zIndex = "-1000";
        container.append(element);
        this._element = element;
    }
    get element() {
        return this._element;
    }
    destroy() {
        this.removeAllListeners();
        this._element.remove();
        this._element = null;
    }
    addListener(key, listener, options) {
        if (!this._element) {
            return;
        }
        this._element.addEventListener(key, listener, options);
        if (this._eventMap.has(key)) {
            this._eventMap.get(key).add(listener);
        }
        else {
            this._eventMap.set(key, new Set().add(listener));
        }
    }
    removeListener(key, listener) {
        if (!this._element) {
            return;
        }
        this._element.removeEventListener(key, listener);
        if (this._eventMap.has(key)) {
            this._eventMap.get(key).delete(listener);
        }
    }
    removeAllListenersForKey(key) {
        if (!this._element) {
            return;
        }
        if (this._eventMap.has(key)) {
            const listeners = this._eventMap.get(key);
            listeners.forEach(x => this._element.removeEventListener(key, x));
            this._eventMap.delete(key);
        }
    }
    removeAllListeners() {
        if (!this._element) {
            return;
        }
        this._eventMap.forEach((v, k) => {
            v.forEach(x => this._element.removeEventListener(k, x));
        });
        this._eventMap.clear();
    }
    getListenersByKey(key) {
        const listenerSet = this._eventMap.get(key);
        return listenerSet
            ? [...listenerSet]
            : [];
    }
    hasListenersForKey(key) {
        const listenerSet = this._eventMap.get(key);
        return !!(listenerSet === null || listenerSet === void 0 ? void 0 : listenerSet.size);
    }
    dispatchEvent(e) {
        if (!this._element) {
            return;
        }
        if (!this.hasListenersForKey(e.type)) {
            return;
        }
        this._element.dispatchEvent(e);
    }
}

const objectTypes = {
    UNKNOWN: 0,
    NULL: 1,
    BOOLEAN: 2,
    NUMBER: 3,
    STRING_LITERAL: 4,
    STRING_HEX: 5,
    NAME: 6,
    ARRAY: 7,
    DICTIONARY: 8,
    STREAM: 9,
};
const xRefTypes = {
    TABLE: 0,
    STREAM: 1,
    HYBRID: 2,
};
const xRefEntryTypes = {
    FREE: 0,
    NORMAL: 1,
    COMPRESSED: 2,
};
const streamFilters = {
    ASCII85: "/ASCII85Decode",
    ASCIIHEX: "/ASCIIHexDecode",
    CCF: "/CCITTFaxDecode",
    CRYPT: "/Crypt",
    DCT: "/DCTDecode",
    FLATE: "/FlateDecode",
    JBIG2: "/JBIG2Decode",
    JPX: "/JPXDecode",
    LZW: "/LZWDecode",
    RLX: "/RunLengthDecode",
};
const flatePredictors = {
    NONE: 1,
    TIFF: 2,
    PNG_NONE: 10,
    PNG_SUB: 11,
    PNG_UP: 12,
    PNG_AVERAGE: 13,
    PNG_PAETH: 14,
    PNG_OPTIMUM: 15,
};
const cryptVersions = {
    RC4_40: 1,
    RC4_128: 2,
    AES_128: 4,
    AES_256: 5,
};
const cryptRevisions = {
    RC4_40: 2,
    RC4_128: 3,
    AES_128: 4,
    AES_256: 5,
    AES_256_V2: 6,
};
const cryptMethods = {
    NONE: "/None",
    RC4: "/V2",
    AES_128: "/AESV2",
    AES_256: "/AESV3",
};
const authEvents = {
    DOC_OPEN: "/DocOpen",
    EMBEDDED_OPEN: "/EFOpen",
};
const streamTypes = {
    XREF: "/XRef",
    OBJECT_STREAM: "/ObjStm",
    FORM_XOBJECT: "/XObject",
    METADATA_STREAM: "/Metadata",
};
const dictTypes = {
    XREF: "/XRef",
    XOBJECT: "/XObject",
    CATALOG: "/Catalog",
    PAGE_TREE: "/Pages",
    PAGE: "/Page",
    ANNOTATION: "/Annot",
    BORDER_STYLE: "/Border",
    OPTIONAL_CONTENT_GROUP: "/OCG",
    OPTIONAL_CONTENT_MD: "/OCMD",
    EXTERNAL_DATA: "/ExDATA",
    ACTION: "/Action",
    MEASURE: "/Measure",
    DEV_EXTENSIONS: "/DeveloperExtensions",
    GRAPHICS_STATE: "/ExtGState",
    CRYPT_FILTER: "/CryptFilter",
    SOFT_MASK: "/Mask",
    GROUP: "/Group",
    FONT: "/Font",
    EMPTY: "",
};
const groupDictTypes = {
    TRANSPARENCY: "/Transparency",
};
const valueTypes = {
    UNKNOWN: 0,
    NULL: 1,
    BOOLEAN: 2,
    NUMBER: 3,
    STRING_LITERAL: 4,
    STRING_HEX: 5,
    NAME: 6,
    ARRAY: 7,
    DICTIONARY: 8,
    STREAM: 9,
    REF: 10,
    COMMENT: 11,
};
const annotationTypes = {
    TEXT: "/Text",
    LINK: "/Link",
    FREE_TEXT: "/FreeText",
    LINE: "/Line",
    SQUARE: "/Square",
    CIRCLE: "/Circle",
    POLYGON: "/Polygon",
    POLYLINE: "/PolyLine",
    HIGHLIGHT: "/Highlight",
    UNDERLINE: "/Underline",
    SQUIGGLY: "/Squiggly",
    STRIKEOUT: "/StrikeOut",
    STAMP: "/Stamp",
    CARET: "/Caret",
    INK: "/Ink",
    POPUP: "/Popup",
    FILE_ATTACHMENT: "/FileAttachment",
    SOUND: "/Sound",
    MOVIE: "/Movie",
    WIDGET: "/Widget",
    SCREEN: "/Screen",
    PRINTER_MARK: "/PrinterMark",
    TRAPNET: "/TrapNet",
    WATERMARK: "/Watermark",
    THREED: "/3D",
    REDACT: "/Redact",
    PROJECTION: "/Projection",
    RICH_MEDIA: "/RichMedia",
};
const annotationStateModelTypes = {
    MARKED: "/Marked",
    REVIEW: "/Review",
};
const annotationMarkedStates = {
    MARKED: "/Marked",
    UNMARKED: "/Unmarked",
};
const annotationReviewStates = {
    ACCEPTED: "/Accepted",
    REJECTED: "/Rejected",
    CANCELLED: "/Cancelled",
    COMPLETED: "/Completed",
    NONE: "/None",
};
const annotationIconTypes = {
    COMMENT: "/Comment",
    KEY: "/Key",
    NOTE: "/Note",
    HELP: "/Help",
    NEW_PARAGRAPH: "/NewParagraph",
    PARAGRAPH: "/Paragraph",
    INSERT: "/Insert",
};
const lineEndingTypes = {
    SQUARE: "/Square",
    CIRCLE: "/Circle",
    DIAMOND: "/Diamond",
    ARROW_OPEN: "/OpenArrow",
    ARROW_CLOSED: "/ClosedArrow",
    NONE: "/None",
    BUTT: "/Butt",
    ARROW_OPEN_R: "/ROpenArrow",
    ARROW_CLOSED_R: "/RClosedArrow",
    SLASH: "/Slash",
};
const lineCapStyles = {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2,
};
const lineJoinStyles = {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2,
};
const renderingIntents = {
    ABSOLUTE: "/AbsoluteColorimetric",
    RELATIVE: "/RelativeColorimetric",
    SATURATION: "/Saturation",
    PERCEPTUAL: "/Perceptual",
};
const blendModes = {
    NORMAL: "/Normal",
    COMPATIBLE: "/Compatible",
    MULTIPLY: "/Multiply",
    SCREEN: "/Screen",
    OVERLAY: "/Overlay",
    DARKEN: "/Darken",
    LIGHTEN: "/Lighten",
    COLOR_DODGE: "/ColorDodge",
    COLOR_BURN: "/ColorBurn",
    HARD_LIGHT: "/HardLight",
    SOFT_LIGHT: "/SoftLight",
    DIFFERENCE: "/Difference",
    EXCLUSION: "/Exclusion",
};
const textRenderModes = {
    FILL: 0,
    STROKE: 1,
    FILL_STROKE: 2,
    INVISIBLE: 3,
    FILL_USE_AS_CLIP: 4,
    STROKE_USE_AS_CLIP: 5,
    FILL_STROKE_USE_AS_CLIP: 6,
    USE_AS_CLIP: 7,
};
const colorSpaces = {
    GRAYSCALE: "/DeviceGray",
    RGB: "/DeviceRGB",
    CMYK: "/DeviceCMYK",
    SPECIAL: "/DeviceN",
    SPECIAL_INDEXED: "/Indexed",
    SPECIAL_PATTERN: "/Pattern",
    SPECIAL_SEPARATION: "/Separation",
};
const softMaskTypes = {
    ALPHA: "/Alpha",
    LUMINOSITY: "/Luminosity",
};
const supportedFilters = new Set([
    streamFilters.FLATE,
    streamFilters.DCT,
    streamFilters.JBIG2,
    streamFilters.JPX,
]);
const maxGeneration = 65535;

const codes = {
    NULL: 0,
    BACKSPACE: 8,
    HORIZONTAL_TAB: 9,
    LINE_FEED: 10,
    VERTICAL_TAB: 11,
    FORM_FEED: 12,
    CARRIAGE_RETURN: 13,
    WHITESPACE: 32,
    EXCLAMATION_MARK: 33,
    DOUBLE_QUOTE: 34,
    HASH: 35,
    DOLLAR: 36,
    PERCENT: 37,
    AMPERSAND: 38,
    QUOTE: 39,
    L_PARENTHESE: 40,
    R_PARENTHESE: 41,
    ASTERISK: 42,
    PLUS: 43,
    COMMA: 44,
    MINUS: 45,
    DOT: 46,
    SLASH: 47,
    D_0: 48,
    D_1: 49,
    D_2: 50,
    D_3: 51,
    D_4: 52,
    D_5: 53,
    D_6: 54,
    D_7: 55,
    D_8: 56,
    D_9: 57,
    COLON: 58,
    SEMICOLON: 59,
    LESS: 60,
    EQUAL: 61,
    GREATER: 62,
    QUESTION_MARK: 63,
    AT: 64,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    L_BRACKET: 91,
    BACKSLASH: 92,
    R_BRACKET: 93,
    CARET: 94,
    UNDERSCORE: 95,
    BACKTICK: 96,
    a: 97,
    b: 98,
    c: 99,
    d: 100,
    e: 101,
    f: 102,
    g: 103,
    h: 104,
    i: 105,
    j: 106,
    k: 107,
    l: 108,
    m: 109,
    n: 110,
    o: 111,
    p: 112,
    q: 113,
    r: 114,
    s: 115,
    t: 116,
    u: 117,
    v: 118,
    w: 119,
    x: 120,
    y: 121,
    z: 122,
    L_BRACE: 123,
    VERTICAL_LINE: 124,
    R_BRACE: 125,
    TILDE: 126,
};
const keywordCodes = {
    NULL: [codes.n, codes.u, codes.l, codes.l],
    OBJ: [codes.o, codes.b, codes.j],
    OBJ_END: [codes.e, codes.n, codes.d, codes.o, codes.b, codes.j],
    STREAM_START: [codes.s, codes.t, codes.r, codes.e, codes.a, codes.m],
    STREAM_END: [codes.e, codes.n, codes.d,
        codes.s, codes.t, codes.r, codes.e, codes.a, codes.m],
    DICT_START: [codes.LESS, codes.LESS],
    DICT_END: [codes.GREATER, codes.GREATER],
    ARRAY_START: [codes.L_BRACKET],
    ARRAY_END: [codes.R_BRACKET],
    STR_LITERAL_START: [codes.L_PARENTHESE],
    STR_LITERAL_END: [codes.R_PARENTHESE],
    STR_HEX_START: [codes.LESS],
    STR_HEX_END: [codes.GREATER],
    VERSION: [codes.PERCENT, codes.P, codes.D, codes.F, codes.MINUS],
    PREV: [codes.SLASH, codes.P, codes.r, codes.e, codes.v],
    TYPE: [codes.SLASH, codes.T, codes.y, codes.p, codes.e],
    SUBTYPE: [codes.SLASH, codes.S, codes.u, codes.b, codes.t, codes.y, codes.p, codes.e],
    FORM: [codes.SLASH, codes.F, codes.o, codes.r, codes.m],
    XREF_TABLE: [codes.x, codes.r, codes.e, codes.f],
    XREF_STREAM: [codes.SLASH, codes.X, codes.R, codes.e, codes.f],
    XREF_HYBRID: [codes.X, codes.R, codes.e, codes.f, codes.S, codes.t, codes.m],
    XREF_START: [codes.s, codes.t, codes.a, codes.r, codes.t,
        codes.x, codes.r, codes.e, codes.f],
    TRAILER: [codes.t, codes.r, codes.a, codes.i, codes.l, codes.e, codes.r],
    END_OF_FILE: [codes.PERCENT, codes.PERCENT, codes.E, codes.O, codes.F],
    END_OF_LINE: [codes.CARRIAGE_RETURN, codes.LINE_FEED],
    TRUE: [codes.t, codes.r, codes.u, codes.e],
    FALSE: [codes.f, codes.a, codes.l, codes.s, codes.e],
};
const DELIMITER_CHARS = new Set([
    codes.PERCENT,
    codes.L_PARENTHESE,
    codes.R_PARENTHESE,
    codes.SLASH,
    codes.LESS,
    codes.GREATER,
    codes.L_BRACKET,
    codes.R_BRACKET,
    codes.L_BRACE,
    codes.R_BRACE,
]);
const SPACE_CHARS = new Set([
    codes.NULL,
    codes.HORIZONTAL_TAB,
    codes.LINE_FEED,
    codes.FORM_FEED,
    codes.CARRIAGE_RETURN,
    codes.WHITESPACE,
]);
const DIGIT_CHARS = new Set([
    codes.D_0,
    codes.D_1,
    codes.D_2,
    codes.D_3,
    codes.D_4,
    codes.D_5,
    codes.D_6,
    codes.D_7,
    codes.D_8,
    codes.D_9,
]);
function isRegularChar(code) {
    if (isNaN(code)) {
        return false;
    }
    return !DELIMITER_CHARS.has(code) && !SPACE_CHARS.has(code);
}
function isDigit(code) {
    return DIGIT_CHARS.has(code);
}

class DataParser {
    constructor(data) {
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new Error("Data is empty");
        }
        this._data = data;
        this._maxIndex = data.length - 1;
    }
    get maxIndex() {
        return this._maxIndex;
    }
    getPdfVersion() {
        var _a;
        const i = this.findSubarrayIndex(keywordCodes.VERSION);
        if (!i) {
            throw new Error("PDF not valid. Version not found");
        }
        const version = (_a = this.parseNumberAt(i.end + 1, true)) === null || _a === void 0 ? void 0 : _a.value;
        if (!version) {
            throw new Error("Error parsing version number");
        }
        return version.toFixed(1);
    }
    getLastXrefIndex() {
        const xrefStartIndex = this.findSubarrayIndex(keywordCodes.XREF_START, { maxIndex: this.maxIndex, direction: "reverse" });
        if (!xrefStartIndex) {
            return null;
        }
        const xrefIndex = this.parseNumberAt(xrefStartIndex.end + 1);
        if (!xrefIndex) {
            return null;
        }
        return xrefIndex;
    }
    findSubarrayIndex(sub, options) {
        var _a, _b;
        const arr = this._data;
        if (!(sub === null || sub === void 0 ? void 0 : sub.length)) {
            return null;
        }
        const direction = (options === null || options === void 0 ? void 0 : options.direction) || "straight";
        const minIndex = Math.max(Math.min((_a = options === null || options === void 0 ? void 0 : options.minIndex) !== null && _a !== void 0 ? _a : 0, this._maxIndex), 0);
        const maxIndex = Math.max(Math.min((_b = options === null || options === void 0 ? void 0 : options.maxIndex) !== null && _b !== void 0 ? _b : this._maxIndex, this._maxIndex), 0);
        const allowOpened = !(options === null || options === void 0 ? void 0 : options.closedOnly);
        let i = direction === "straight"
            ? minIndex
            : maxIndex;
        let j;
        if (direction === "straight") {
            outer_loop: for (i; i <= maxIndex; i++) {
                for (j = 0; j < sub.length; j++) {
                    if (arr[i + j] !== sub[j]) {
                        continue outer_loop;
                    }
                }
                if (allowOpened || !isRegularChar(arr[i + j])) {
                    return { start: i, end: i + j - 1 };
                }
            }
        }
        else {
            const subMaxIndex = sub.length - 1;
            outer_loop: for (i; i >= minIndex; i--) {
                for (j = 0; j < sub.length; j++) {
                    if (arr[i - j] !== sub[subMaxIndex - j]) {
                        continue outer_loop;
                    }
                }
                if (allowOpened || !isRegularChar(arr[i - j])) {
                    return { start: i - j + 1, end: i };
                }
            }
        }
        return null;
    }
    findCharIndex(charCode, direction = "straight", start) {
        return this.findSingleCharIndex((value) => charCode === value, direction, start);
    }
    findNewLineIndex(direction = "straight", start) {
        let lineBreakIndex = this.findSingleCharIndex((value) => value === codes.CARRIAGE_RETURN || value === codes.LINE_FEED, direction, start);
        if (lineBreakIndex === -1) {
            return -1;
        }
        if (direction === "straight") {
            if (this._data[lineBreakIndex] === codes.CARRIAGE_RETURN
                && this._data[lineBreakIndex + 1] === codes.LINE_FEED) {
                lineBreakIndex++;
            }
            return Math.min(lineBreakIndex + 1, this._maxIndex);
        }
        else {
            if (this._data[lineBreakIndex] === codes.LINE_FEED
                && this._data[lineBreakIndex - 1] === codes.CARRIAGE_RETURN) {
                lineBreakIndex--;
            }
            return Math.max(lineBreakIndex - 1, 0);
        }
    }
    findSpaceIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => SPACE_CHARS.has(value), direction, start);
    }
    findNonSpaceIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => !SPACE_CHARS.has(value), direction, start);
    }
    findDelimiterIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => DELIMITER_CHARS.has(value), direction, start);
    }
    findNonDelimiterIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => !DELIMITER_CHARS.has(value), direction, start);
    }
    findIrregularIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => !isRegularChar(value), direction, start);
    }
    findRegularIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => isRegularChar(value), direction, start);
    }
    getValueTypeAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        const arr = this._data;
        const i = start;
        const charCode = arr[i];
        switch (charCode) {
            case codes.SLASH:
                if (isRegularChar(arr[i + 1])) {
                    return valueTypes.NAME;
                }
                return valueTypes.UNKNOWN;
            case codes.L_BRACKET:
                return valueTypes.ARRAY;
            case codes.L_PARENTHESE:
                return valueTypes.STRING_LITERAL;
            case codes.LESS:
                if (codes.LESS === arr[i + 1]) {
                    return valueTypes.DICTIONARY;
                }
                return valueTypes.STRING_HEX;
            case codes.PERCENT:
                return valueTypes.COMMENT;
            case codes.D_0:
            case codes.D_1:
            case codes.D_2:
            case codes.D_3:
            case codes.D_4:
            case codes.D_5:
            case codes.D_6:
            case codes.D_7:
            case codes.D_8:
            case codes.D_9:
                const nextDelimIndex = this.findDelimiterIndex("straight", i + 1);
                if (nextDelimIndex !== -1) {
                    const refEndIndex = this.findCharIndex(codes.R, "reverse", nextDelimIndex - 1);
                    if (refEndIndex !== -1 && refEndIndex > i && !isRegularChar(arr[refEndIndex + 1])) {
                        return valueTypes.REF;
                    }
                }
                return valueTypes.NUMBER;
            case codes.DOT:
            case codes.MINUS:
                if (isDigit(arr[i + 1])) {
                    return valueTypes.NUMBER;
                }
                return valueTypes.UNKNOWN;
            case codes.s:
                if (arr[i + 1] === codes.t
                    && arr[i + 2] === codes.r
                    && arr[i + 3] === codes.e
                    && arr[i + 4] === codes.a
                    && arr[i + 5] === codes.m) {
                    return valueTypes.STREAM;
                }
                return valueTypes.UNKNOWN;
            case codes.t:
                if (arr[i + 1] === codes.r
                    && arr[i + 2] === codes.u
                    && arr[i + 3] === codes.e) {
                    return valueTypes.BOOLEAN;
                }
                return valueTypes.UNKNOWN;
            case codes.f:
                if (arr[i + 1] === codes.a
                    && arr[i + 2] === codes.l
                    && arr[i + 3] === codes.s
                    && arr[i + 4] === codes.e) {
                    return valueTypes.BOOLEAN;
                }
                return valueTypes.UNKNOWN;
            default:
                return valueTypes.UNKNOWN;
        }
    }
    getIndirectObjectBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        const objStartIndex = this.findSubarrayIndex(keywordCodes.OBJ, { minIndex: start, closedOnly: true });
        if (!objStartIndex) {
            return null;
        }
        let contentStart = this.findNonSpaceIndex("straight", objStartIndex.end + 1);
        if (contentStart === -1) {
            return null;
        }
        const objEndIndex = this.findSubarrayIndex(keywordCodes.OBJ_END, { minIndex: contentStart, closedOnly: true });
        if (!objEndIndex) {
            return null;
        }
        let contentEnd = this.findNonSpaceIndex("reverse", objEndIndex.start - 1);
        if (this.getCharCode(contentStart) === codes.LESS
            && this.getCharCode(contentStart + 1) === codes.LESS
            && this.getCharCode(contentEnd - 1) === codes.GREATER
            && this.getCharCode(contentEnd) === codes.GREATER) {
            contentStart += 2;
            contentEnd -= 2;
        }
        return {
            start: objStartIndex.start,
            end: objEndIndex.end,
            contentStart,
            contentEnd,
        };
    }
    getXrefTableBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this._data[start] !== codes.x) {
            return null;
        }
        const xrefStart = this.findSubarrayIndex(keywordCodes.XREF_TABLE, { minIndex: start });
        if (!xrefStart) {
            return null;
        }
        const contentStart = this.findNonSpaceIndex("straight", xrefStart.end + 1);
        if (contentStart === -1) {
            return null;
        }
        const xrefEnd = this.findSubarrayIndex(keywordCodes.TRAILER, { minIndex: xrefStart.end + 1 });
        if (!xrefEnd) {
            return null;
        }
        const contentEnd = this.findNonSpaceIndex("reverse", xrefEnd.start - 1);
        if (contentEnd < contentStart) {
            return null;
        }
        return {
            start: xrefStart.start,
            end: xrefEnd.end,
            contentStart,
            contentEnd,
        };
    }
    getDictBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)
            || this._data[start] !== codes.LESS
            || this._data[start + 1] !== codes.LESS) {
            return null;
        }
        const contentStart = this.findNonSpaceIndex("straight", start + 2);
        if (contentStart === -1) {
            return null;
        }
        let dictOpened = 1;
        let dictBound = true;
        let literalOpened = 0;
        let i = contentStart;
        let code;
        let prevCode;
        while (dictOpened) {
            prevCode = code;
            code = this._data[i++];
            if (code === codes.L_PARENTHESE
                && (!literalOpened || prevCode !== codes.BACKSLASH)) {
                literalOpened++;
            }
            if (code === codes.R_PARENTHESE
                && (literalOpened && prevCode !== codes.BACKSLASH)) {
                literalOpened--;
            }
            if (literalOpened) {
                continue;
            }
            if (!dictBound) {
                if (code === codes.LESS && code === prevCode) {
                    dictOpened++;
                    dictBound = true;
                }
                else if (code === codes.GREATER && code === prevCode) {
                    dictOpened--;
                    dictBound = true;
                }
            }
            else {
                dictBound = false;
            }
        }
        const end = i - 1;
        const contentEnd = this.findNonSpaceIndex("reverse", end - 2);
        if (contentEnd < contentStart) {
            return {
                start,
                end,
            };
        }
        return {
            start,
            end,
            contentStart,
            contentEnd,
        };
    }
    getArrayBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this._data[start] !== codes.L_BRACKET) {
            return null;
        }
        let arraysOpened = 1;
        let i = start + 1;
        let code;
        while (arraysOpened) {
            code = this._data[i++];
            if (code === codes.L_BRACKET) {
                arraysOpened++;
            }
            else if (code === codes.R_BRACKET) {
                arraysOpened--;
            }
        }
        const arrayEnd = i - 1;
        if (arrayEnd - start < 1) {
            return null;
        }
        return { start, end: arrayEnd };
    }
    getHexBounds(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this.getCharCode(start) !== codes.LESS) {
            return null;
        }
        const end = this.findCharIndex(codes.GREATER, "straight", start + 1);
        if (end === -1) {
            return null;
        }
        return { start, end };
    }
    getLiteralBounds(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this.getCharCode(start) !== codes.L_PARENTHESE) {
            return null;
        }
        let i = start + 1;
        let prevCode;
        let code;
        let opened = 0;
        while (opened || code !== codes.R_PARENTHESE || prevCode === codes.BACKSLASH) {
            if (i > this._maxIndex) {
                return null;
            }
            if (!isNaN(code)) {
                prevCode = code;
            }
            code = this.getCharCode(i++);
            if (prevCode !== codes.BACKSLASH) {
                if (code === codes.L_PARENTHESE) {
                    opened += 1;
                }
                else if (opened && code === codes.R_PARENTHESE) {
                    opened -= 1;
                }
            }
        }
        return { start, end: i - 1 };
    }
    parseNumberAt(start, float = false, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || !isRegularChar(this._data[start])) {
            return null;
        }
        let i = start;
        let numberStr = "";
        let value = this._data[i];
        if (value === codes.MINUS) {
            numberStr += "-";
            value = this._data[++i];
        }
        else if (value === codes.DOT) {
            numberStr += "0.";
            value = this._data[++i];
        }
        while (DIGIT_CHARS.has(value)
            || (float && value === codes.DOT)) {
            numberStr += String.fromCharCode(value);
            value = this._data[++i];
        }
        return numberStr
            ? { value: +numberStr, start, end: i - 1 }
            : null;
    }
    parseNameAt(start, includeSlash = true, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this._data[start] !== codes.SLASH) {
            return null;
        }
        let i = start + 1;
        let result = includeSlash
            ? "/"
            : "";
        let value = this._data[i];
        while (isRegularChar(value)) {
            result += String.fromCharCode(value);
            value = this._data[++i];
        }
        return result.length > 1
            ? { value: result, start, end: i - 1 }
            : null;
    }
    parseStringAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        let i = start;
        let result = "";
        let value = this._data[i];
        while (isRegularChar(value)) {
            result += String.fromCharCode(value);
            value = this._data[++i];
        }
        return result.length !== 0
            ? { value: result, start, end: i - 1 }
            : null;
    }
    parseBoolAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        const nearestDelimiter = this.findDelimiterIndex("straight", start);
        const isTrue = this.findSubarrayIndex(keywordCodes.TRUE, {
            minIndex: start,
            maxIndex: nearestDelimiter === -1 ? this._maxIndex : nearestDelimiter,
        });
        if (isTrue) {
            return { value: true, start, end: isTrue.end };
        }
        const isFalse = this.findSubarrayIndex(keywordCodes.FALSE, {
            minIndex: start,
            maxIndex: nearestDelimiter === -1 ? this._maxIndex : nearestDelimiter,
        });
        if (isFalse) {
            return { value: false, start, end: isFalse.end };
        }
        return null;
    }
    parseNumberArrayAt(start, float = true, skipEmpty = true) {
        const arrayBounds = this.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const numbers = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = this.parseNumberAt(i, float, true);
            if (!current) {
                break;
            }
            numbers.push(current.value);
            i = current.end + 1;
        }
        return { value: numbers, start: arrayBounds.start, end: arrayBounds.end };
    }
    parseNameArrayAt(start, includeSlash = true, skipEmpty = true) {
        const arrayBounds = this.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const names = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = this.parseNameAt(i, includeSlash, true);
            if (!current) {
                break;
            }
            names.push(current.value);
            i = current.end + 1;
        }
        return { value: names, start: arrayBounds.start, end: arrayBounds.end };
    }
    parseDictType(bounds) {
        return this.parseDictPropertyByName(keywordCodes.TYPE, bounds);
    }
    parseDictSubtype(bounds) {
        return this.parseDictPropertyByName(keywordCodes.SUBTYPE, bounds);
    }
    parseDictPropertyByName(propName, bounds) {
        var _a, _b;
        const arr = this._data;
        if (!(propName === null || propName === void 0 ? void 0 : propName.length)) {
            return null;
        }
        const minIndex = Math.max(Math.min((_a = bounds.start) !== null && _a !== void 0 ? _a : 0, this._maxIndex), 0);
        const maxIndex = Math.max(Math.min((_b = bounds.end) !== null && _b !== void 0 ? _b : this._maxIndex, this._maxIndex), 0);
        let propNameBounds;
        let i = minIndex;
        let j;
        let code;
        let prevCode;
        let dictOpened = 0;
        let dictBound = true;
        let literalOpened = 0;
        outer_loop: for (i; i <= maxIndex; i++) {
            prevCode = code;
            code = arr[i];
            if (code === codes.L_PARENTHESE
                && (!literalOpened || prevCode !== codes.BACKSLASH)) {
                literalOpened++;
            }
            if (code === codes.R_PARENTHESE
                && (literalOpened && prevCode !== codes.BACKSLASH)) {
                literalOpened--;
            }
            if (literalOpened) {
                continue;
            }
            if (!dictBound) {
                if (code === codes.LESS && code === prevCode) {
                    dictOpened++;
                    dictBound = true;
                }
                else if (code === codes.GREATER && code === prevCode) {
                    dictOpened--;
                    dictBound = true;
                }
            }
            else {
                dictBound = false;
            }
            for (j = 0; j < propName.length; j++) {
                if (arr[i + j] !== propName[j]) {
                    continue outer_loop;
                }
            }
            if (dictOpened !== 1) {
                continue;
            }
            if (!isRegularChar(arr[i + j])) {
                propNameBounds = { start: i, end: i + j - 1 };
                break;
            }
        }
        if (!propNameBounds) {
            return null;
        }
        const type = this.parseNameAt(propNameBounds.end + 1);
        if (!type) {
            return null;
        }
        return type.value;
    }
    skipEmpty(start) {
        let index = this.findNonSpaceIndex("straight", start);
        if (index === -1) {
            return -1;
        }
        if (this._data[index] === codes.PERCENT) {
            const afterComment = this.findNewLineIndex("straight", index + 1);
            if (afterComment === -1) {
                return -1;
            }
            index = this.findNonSpaceIndex("straight", afterComment);
        }
        return index;
    }
    skipToNextName(start, max) {
        start || (start = 0);
        max = max
            ? Math.min(max, this._maxIndex)
            : 0;
        if (max < start) {
            return -1;
        }
        let i = start;
        while (i <= max) {
            const value = this.getValueTypeAt(i, true);
            if (value) {
                let skipValueBounds;
                switch (value) {
                    case valueTypes.DICTIONARY:
                        skipValueBounds = this.getDictBoundsAt(i, false);
                        break;
                    case valueTypes.ARRAY:
                        skipValueBounds = this.getArrayBoundsAt(i, false);
                        break;
                    case valueTypes.STRING_LITERAL:
                        skipValueBounds = this.getLiteralBounds(i, false);
                        break;
                    case valueTypes.STRING_HEX:
                        skipValueBounds = this.getHexBounds(i, false);
                        break;
                    case valueTypes.NUMBER:
                        const numberParseResult = this.parseNumberAt(i, true, false);
                        if (numberParseResult) {
                            skipValueBounds = numberParseResult;
                        }
                        break;
                    case valueTypes.BOOLEAN:
                        const boolParseResult = this.parseBoolAt(i, false);
                        if (boolParseResult) {
                            skipValueBounds = boolParseResult;
                        }
                        break;
                    case valueTypes.COMMENT:
                        break;
                    case valueTypes.NAME:
                        return i;
                    default:
                        i++;
                        continue;
                }
                if (skipValueBounds) {
                    i = skipValueBounds.end + 1;
                    skipValueBounds = null;
                    continue;
                }
            }
            i++;
        }
        return -1;
    }
    getCharCode(index) {
        return this._data[index];
    }
    getChar(index) {
        const code = this._data[index];
        if (!isNaN(code)) {
            return String.fromCharCode(code);
        }
        return null;
    }
    sliceCharCodes(start, end) {
        return this._data.slice(start, (end || start) + 1);
    }
    sliceChars(start, end) {
        return String.fromCharCode(...this._data.slice(start, (end || start) + 1));
    }
    subCharCodes(start, end) {
        return this._data.subarray(start, (end || start) + 1);
    }
    isOutside(index) {
        return (index < 0 || index > this._maxIndex);
    }
    findSingleCharIndex(filter, direction = "straight", start) {
        const arr = this._data;
        let i = isNaN(start)
            ? direction === "straight"
                ? 0
                : this._maxIndex
            : start;
        if (direction === "straight") {
            for (i; i <= this._maxIndex; i++) {
                if (filter(arr[i])) {
                    return i;
                }
            }
        }
        else {
            for (i; i >= 0; i--) {
                if (filter(arr[i])) {
                    return i;
                }
            }
        }
        return -1;
    }
}

class LinkedListNode {
    constructor(data) {
        this.data = data;
    }
}
class LinkedList {
    constructor(head) {
        this._length = 0;
        if (head) {
            this.push(head);
        }
    }
    get head() {
        return this._head.data;
    }
    get length() {
        return this._length;
    }
    get tail() {
        return this.get(this._length - 1);
    }
    push(value) {
        const node = new LinkedListNode(value);
        let current;
        if (!this._head) {
            this._head = node;
        }
        else {
            current = this._head;
            while (current.next) {
                current = current.next;
            }
            current.next = node;
        }
        this._length++;
    }
    insert(value, n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        const node = new LinkedListNode(value);
        let previous;
        let current = this._head;
        let i = 0;
        if (!n) {
            this._head = node;
        }
        else {
            while (i++ < n) {
                previous = current;
                current = current.next;
            }
            previous.next = node;
        }
        node.next = current;
        this._length++;
        return node.data;
    }
    replace(value, n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        const node = new LinkedListNode(value);
        let previous;
        let current = this._head;
        let i = 0;
        if (!n) {
            this._head = node;
        }
        else {
            while (i++ < n) {
                previous = current;
                current = current.next;
            }
            previous.next = node;
        }
        node.next = current.next;
        return current.data;
    }
    remove(n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        let previous;
        let current = this._head;
        let i = 0;
        if (!n) {
            this._head = current.next;
        }
        else {
            while (i++ < n) {
                previous = current;
                current = current.next;
            }
            previous.next = current.next;
        }
        this._length--;
        return current.data;
    }
    clear() {
        this._head = null;
        this._length = 0;
    }
    get(n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        let current = this._head;
        let i = 0;
        while (i++ < n) {
            current = current.next;
        }
        return current.data;
    }
    pop() {
        return this.remove(this._length - 1);
    }
    has(value, comparator) {
        if (!this._length) {
            return false;
        }
        comparator || (comparator = (a, b) => a === b);
        let current = this._head;
        let i = 0;
        while (i < this._length) {
            if (comparator(value, current.data)) {
                return true;
            }
            current = current.next;
            i++;
        }
        return false;
    }
    findIndex(value, comparator) {
        if (!this._length) {
            return -1;
        }
        comparator || (comparator = (a, b) => a === b);
        let current = this._head;
        let i = 0;
        while (i < this._length) {
            if (comparator(value, current.data)) {
                return i;
            }
            current = current.next;
            i++;
        }
        return -1;
    }
    *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
            yield current.data;
            current = current.next;
        }
    }
}

function parseIntFromBytes(bytes) {
    if (!(bytes === null || bytes === void 0 ? void 0 : bytes.length)) {
        return 0;
    }
    if (bytes.length === 1) {
        return bytes[0];
    }
    const hex = Array.from(bytes, (byte) => ("0" + (byte & 0xFF).toString(16)).slice(-2)).join("");
    return parseInt(hex, 16);
}
function int8ToBytes(int) {
    const buffer = new ArrayBuffer(1);
    const view = new DataView(buffer);
    view.setInt8(0, int);
    return new Uint8Array(buffer);
}
function int16ToBytes(int, le = false) {
    const buffer = new ArrayBuffer(2);
    const view = new DataView(buffer);
    view.setInt16(0, int, le);
    return new Uint8Array(buffer);
}
function int32ToBytes(int, le = false) {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setInt32(0, int, le);
    return new Uint8Array(buffer);
}
function int32ArrayToBytes(ints, le = false) {
    const buffer = new ArrayBuffer(ints.length * 4);
    const view = new DataView(buffer);
    for (let i = 0; i < ints.length; i++) {
        view.setInt32(i * 4, ints[i], le);
    }
    return new Uint8Array(buffer);
}
function xorBytes(bytes, n) {
    const result = new Uint8Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        result[i] = bytes[i] ^ n;
    }
    return result;
}
function arraysEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
function findSubarrayIndex(arr, sub) {
    if ((arr === null || arr === void 0 ? void 0 : arr.length) && (sub === null || sub === void 0 ? void 0 : sub.length)) {
        let j;
        outer_loop: for (let i = 0; i <= arr.length; i++) {
            let overlap = false;
            for (j = 0; j < sub.length; j++) {
                if (i + j < arr.length) {
                    if (arr[i + j] !== sub[j]) {
                        continue outer_loop;
                    }
                    overlap = true;
                }
                else if (overlap) {
                    return i;
                }
                else {
                    break outer_loop;
                }
            }
        }
    }
    return -1;
}
function hexStringToBytes(hexString) {
    const bytes = new Uint8Array(hexString.length / 2);
    for (let i = 0, j = 0; i < hexString.length; i += 2, j++) {
        bytes[j] = parseInt(hexString.substr(i, 2), 16);
    }
    return bytes;
}

class XRefEntry {
    constructor(type, id, generation, byteOffset, nextFreeId, streamId, streamIndex) {
        this.type = type;
        this.id = id;
        this.generation = generation;
        this.byteOffset = byteOffset;
        this.nextFreeId = nextFreeId;
        this.streamId = streamId;
        this.streamIndex = streamIndex;
    }
    static *fromTableBytes(bytes) {
        let i = 0;
        let j = 0;
        while (i < bytes.length) {
            const firstIndexBytes = [];
            let firstIndexDigit = bytes[i++];
            while (DIGIT_CHARS.has(firstIndexDigit)) {
                firstIndexBytes.push(firstIndexDigit);
                firstIndexDigit = bytes[i++];
            }
            let firstIndex = parseInt(firstIndexBytes.map(x => String.fromCharCode(x)).join(""), 10);
            const countBytes = [];
            let countDigit = bytes[i++];
            while (DIGIT_CHARS.has(countDigit)) {
                countBytes.push(countDigit);
                countDigit = bytes[i++];
            }
            const count = parseInt(countBytes.map(x => String.fromCharCode(x)).join(""), 10);
            while (!DIGIT_CHARS.has(bytes[i])) {
                i++;
            }
            for (j = 0; j < count; j++) {
                const value = parseInt(Array.from(bytes.subarray(i, i + 10))
                    .map(x => String.fromCharCode(x)).join(""), 10);
                i += 11;
                const gen = parseInt(Array.from(bytes.subarray(i, i + 5))
                    .map(x => String.fromCharCode(x)).join(""), 10);
                i += 6;
                const typeByte = bytes[i];
                if (typeByte === codes.f) {
                    yield new XRefEntry(xRefEntryTypes.FREE, firstIndex++, gen, null, value);
                }
                else if (typeByte === codes.n) {
                    yield new XRefEntry(xRefEntryTypes.NORMAL, firstIndex++, gen, value);
                }
                i += 3;
            }
        }
        return;
    }
    static *fromStreamBytes(bytes, w, index) {
        const [w1, w2, w3] = w;
        const entryLength = w1 + w2 + w3;
        if (bytes.length % entryLength) {
            throw new Error("Incorrect stream length");
        }
        const count = bytes.length / entryLength;
        const ids = new Array(count);
        if (index === null || index === void 0 ? void 0 : index.length) {
            let id;
            let n;
            let m = 0;
            for (let k = 0; k < index.length; k++) {
                if (!(k % 2)) {
                    id = index[k];
                }
                else {
                    for (n = 0; n < index[k]; n++) {
                        ids[m++] = id + n;
                    }
                }
            }
        }
        else {
            let l = 0;
            while (l < count) {
                ids[l++] = l;
            }
        }
        let i = 0;
        let j = 0;
        let type;
        let value1;
        let value2;
        while (i < bytes.length) {
            type = w1
                ? parseIntFromBytes(bytes.slice(i, i + w1))
                : 1;
            i += w1;
            value1 = parseIntFromBytes(bytes.slice(i, i + w2));
            i += w2;
            value2 = w3
                ? parseIntFromBytes(bytes.slice(i, i + w3))
                : null;
            i += w3;
            switch (type) {
                case xRefEntryTypes.FREE:
                    yield new XRefEntry(xRefEntryTypes.FREE, ids[j++], value2 !== null && value2 !== void 0 ? value2 : maxGeneration, null, value1);
                    break;
                case xRefEntryTypes.NORMAL:
                    yield new XRefEntry(xRefEntryTypes.NORMAL, ids[j++], value2 !== null && value2 !== void 0 ? value2 : 0, value1);
                    break;
                case xRefEntryTypes.COMPRESSED:
                    yield new XRefEntry(xRefEntryTypes.COMPRESSED, ids[j++], 0, null, null, value1, value2);
                    break;
            }
        }
        return;
    }
    static toTableBytes(entries) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length)) {
            return null;
        }
        const encoder = new TextEncoder();
        const groups = this.groupEntries(entries);
        let bytes = new Uint8Array();
        let temp;
        let line;
        for (const group of groups) {
            line = `${group[0]} ${group[1].length}\r\n`;
            temp = new Uint8Array(bytes.length + line.length);
            temp.set(bytes);
            temp.set(encoder.encode(line), bytes.length);
            bytes = temp;
            for (const entry of group[1]) {
                switch (entry.type) {
                    case xRefEntryTypes.FREE:
                        line = `${entry.nextFreeId.toString().padStart(10, "0")} ${entry.generation.toString().padStart(5, "0")} f\r\n`;
                        break;
                    case xRefEntryTypes.NORMAL:
                        line = `${entry.byteOffset.toString().padStart(10, "0")} ${entry.generation.toString().padStart(5, "0")} n\r\n`;
                        break;
                    default:
                        continue;
                }
                temp = new Uint8Array(bytes.length + line.length);
                temp.set(bytes);
                temp.set(encoder.encode(line), bytes.length);
                bytes = temp;
            }
        }
        return bytes;
    }
    static toStreamBytes(entries, w = [1, 4, 2]) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length)) {
            return null;
        }
        if (Math.min(...w) < 0) {
            throw new Error("Negative length values are not permitted");
        }
        let [w1, w2, w3] = w;
        w1 !== null && w1 !== void 0 ? w1 : (w1 = 0);
        w2 !== null && w2 !== void 0 ? w2 : (w2 = 4);
        w3 !== null && w3 !== void 0 ? w3 : (w3 = 0);
        const entryLength = w1 + w2 + w3;
        let w1ToBytesFunc;
        let w2ToBytesFunc;
        let w3ToBytesFunc;
        switch (w1) {
            case 0:
                w1ToBytesFunc = () => new Uint8Array();
                break;
            case 1:
                w1ToBytesFunc = int8ToBytes;
                break;
            case 2:
                w1ToBytesFunc = int16ToBytes;
                break;
            default:
                w2ToBytesFunc = (n) => new Uint8Array([...new Array(w1 - 2).fill(0), ...int16ToBytes(n)]);
                break;
        }
        switch (w2) {
            case 1:
                w2ToBytesFunc = int8ToBytes;
                break;
            case 2:
                w2ToBytesFunc = int16ToBytes;
                break;
            case 3:
                w2ToBytesFunc = (n) => new Uint8Array([0, ...int16ToBytes(n)]);
                break;
            case 4:
                w2ToBytesFunc = int32ToBytes;
                break;
            default:
                w2ToBytesFunc = (n) => new Uint8Array([...new Array(w1 - 4).fill(0), ...int32ToBytes(n)]);
                break;
        }
        switch (w3) {
            case 0:
                w3ToBytesFunc = () => new Uint8Array();
                break;
            case 1:
                w3ToBytesFunc = int8ToBytes;
                break;
            case 2:
                w3ToBytesFunc = int16ToBytes;
                break;
            default:
                w2ToBytesFunc = (n) => new Uint8Array([...new Array(w1 - 2).fill(0), ...int16ToBytes(n)]);
                break;
        }
        new TextEncoder();
        const groups = this.groupEntries(entries);
        const index = [];
        let bytes = new Uint8Array();
        let temp;
        let entryV1;
        let entryV2;
        let entryV3;
        for (const group of groups) {
            index.push(group[0], group[1].length);
            for (const entry of group[1]) {
                switch (entry.type) {
                    case xRefEntryTypes.FREE:
                        entryV1 = w1ToBytesFunc(0);
                        entryV2 = w2ToBytesFunc(entry.nextFreeId);
                        entryV3 = w3ToBytesFunc(entry.generation);
                        break;
                    case xRefEntryTypes.NORMAL:
                        entryV1 = w1ToBytesFunc(1);
                        entryV2 = w2ToBytesFunc(entry.byteOffset);
                        entryV3 = w3ToBytesFunc(entry.generation);
                        break;
                    case xRefEntryTypes.COMPRESSED:
                        entryV1 = w1ToBytesFunc(2);
                        entryV2 = w2ToBytesFunc(entry.streamId);
                        entryV3 = w3ToBytesFunc(entry.streamIndex);
                        break;
                    default:
                        continue;
                }
                temp = new Uint8Array(bytes.length + entryLength);
                temp.set(bytes);
                temp.set(entryV1, bytes.length);
                temp.set(entryV2, bytes.length + w1);
                temp.set(entryV3, bytes.length + w1 + w2);
                bytes = temp;
            }
        }
        return { bytes, index };
    }
    static groupEntries(entries) {
        entries.sort((a, b) => a.id - b.id);
        const groups = [];
        let groupStart;
        let groupEntries;
        let last;
        for (const entry of entries) {
            if (entry.id !== last + 1) {
                if (groupEntries === null || groupEntries === void 0 ? void 0 : groupEntries.length) {
                    groups.push([groupStart, groupEntries]);
                }
                groupStart = entry.id;
                groupEntries = [entry];
            }
            else {
                groupEntries.push(entry);
            }
            last = entry.id;
        }
        if (groupEntries === null || groupEntries === void 0 ? void 0 : groupEntries.length) {
            groups.push([groupStart, groupEntries]);
        }
        return groups;
    }
}

class ReferenceData {
    constructor(xrefs) {
        var _a;
        const allFreeEntries = [];
        const allNormalEntries = [];
        const allCompressedEntries = [];
        let maxId = 0;
        xrefs.forEach(x => {
            for (const entry of x.getEntries()) {
                switch (entry.type) {
                    case xRefEntryTypes.FREE:
                        allFreeEntries.push(entry);
                        break;
                    case xRefEntryTypes.NORMAL:
                        allNormalEntries.push(entry);
                        break;
                    case xRefEntryTypes.COMPRESSED:
                        allCompressedEntries.push(entry);
                        break;
                    default:
                        continue;
                }
                if (entry.id > maxId) {
                    maxId = entry.id;
                }
            }
        });
        this.size = maxId + 1;
        const zeroFreeRef = {
            id: 0,
            generation: maxGeneration,
            nextFreeId: 0,
        };
        const freeLinkedList = new LinkedList(zeroFreeRef);
        const freeOutsideListMap = new Map();
        const freeMap = new Map();
        let zeroFound = false;
        for (const entry of allFreeEntries) {
            if (!zeroFound && entry.id === 0) {
                zeroFound = true;
                zeroFreeRef.nextFreeId = entry.nextFreeId;
                continue;
            }
            const valueFromMap = freeMap.get(entry.id);
            if (!valueFromMap || valueFromMap.generation < entry.generation) {
                freeMap.set(entry.id, {
                    id: entry.id,
                    generation: entry.generation,
                    nextFreeId: entry.nextFreeId
                });
            }
        }
        let nextId = zeroFreeRef.nextFreeId;
        let next;
        while (nextId) {
            next = freeMap.get(nextId);
            freeMap.delete(nextId);
            freeLinkedList.push(next);
            nextId = next.nextFreeId;
        }
        [...freeMap].forEach(x => {
            const value = x[1];
            if (value.generation === maxGeneration && value.nextFreeId === 0) {
                freeOutsideListMap.set(value.id, value);
            }
        });
        this.freeLinkedList = freeLinkedList;
        this.freeOutsideListMap = freeOutsideListMap;
        const normalRefs = new Map();
        for (const entry of allNormalEntries) {
            if (this.isFreed(entry)) {
                continue;
            }
            const valueFromMap = normalRefs.get(entry.id);
            if (valueFromMap && valueFromMap.generation >= entry.generation) {
                continue;
            }
            normalRefs.set(entry.id, {
                id: entry.id,
                generation: entry.generation,
                byteOffset: entry.byteOffset,
            });
        }
        for (const entry of allCompressedEntries) {
            if (this.isFreed(entry)) {
                continue;
            }
            const valueFromMap = normalRefs.get(entry.id);
            if (valueFromMap) {
                continue;
            }
            const offset = (_a = normalRefs.get(entry.streamId)) === null || _a === void 0 ? void 0 : _a.byteOffset;
            if (offset) {
                normalRefs.set(entry.id, {
                    id: entry.id,
                    generation: entry.generation,
                    byteOffset: offset,
                    compressed: true,
                    streamId: entry.streamId,
                    streamIndex: entry.streamIndex,
                });
            }
        }
        this.usedMap = normalRefs;
    }
    getOffset(id) {
        var _a;
        return (_a = this.usedMap.get(id)) === null || _a === void 0 ? void 0 : _a.byteOffset;
    }
    getGeneration(id) {
        var _a;
        return (_a = this.usedMap.get(id)) === null || _a === void 0 ? void 0 : _a.generation;
    }
    isFreed(ref) {
        return this.freeOutsideListMap.has(ref.id)
            || this.freeLinkedList.has(ref, (a, b) => a.id === b.id && a.generation < b.generation);
    }
    isUsed(id) {
        return this.usedMap.has(id);
    }
}
class ReferenceDataChange {
    constructor(refData) {
        this._refData = refData;
        this._size = refData.size;
        const freeLinkedList = new LinkedList();
        for (const freeRef of refData.freeLinkedList) {
            freeLinkedList.push(Object.assign({}, freeRef));
        }
        this._freeLinkedList = freeLinkedList;
        this._usedMap = new Map();
    }
    get size() {
        return this._size;
    }
    takeFreeRef(byteOffset, forceNew = false) {
        let ref;
        if (!forceNew && this._freeLinkedList.length > 1) {
            const freeRef = this._freeLinkedList.pop();
            this._freeLinkedList.tail.nextFreeId = 0;
            ref = {
                id: freeRef.id,
                generation: freeRef.generation,
                byteOffset,
            };
        }
        else {
            ref = {
                id: this._size++,
                generation: 0,
                byteOffset,
            };
        }
        this._usedMap.set(ref.id, ref);
        return ref;
    }
    setRefFree(id) {
        if (this._usedMap.has(id)) {
            this._usedMap.delete(id);
            if (this._size > this._refData.size && this._size === id + 1) {
                this._size--;
            }
        }
        if (this._refData.isUsed(id)) {
            const gen = this._refData.getGeneration(id);
            const ref = { id: id, generation: gen + 1, nextFreeId: 0 };
            const index = this._freeLinkedList.findIndex(ref, (a, b) => a.id === b.id && a.generation <= b.generation);
            if (index !== -1) {
                return;
            }
            const lastFreeRef = this._freeLinkedList.tail;
            lastFreeRef.nextFreeId = id;
            this._freeLinkedList.push(ref);
        }
    }
    updateUsedRef(ref) {
        if (ref.compressed && ref.generation) {
            throw new Error(`Compressed ref generation can't be greater than zero: '${ref.id} ${ref.generation} R'`);
        }
        if (this.isFreed(ref)) {
            throw new Error(`The reference is freed: '${ref.id} ${ref.generation} R'`);
        }
        const current = this._usedMap.get(ref.id);
        if (current) {
            throw new Error(`Same reference has been issued twice: '${current.id} ${current.generation} R'`);
        }
        if (this._refData.isUsed(ref.id)) {
            const gen = this._refData.getGeneration(ref.id);
            if (ref.generation >= gen) {
                this._usedMap.set(ref.id, ref);
                return true;
            }
            throw new Error(`The reference has an old generation: '${current.id} ${current.generation} R'`);
        }
        throw new Error(`The reference is not used: '${current.id} ${current.generation} R'`);
    }
    exportEntries() {
        const entries = [];
        for (const entry of this._freeLinkedList) {
            entries.push(new XRefEntry(xRefEntryTypes.FREE, entry.id, entry.generation, null, entry.nextFreeId));
        }
        this._usedMap.forEach(v => {
            if (v.compressed) {
                entries.push(new XRefEntry(xRefEntryTypes.COMPRESSED, v.id, 0, null, null, v.streamId, v.streamIndex));
            }
            else {
                entries.push(new XRefEntry(xRefEntryTypes.NORMAL, v.id, v.generation, v.byteOffset));
            }
        });
        return entries;
    }
    isFreed(ref) {
        return this._freeLinkedList.has(ref, (a, b) => a.id === b.id && a.generation < b.generation);
    }
    isUsedInSource(id) {
        return this._refData.isUsed(id);
    }
}

class DataWriter {
    constructor(data) {
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new Error("Data is empty");
        }
        this._data = [...data];
        this._pointer = data.length;
        this._encoder = new TextEncoder();
        this.fixEof();
    }
    get offset() {
        return this._pointer;
    }
    getCurrentData() {
        return new Uint8Array(this._data);
    }
    writeBytes(bytes) {
        if (!(bytes === null || bytes === void 0 ? void 0 : bytes.length)) {
            return;
        }
        this._data.push(...bytes);
        this._pointer += bytes.length;
    }
    writeIndirectObject(cryptInfo, obj) {
        if (!(cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) || !obj) {
            return;
        }
        const objBytes = [
            ...this._encoder.encode(`${cryptInfo.ref.id} ${cryptInfo.ref.generation} `),
            ...keywordCodes.OBJ, ...keywordCodes.END_OF_LINE,
            ...obj.toArray(cryptInfo), ...keywordCodes.END_OF_LINE,
            ...keywordCodes.OBJ_END, ...keywordCodes.END_OF_LINE,
        ];
        this.writeBytes(objBytes);
    }
    writeIndirectArray(cryptInfo, objs) {
        if (!(cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) || !objs) {
            return;
        }
        const objBytes = [
            ...this._encoder.encode(`${cryptInfo.ref.id} ${cryptInfo.ref.generation} `),
            ...keywordCodes.OBJ, ...keywordCodes.END_OF_LINE,
            codes.L_BRACKET,
        ];
        for (const obj of objs) {
            objBytes.push(codes.WHITESPACE, ...obj.toArray(cryptInfo));
        }
        objBytes.push(codes.R_BRACKET, ...keywordCodes.END_OF_LINE, ...keywordCodes.OBJ_END, ...keywordCodes.END_OF_LINE);
        this.writeBytes(objBytes);
    }
    writeEof(xrefOffset) {
        const eof = [
            ...keywordCodes.XREF_START, ...keywordCodes.END_OF_LINE,
            ...this._encoder.encode(xrefOffset + ""), ...keywordCodes.END_OF_LINE,
            ...keywordCodes.END_OF_FILE, ...keywordCodes.END_OF_LINE
        ];
        this.writeBytes(eof);
    }
    fixEof() {
        if (this._data[this._pointer - 1] !== codes.LINE_FEED) {
            if (this._data[this._pointer - 2] !== codes.CARRIAGE_RETURN) {
                this._data.push(codes.CARRIAGE_RETURN, codes.LINE_FEED);
                this._pointer += 2;
            }
            else {
                this._data.push(codes.LINE_FEED);
                this._pointer += 1;
            }
        }
    }
}

class ObjectId {
    constructor(id, generation) {
        this.id = id !== null && id !== void 0 ? id : 0;
        this.generation = generation !== null && generation !== void 0 ? generation : 0;
    }
    static parse(parser, start, skipEmpty = true) {
        if (skipEmpty) {
            start = parser.findRegularIndex("straight", start);
        }
        if (start < 0 || start > parser.maxIndex) {
            return null;
        }
        const id = parser.parseNumberAt(start, false, false);
        if (!id || isNaN(id.value)) {
            return null;
        }
        const generation = parser.parseNumberAt(id.end + 2, false, false);
        if (!generation || isNaN(generation.value)) {
            return null;
        }
        return {
            value: new ObjectId(id.value, generation.value),
            start,
            end: generation.end,
        };
    }
    static parseRef(parser, start, skipEmpty = true) {
        const id = ObjectId.parse(parser, start, skipEmpty);
        if (!id) {
            return null;
        }
        const rIndexSupposed = id.end + 2;
        const rIndex = parser.findSubarrayIndex([codes.R], { minIndex: rIndexSupposed, closedOnly: true });
        if (!rIndex || rIndex.start !== rIndexSupposed) {
            return null;
        }
        return {
            value: id.value,
            start: id.start,
            end: rIndex.end,
        };
    }
    static parseRefArray(parser, start, skipEmpty = true) {
        const arrayBounds = parser.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const ids = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = ObjectId.parseRef(parser, i, true);
            if (!current) {
                break;
            }
            ids.push(current.value);
            i = current.end + 1;
        }
        return { value: ids, start: arrayBounds.start, end: arrayBounds.end };
    }
    static fromRef(ref) {
        return new ObjectId(ref.id, ref.generation);
    }
    equals(other) {
        return this.id === other.id
            && this.generation === other.generation;
    }
    toArray(cryptInfo) {
        return new TextEncoder().encode(`${this.id} ${this.generation} R`);
    }
    toString() {
        return this.id + "|" + this.generation;
    }
}

class DateString {
    constructor(source, date) {
        this._source = source;
        this._date = new Date(date);
    }
    get source() {
        return this._source;
    }
    get date() {
        return new Date(this._date);
    }
    static parse(parser, start, cryptInfo = null, skipEmpty = true) {
        if (skipEmpty) {
            start = parser.skipEmpty(start);
        }
        if (parser.isOutside(start) || parser.getCharCode(start) !== codes.L_PARENTHESE) {
            return null;
        }
        const end = parser.findCharIndex(codes.R_PARENTHESE, "straight", start);
        if (end === -1) {
            return null;
        }
        let bytes = parser.subCharCodes(start + 1, end - 1);
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.decrypt(bytes, cryptInfo.ref);
        }
        try {
            const date = DateString.fromArray(bytes);
            return { value: date, start, end };
        }
        catch (_a) {
            return null;
        }
    }
    static fromDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        const hours = String(date.getHours()).padStart(2, "0");
        const minutes = String(date.getMinutes()).padStart(2, "0");
        const seconds = String(date.getSeconds()).padStart(2, "0");
        const source = `D:${year}${month}${day}${hours}${minutes}${seconds}`;
        return new DateString(source, date);
    }
    static fromString(source) {
        const result = /D:(?<Y>\d{4})(?<M>\d{2})(?<D>\d{2})(?<h>\d{2})(?<m>\d{2})(?<s>\d{2})/.exec(source);
        const date = new Date(+result.groups.Y, +result.groups.M - 1, +result.groups.D, +result.groups.h, +result.groups.m, +result.groups.s);
        return new DateString(source, date);
    }
    static fromArray(arr) {
        const source = new TextDecoder().decode(arr);
        return DateString.fromString(source);
    }
    toArray(cryptInfo) {
        let bytes = new TextEncoder().encode(this._source);
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.encrypt(bytes, cryptInfo.ref);
        }
        return new Uint8Array([
            ...keywordCodes.STR_LITERAL_START,
            ...bytes,
            ...keywordCodes.STR_LITERAL_END,
        ]);
    }
}

class LiteralString {
    constructor(literal, bytes) {
        this._literal = literal;
        this._bytes = bytes;
    }
    get literal() {
        return this._literal;
    }
    get bytes() {
        return this._bytes.slice();
    }
    static parse(parser, start, cryptInfo = null, skipEmpty = true) {
        const bounds = parser.getLiteralBounds(start, skipEmpty);
        if (!bounds) {
            return;
        }
        let bytes = LiteralString.unescape(parser.subCharCodes(bounds.start + 1, bounds.end - 1));
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.decrypt(bytes, cryptInfo.ref);
        }
        const result = LiteralString.fromBytes(bytes);
        return { value: result, start: bounds.start, end: bounds.end };
    }
    static fromBytes(bytes) {
        const decoder = bytes[0] === 254 && bytes[1] === 255
            ? new TextDecoder("utf-16be")
            : new TextDecoder();
        const literal = decoder.decode(bytes);
        return new LiteralString(literal, bytes);
    }
    static fromString(source) {
        const bytes = [];
        bytes.push(254, 255);
        for (let i = 0; i < source.length; i++) {
            const charCode = source.charCodeAt(i);
            bytes.push((charCode & 0xFF00) >>> 8);
            bytes.push(charCode & 0xFF);
        }
        return new LiteralString(source, new Uint8Array(bytes));
    }
    static escape(bytes) {
        const result = [];
        for (let i = 0; i < bytes.length; i++) {
            switch (bytes[i]) {
                case codes.LINE_FEED:
                    result.push(codes.BACKSLASH);
                    result.push(codes.n);
                    break;
                case codes.CARRIAGE_RETURN:
                    result.push(codes.BACKSLASH);
                    result.push(codes.r);
                    break;
                case codes.HORIZONTAL_TAB:
                    result.push(codes.BACKSLASH);
                    result.push(codes.t);
                    break;
                case codes.BACKSPACE:
                    result.push(codes.BACKSLASH);
                    result.push(codes.b);
                    break;
                case codes.FORM_FEED:
                    result.push(codes.BACKSLASH);
                    result.push(codes.f);
                    break;
                case codes.L_PARENTHESE:
                    result.push(codes.BACKSLASH);
                    result.push(codes.L_PARENTHESE);
                    break;
                case codes.R_PARENTHESE:
                    result.push(codes.BACKSLASH);
                    result.push(codes.R_PARENTHESE);
                    break;
                case codes.BACKSLASH:
                    result.push(codes.BACKSLASH);
                    result.push(codes.BACKSLASH);
                    break;
                default:
                    result.push(bytes[i]);
                    break;
            }
        }
        return new Uint8Array(result);
    }
    static unescape(bytes) {
        const result = [];
        let escaped = false;
        for (let i = 0; i < bytes.length; i++) {
            if (escaped) {
                switch (bytes[i]) {
                    case codes.n:
                        result.push(codes.LINE_FEED);
                        break;
                    case codes.r:
                        result.push(codes.CARRIAGE_RETURN);
                        break;
                    case codes.t:
                        result.push(codes.HORIZONTAL_TAB);
                        break;
                    case codes.b:
                        result.push(codes.BACKSPACE);
                        break;
                    case codes.f:
                        result.push(codes.FORM_FEED);
                        break;
                    case codes.L_PARENTHESE:
                        result.push(codes.L_PARENTHESE);
                        break;
                    case codes.R_PARENTHESE:
                        result.push(codes.R_PARENTHESE);
                        break;
                    case codes.BACKSLASH:
                        result.push(codes.BACKSLASH);
                        break;
                    default:
                        result.push(bytes[i]);
                        break;
                }
                escaped = false;
                continue;
            }
            if (bytes[i] === codes.BACKSLASH) {
                escaped = true;
                continue;
            }
            result.push(bytes[i]);
        }
        return new Uint8Array(result);
    }
    toArray(cryptInfo) {
        const bytes = (cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor
            ? cryptInfo.stringCryptor.encrypt(this._bytes, cryptInfo.ref)
            : this._bytes;
        return new Uint8Array([
            ...keywordCodes.STR_LITERAL_START,
            ...LiteralString.escape(bytes),
            ...keywordCodes.STR_LITERAL_END,
        ]);
    }
}

class PdfObject {
    constructor() {
        this._added = false;
        this._edited = false;
        this._deleted = false;
        this.onChange = {
            set: (target, prop, value) => {
                if (prop[0] !== "_" && prop[0] !== "$") {
                    this._edited || (this._edited = true);
                    if (this.$onEditedAction) {
                        this.$onEditedAction();
                    }
                }
                target[prop] = value;
                return true;
            },
        };
    }
    get sourceBytes() {
        var _a;
        return (_a = this._sourceBytes) === null || _a === void 0 ? void 0 : _a.slice();
    }
    get sourceChars() {
        return this._sourceBytes
            ? String.fromCharCode(...this._sourceBytes.slice(0, this._sourceBytes.length))
            : "";
    }
    get ref() {
        return this._ref;
    }
    set ref(ref) {
        this._ref = ref;
    }
    get id() {
        var _a;
        return (_a = this._ref) === null || _a === void 0 ? void 0 : _a.id;
    }
    get generation() {
        var _a;
        return (_a = this._ref) === null || _a === void 0 ? void 0 : _a.generation;
    }
    get added() {
        return this._added;
    }
    get edited() {
        return this._edited;
    }
    get deleted() {
        return this._deleted;
    }
    markAsDeleted(value = true) {
        this._deleted = value;
    }
    parseRefProp(propName, parser, index) {
        const parsed = ObjectId.parseRef(parser, index);
        return this.setParsedProp(propName, parsed);
    }
    parseRefArrayProp(propName, parser, index) {
        const parsed = ObjectId.parseRefArray(parser, index);
        return this.setParsedProp(propName, parsed);
    }
    parseBoolProp(propName, parser, index) {
        const parsed = parser.parseBoolAt(index);
        return this.setParsedProp(propName, parsed);
    }
    parseNameProp(propName, parser, index, includeSlash = true) {
        const parsed = parser.parseNameAt(index, includeSlash);
        return this.setParsedProp(propName, parsed);
    }
    parseNameArrayProp(propName, parser, index, includeSlash = true) {
        const parsed = parser.parseNameArrayAt(index, includeSlash);
        return this.setParsedProp(propName, parsed);
    }
    parseNumberProp(propName, parser, index, float = true) {
        const parsed = parser.parseNumberAt(index, float);
        return this.setParsedProp(propName, parsed);
    }
    parseNumberArrayProp(propName, parser, index, float = true) {
        const parsed = parser.parseNumberArrayAt(index, float);
        return this.setParsedProp(propName, parsed);
    }
    parseDateProp(propName, parser, index, cryptInfo) {
        const parsed = DateString.parse(parser, index, cryptInfo);
        return this.setParsedProp(propName, parsed);
    }
    parseLiteralProp(propName, parser, index, cryptInfo) {
        const parsed = LiteralString.parse(parser, index, cryptInfo);
        return this.setParsedProp(propName, parsed);
    }
    setParsedProp(propName, parsed) {
        if (!parsed) {
            throw new Error(`Can't parse ${propName} property value`);
        }
        this[propName.slice(1)] = parsed.value;
        return parsed.end + 1;
    }
}

class PdfDict extends PdfObject {
    constructor(type) {
        super();
        this.Type = type;
    }
    get streamId() {
        return this._streamId;
    }
    toArray(cryptInfo) {
        const encoder = new TextEncoder();
        const bytes = [...keywordCodes.DICT_START];
        if (this.Type) {
            bytes.push(...keywordCodes.TYPE, ...encoder.encode(this.Type));
        }
        bytes.push(...keywordCodes.DICT_END);
        return new Uint8Array(bytes);
    }
    parseProps(parseInfo) {
        var _a;
        if (!parseInfo) {
            throw new Error("Parse info is empty");
        }
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        this._ref = (_a = parseInfo.cryptInfo) === null || _a === void 0 ? void 0 : _a.ref;
        this._streamId = parseInfo.streamId;
        this._sourceBytes = parser.sliceCharCodes(start, end);
        let i = parser.skipToNextName(start, end - 1);
        if (i === -1) {
            throw new Error("Dict is empty (has no properties)");
        }
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Type":
                        const type = parser.parseNameAt(i);
                        if (type) {
                            if (this.Type && this.Type !== type.value) {
                                throw new Error(`Ivalid dict type: '${type.value}' instead of '${this.Type}'`);
                            }
                            return;
                        }
                        throw new Error("Can't parse /Type property value");
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class DecodeParamsDict extends PdfDict {
    constructor() {
        super(dictTypes.EMPTY);
        this._intPropMap = new Map();
        this._boolPropMap = new Map();
        this._namePropMap = new Map();
        this._refPropMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new DecodeParamsDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    static parseArray(parser, start, cryptInfo = null, skipEmpty = true) {
        const arrayBounds = parser.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const paramsDicts = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            const paramsBounds = parser.getDictBoundsAt(i);
            current = DecodeParamsDict.parse({ parser, bounds: paramsBounds, cryptInfo });
            if (!current) {
                break;
            }
            paramsDicts.push(current.value);
            i = current.end + 1;
        }
        return { value: paramsDicts, start: arrayBounds.start, end: arrayBounds.end };
    }
    getIntProp(name) {
        return this._intPropMap.get(name);
    }
    getBoolProp(name) {
        return this._boolPropMap.get(name);
    }
    getNameProp(name) {
        return this._namePropMap.get(name);
    }
    getRefProp(name) {
        return this._refPropMap.get(name);
    }
    setIntProp(name, value) {
        return this._intPropMap.set(name, value);
    }
    setBoolProp(name, value) {
        return this._boolPropMap.set(name, value);
    }
    setNameProp(name, value) {
        return this._namePropMap.set(name, value);
    }
    setRefProp(name, value) {
        return this._refPropMap.set(name, value);
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        this._intPropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...encoder.encode(" " + v)));
        this._boolPropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...encoder.encode(" " + v)));
        this._namePropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...encoder.encode(v)));
        this._refPropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...v.toArray(cryptInfo)));
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                const valueType = parser.getValueTypeAt(i);
                switch (valueType) {
                    case valueTypes.NUMBER:
                        const intValue = parser.parseNumberAt(i, false);
                        if (intValue) {
                            this._intPropMap.set(name, intValue.value);
                            i = intValue.end + 1;
                            continue;
                        }
                        break;
                    case valueTypes.BOOLEAN:
                        const boolValue = parser.parseBoolAt(i);
                        if (boolValue) {
                            this._boolPropMap.set(name, boolValue.value);
                            i = boolValue.end + 1;
                            continue;
                        }
                        break;
                    case valueTypes.NAME:
                        const nameValue = parser.parseNameAt(i);
                        if (nameValue) {
                            this._namePropMap.set(name, nameValue.value);
                            i = nameValue.end + 1;
                            continue;
                        }
                        break;
                    case valueTypes.REF:
                        const refValue = ObjectId.parseRef(parser, i);
                        if (refValue) {
                            this._refPropMap.set(name, refValue.value);
                            i = refValue.end + 1;
                            continue;
                        }
                        break;
                }
                i = parser.skipToNextName(i, end - 1);
            }
            else {
                break;
            }
        }
    }
}

class DecodedStream {
    constructor(encodedStream) {
        this._minBufferLength = 512;
        this._bufferLength = 0;
        this._current = 0;
        this._ended = false;
        this._sourceStream = encodedStream;
    }
    get length() {
        return this._buffer.length;
    }
    ensureBuffer(size) {
        const buffer = this._buffer;
        if (buffer && size <= buffer.byteLength) {
            return buffer;
        }
        let length = this._minBufferLength;
        while (length < size) {
            length *= 2;
        }
        const enlargedBuffer = new Uint8Array(length);
        if (buffer) {
            enlargedBuffer.set(buffer);
        }
        return (this._buffer = enlargedBuffer);
    }
    takeByte() {
        const current = this._current;
        while (this._bufferLength <= current) {
            if (this._ended) {
                return -1;
            }
            this._readBlock();
        }
        return this._buffer[this._current++];
    }
    takeBytes(length) {
        let end;
        const position = this._current;
        if (length) {
            this.ensureBuffer(position + length);
            end = position + length;
            while (!this._ended && this._bufferLength < end) {
                this._readBlock();
            }
            if (end > this._bufferLength) {
                end = this._bufferLength;
            }
        }
        else {
            while (!this._ended) {
                this._readBlock();
            }
            end = this._bufferLength;
        }
        this._current = end;
        const subarray = this._buffer.subarray(position, end);
        return subarray;
    }
    takeUint16() {
        const byte_0 = this.takeByte();
        const byte_1 = this.takeByte();
        if (byte_0 === -1 || byte_1 === -1) {
            return -1;
        }
        return (byte_0 << 8) + byte_1;
    }
    takeInt32() {
        const byte_0 = this.takeByte();
        const byte_1 = this.takeByte();
        const byte_2 = this.takeByte();
        const byte_3 = this.takeByte();
        return (byte_0 << 24) + (byte_1 << 16) + (byte_2 << 8) + byte_3;
    }
    peekByte() {
        const peekedByte = this.takeByte();
        if (peekedByte !== -1) {
            this._current--;
        }
        return peekedByte;
    }
    peekBytes(length) {
        const bytes = this.takeBytes(length);
        this._current -= bytes.length;
        return bytes;
    }
    skip(n) {
        this._current += n || 1;
    }
    reset() {
        this._current = 0;
    }
}

class FlateStream extends DecodedStream {
    constructor(encodedStream) {
        super(encodedStream);
        this._codeSize = 0;
        this._codeBuf = 0;
        const cmf = encodedStream.takeByte();
        const flg = encodedStream.takeByte();
        if (cmf === -1 || flg === -1) {
            throw new Error(`Invalid header in flate stream: ${cmf}, ${flg}`);
        }
        if ((cmf & 0x0f) !== 0x08) {
            throw new Error(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
        }
        if (((cmf << 8) + flg) % 31 !== 0) {
            throw new Error(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
        }
        if (flg & 0x20) {
            throw new Error(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
        }
        this._codeSize = 0;
        this._codeBuf = 0;
    }
    _readBlock() {
        let buffer;
        let len;
        const str = this._sourceStream;
        let header = this.getBits(3);
        if (header & 1) {
            this._ended = true;
        }
        header >>= 1;
        if (header === 0) {
            let b;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            let blockLen = b;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            blockLen |= b << 8;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            let check = b;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            check |= b << 8;
            if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
                throw new Error("Bad uncompressed block length in flate stream");
            }
            this._codeBuf = 0;
            this._codeSize = 0;
            const bufferLength = this._bufferLength, end = bufferLength + blockLen;
            buffer = this.ensureBuffer(end);
            this._bufferLength = end;
            if (blockLen === 0) {
                if (str.peekByte() === -1) {
                    this._ended = true;
                }
            }
            else {
                const block = str.takeBytes(blockLen);
                buffer.set(block, bufferLength);
                if (block.length < blockLen) {
                    this._ended = true;
                }
            }
            return;
        }
        let litCodeTable;
        let distCodeTable;
        if (header === 1) {
            litCodeTable = FlateStream.fixedLitCodeTab;
            distCodeTable = FlateStream.fixedDistCodeTab;
        }
        else if (header === 2) {
            const numLitCodes = this.getBits(5) + 257;
            const numDistCodes = this.getBits(5) + 1;
            const numCodeLenCodes = this.getBits(4) + 4;
            const codeLenCodeLengths = new Uint8Array(FlateStream.codeLenCodeMap.length);
            let i;
            for (i = 0; i < numCodeLenCodes; i++) {
                codeLenCodeLengths[FlateStream.codeLenCodeMap[i]] = this.getBits(3);
            }
            const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            len = 0;
            i = 0;
            const codes = numLitCodes + numDistCodes;
            const codeLengths = new Uint8Array(codes);
            let bitsLength;
            let bitsOffset;
            let what;
            while (i < codes) {
                const code = this.getCode(codeLenCodeTab);
                if (code === 16) {
                    bitsLength = 2;
                    bitsOffset = 3;
                    what = len;
                }
                else if (code === 17) {
                    bitsLength = 3;
                    bitsOffset = 3;
                    what = len = 0;
                }
                else if (code === 18) {
                    bitsLength = 7;
                    bitsOffset = 11;
                    what = len = 0;
                }
                else {
                    codeLengths[i++] = len = code;
                    continue;
                }
                let repeatLength = this.getBits(bitsLength) + bitsOffset;
                while (repeatLength-- > 0) {
                    codeLengths[i++] = what;
                }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
        }
        else {
            throw new Error("Unknown block type in flate stream");
        }
        buffer = this._buffer;
        let limit = buffer ? buffer.length : 0;
        let pos = this._bufferLength;
        while (true) {
            let code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
                if (pos + 1 >= limit) {
                    buffer = this.ensureBuffer(pos + 1);
                    limit = buffer.length;
                }
                buffer[pos++] = code1;
                continue;
            }
            if (code1 === 256) {
                this._bufferLength = pos;
                return;
            }
            code1 -= 257;
            code1 = FlateStream.lengthDecode[code1];
            let code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            len = (code1 & 0xffff) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = FlateStream.distDecode[code1];
            code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            const dist = (code1 & 0xffff) + code2;
            if (pos + len >= limit) {
                buffer = this.ensureBuffer(pos + len);
                limit = buffer.length;
            }
            for (let k = 0; k < len; ++k, ++pos) {
                buffer[pos] = buffer[pos - dist];
            }
        }
    }
    ;
    getBits(n) {
        const stream = this._sourceStream;
        let size = this._codeSize;
        let buf = this._codeBuf;
        let value;
        while (size < n) {
            if ((value = stream.takeByte()) === -1) {
                throw new Error("Bad encoding in flate stream");
            }
            buf |= value << size;
            size += 8;
        }
        value = buf & ((1 << n) - 1);
        this._codeBuf = buf >> n;
        this._codeSize = size -= n;
        return value;
    }
    ;
    getCode(table) {
        const stream = this._sourceStream;
        const [codes, maxLength] = table;
        let size = this._codeSize;
        let buf = this._codeBuf;
        let value;
        while (size < maxLength) {
            if ((value = stream.takeByte()) === -1) {
                break;
            }
            buf |= value << size;
            size += 8;
        }
        const code = codes[buf & ((1 << maxLength) - 1)];
        const codeLen = code >> 16;
        const codeVal = code & 0xffff;
        if (codeLen < 1 || size < codeLen) {
            throw new Error("Bad encoding in flate stream");
        }
        this._codeBuf = buf >> codeLen;
        this._codeSize = size - codeLen;
        return codeVal;
    }
    ;
    generateHuffmanTable(lengths) {
        const n = lengths.length;
        let maxLength = 0;
        let i;
        for (i = 0; i < n; i++) {
            if (lengths[i] > maxLength) {
                maxLength = lengths[i];
            }
        }
        const size = 1 << maxLength;
        const codes = new Int32Array(size);
        for (let length = 1, code = 0, skip = 2; length <= maxLength; length++, code <<= 1, skip <<= 1) {
            for (let value = 0; value < n; value++) {
                if (lengths[value] === length) {
                    let code2 = 0;
                    let t = code;
                    for (i = 0; i < length; i++) {
                        code2 = (code2 << 1) | (t & 1);
                        t >>= 1;
                    }
                    for (i = code2; i < size; i += skip) {
                        codes[i] = (length << 16) | value;
                    }
                    code++;
                }
            }
        }
        return [codes, maxLength];
    }
    ;
}
FlateStream.codeLenCodeMap = new Int32Array([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
]);
FlateStream.lengthDecode = new Int32Array([
    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
]);
FlateStream.distDecode = new Int32Array([
    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
]);
FlateStream.fixedLitCodeTab = [new Int32Array([
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
        0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
        0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
        0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
        0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
        0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
        0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
        0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
        0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
        0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
        0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
        0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
        0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
        0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
        0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
        0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
        0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
        0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
        0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
        0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
        0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
        0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
        0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
        0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
        0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
        0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
        0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
        0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
        0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
        0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
        0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
        0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
        0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
        0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
        0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
        0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
        0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
        0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
        0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
        0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
        0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
        0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
        0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
        0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
        0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
        0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
        0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
        0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
        0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
    ]), 9];
FlateStream.fixedDistCodeTab = [new Int32Array([
        0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
        0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
        0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
        0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
    ]), 5];

class Stream {
    constructor(bytes, start = 0, length) {
        if (length && length < 0) {
            throw new Error("Stream length can't be negative");
        }
        this._bytes = bytes instanceof Uint8Array
            ? bytes
            : new Uint8Array(bytes);
        this._start = start;
        this._current = start;
        this._end = start + length || bytes.length;
    }
    get length() {
        return this._end - this._start;
    }
    takeByte() {
        if (this._current >= this._end) {
            return -1;
        }
        return this._bytes[this._current++];
    }
    takeBytes(length) {
        const bytes = this._bytes;
        const position = this._current;
        const bytesEnd = this._end;
        if (!length) {
            const subarray = bytes.subarray(position, bytesEnd);
            return subarray;
        }
        else {
            let end = position + length;
            if (end > bytesEnd) {
                end = bytesEnd;
            }
            this._current = end;
            const subarray = bytes.subarray(position, end);
            return subarray;
        }
    }
    takeUint16() {
        const b0 = this.takeByte();
        const b1 = this.takeByte();
        if (b0 === -1 || b1 === -1) {
            return -1;
        }
        return (b0 << 8) + b1;
    }
    takeInt32() {
        const b0 = this.takeByte();
        const b1 = this.takeByte();
        const b2 = this.takeByte();
        const b3 = this.takeByte();
        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    }
    peekByte() {
        const peekedByte = this.takeByte();
        if (peekedByte !== -1) {
            this._current--;
        }
        return peekedByte;
    }
    peekBytes(length) {
        const bytes = this.takeBytes(length);
        this._current -= bytes.length;
        return bytes;
    }
    getByte(index) {
        return this._bytes[index];
    }
    getByteRange(start, end) {
        return this._bytes.subarray(Math.max(start, 0), Math.min(end, this._end));
    }
    skip(n) {
        this._current += n || 1;
    }
    reset() {
        this._current = this._start;
    }
}

class FlateDecoder {
    static Decode(input, predictor = flatePredictors.NONE, columns = 1, components = 1, bpc = 8) {
        const stream = new Stream(input, 0, input.length);
        const flate = new FlateStream(stream);
        const inflated = flate.takeBytes(null);
        switch (predictor) {
            case (flatePredictors.NONE):
                return inflated;
            case (flatePredictors.PNG_NONE):
            case (flatePredictors.PNG_SUB):
            case (flatePredictors.PNG_UP):
            case (flatePredictors.PNG_AVERAGE):
            case (flatePredictors.PNG_PAETH):
            case (flatePredictors.PNG_OPTIMUM):
                const unfiltered = FlateDecoder.removePngFilter(inflated, columns, components, bpc);
                return unfiltered;
            case (flatePredictors.TIFF):
                throw new Error("Unsupported filter predictor");
        }
    }
    static Encode(input, predictor = flatePredictors.PNG_UP, columns = 5, components = 1, bpc = 8) {
        let filtered;
        switch (predictor) {
            case (flatePredictors.NONE):
                filtered = input;
                break;
            case (flatePredictors.PNG_NONE):
            case (flatePredictors.PNG_SUB):
            case (flatePredictors.PNG_UP):
            case (flatePredictors.PNG_AVERAGE):
            case (flatePredictors.PNG_PAETH):
            case (flatePredictors.PNG_OPTIMUM):
                filtered = FlateDecoder.applyPngFilter(input, predictor, columns, components, bpc);
                break;
            case (flatePredictors.TIFF):
                throw new Error("Unsupported filter predictor");
        }
        const deflated = Pako.deflate(filtered);
        return deflated;
    }
    static removePngFilter(input, columns, components, bpc) {
        const interval = Math.ceil(components * bpc / 8);
        const lineLen = columns * interval;
        const lineLen_filtered = lineLen + 1;
        if (!!(input.length % lineLen_filtered)) {
            throw new Error("Data length doesn't match filter columns");
        }
        const output = new Uint8Array(input.length / lineLen_filtered * lineLen);
        const previous = new Array(lineLen).fill(0);
        const current = new Array(lineLen).fill(0);
        const getLeft = (j) => j - interval < 0
            ? 0
            : current[j - interval];
        const getAbove = (j) => previous[j];
        const getUpperLeft = (j) => j - interval < 0
            ? 0
            : previous[j - interval];
        let x = 0;
        let y = 0;
        let k = 0;
        let rowStart = 0;
        let filterType = 0;
        let result = 0;
        for (let i = 0; i < input.length; i++) {
            if (i % lineLen_filtered === 0) {
                filterType = input[i];
                x = 0;
                if (i) {
                    for (k = 0; k < lineLen; k++) {
                        previous[k] = output[rowStart + k];
                    }
                }
                rowStart = y;
            }
            else {
                current[x] = input[i];
                switch (filterType) {
                    case 0:
                        result = current[x];
                        break;
                    case 1:
                        result = (current[x] + getLeft(x)) % 256;
                        break;
                    case 2:
                        result = (current[x] + getAbove(x)) % 256;
                        break;
                    case 3:
                        result = (current[x] + Math.floor((getAbove(x) + getLeft(x)) / 2)) % 256;
                        break;
                    case 4:
                        result = (current[x] + this.paethPredictor(getLeft(x), getAbove(x), getUpperLeft(x))) % 256;
                        break;
                }
                output[y++] = result;
                x++;
            }
        }
        return output;
    }
    static applyPngFilter(input, predictor = 12, columns = 5, components = 1, bpc = 8) {
        let filterType;
        switch (predictor) {
            case flatePredictors.PNG_NONE:
                filterType = 0;
                break;
            case flatePredictors.PNG_SUB:
                filterType = 1;
                break;
            case flatePredictors.PNG_UP:
                filterType = 2;
                break;
            case flatePredictors.PNG_AVERAGE:
                filterType = 3;
                break;
            case flatePredictors.PNG_PAETH:
                filterType = 4;
                break;
            default:
                throw new Error("Invalid PNG filter type");
        }
        const interval = Math.ceil(components * bpc / 8);
        const lineLen = columns * interval;
        const lineLen_filtered = lineLen + 1;
        const lineCount = Math.ceil(input.length / lineLen);
        const lenFiltered = lineCount * lineLen_filtered;
        const output = new Uint8Array(lenFiltered);
        const previous = new Array(lineLen).fill(0);
        const current = new Array(lineLen).fill(0);
        const getLeft = (j) => j - interval < 0
            ? 0
            : current[j - interval];
        const getAbove = (j) => previous[j];
        const getUpperLeft = (j) => j - interval < 0
            ? 0
            : previous[j - interval];
        let x = 0;
        let y = 0;
        let k = 0;
        let rowStart = 0;
        let result = 0;
        for (let i = 0; i < lenFiltered; i++) {
            if (i % lineLen_filtered === 0) {
                x = 0;
                if (i) {
                    for (k = 0; k < lineLen; k++) {
                        previous[k] = input[rowStart + k];
                    }
                }
                rowStart = y;
                output[i] = filterType;
            }
            else {
                current[x] = input[y++] || 0;
                switch (filterType) {
                    case 0:
                        result = current[x];
                        break;
                    case 1:
                        result = (current[x] - getLeft(x)) % 256;
                        break;
                    case 2:
                        result = (current[x] - getAbove(x)) % 256;
                        break;
                    case 3:
                        result = (current[x] - Math.floor((getAbove(x) + getLeft(x)) / 2)) % 256;
                        break;
                    case 4:
                        result = (current[x] - this.paethPredictor(getLeft(x), getAbove(x), getUpperLeft(x))) % 256;
                        break;
                }
                output[i] = result;
                x++;
            }
        }
        return output;
    }
    static paethPredictor(a, b, c) {
        const p = a + b - c;
        const pa = Math.abs(p - a);
        const pb = Math.abs(p - b);
        const pc = Math.abs(p - c);
        if (pa <= pb && pa <= pc) {
            return a;
        }
        else if (pb <= pc) {
            return b;
        }
        else {
            return c;
        }
    }
}

class PdfStream extends PdfObject {
    constructor(type) {
        super();
        this.Type = type;
    }
    get streamData() {
        return this._streamData;
    }
    set streamData(data) {
        this.setStreamData(data);
        this._edited = true;
    }
    get decodedStreamData() {
        if (!this._decodedStreamData) {
            this.decodeStreamData();
        }
        return this._decodedStreamData;
    }
    get decodedStreamDataChars() {
        const decoder = new TextDecoder();
        return decoder.decode(this._decodedStreamData);
    }
    toArray(cryptInfo) {
        const streamData = (cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.streamCryptor
            ? cryptInfo.streamCryptor.encrypt(this.streamData, cryptInfo.ref)
            : this.streamData;
        const encoder = new TextEncoder();
        const bytes = [...keywordCodes.DICT_START];
        bytes.push(...encoder.encode("/Length "), ...encoder.encode(" " + streamData.length));
        if (this.Type) {
            bytes.push(...keywordCodes.TYPE, ...encoder.encode(this.Type));
        }
        if (this.Filter) {
            bytes.push(...encoder.encode("/Filter "), ...encoder.encode(this.Filter));
        }
        if (this.DecodeParms) {
            bytes.push(...encoder.encode("/DecodeParms "), ...this.DecodeParms.toArray(cryptInfo));
        }
        bytes.push(...keywordCodes.DICT_END, ...keywordCodes.END_OF_LINE, ...keywordCodes.STREAM_START, ...keywordCodes.END_OF_LINE, ...streamData, ...keywordCodes.END_OF_LINE, ...keywordCodes.STREAM_END);
        return new Uint8Array(bytes);
    }
    setTextStreamData(text) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        this.streamData = bytes;
    }
    parseProps(parseInfo) {
        var _a, _b;
        if (!parseInfo) {
            throw new Error("Parse info is empty");
        }
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        this._ref = (_a = parseInfo.cryptInfo) === null || _a === void 0 ? void 0 : _a.ref;
        this._sourceBytes = parser.sliceCharCodes(start, end);
        const streamEndIndex = parser.findSubarrayIndex(keywordCodes.STREAM_END, {
            direction: "reverse",
            minIndex: start,
            maxIndex: end,
            closedOnly: true
        });
        if (!streamEndIndex) {
            throw new Error("Object is not a stream");
        }
        const streamStartIndex = parser.findSubarrayIndex(keywordCodes.STREAM_START, {
            direction: "reverse",
            minIndex: start,
            maxIndex: streamEndIndex.start - 1,
            closedOnly: true
        });
        if (!streamStartIndex) {
            throw new Error("Stream start is out of the data bounds");
        }
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        if (i === -1) {
            throw new Error("Dict is empty (has no properties)");
        }
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Type":
                        const type = parser.parseNameAt(i);
                        if (type) {
                            if (this.Type && this.Type !== type.value) {
                                throw new Error(`Ivalid dict type: '${type.value}' instead of '${this.Type}'`);
                            }
                            i = type.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Type property value");
                        }
                        break;
                    case "/Length":
                    case "/DL":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Filter":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.NAME) {
                            const filter = parser.parseNameAt(i);
                            if (filter && supportedFilters.has(filter.value)) {
                                this.Filter = filter.value;
                                i = filter.end + 1;
                                break;
                            }
                            else {
                                throw new Error(`Unsupported /Filter property value: ${filter.value}`);
                            }
                        }
                        else if (entryType === valueTypes.ARRAY) {
                            const filterNames = parser.parseNameArrayAt(i);
                            if (filterNames) {
                                const filterArray = filterNames.value;
                                if (filterArray.length === 1 && supportedFilters.has(filterArray[0])) {
                                    this.Filter = filterArray[0];
                                    i = filterNames.end + 1;
                                    break;
                                }
                                else {
                                    throw new Error(`Unsupported /Filter property value: ${filterArray.toString()}`);
                                }
                            }
                        }
                        throw new Error(`Unsupported /Filter property value type: ${entryType}`);
                    case "/DecodeParms":
                        const paramsEntryType = parser.getValueTypeAt(i);
                        if (paramsEntryType === valueTypes.DICTIONARY) {
                            const decodeParamsBounds = parser.getDictBoundsAt(i);
                            if (decodeParamsBounds) {
                                const params = DecodeParamsDict.parse({ parser,
                                    bounds: decodeParamsBounds, cryptInfo: parseInfo.cryptInfo });
                                if (params) {
                                    this.DecodeParms = params.value;
                                    i = decodeParamsBounds.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /DecodeParms property value");
                        }
                        else if (paramsEntryType === valueTypes.ARRAY) {
                            const paramsDicts = DecodeParamsDict.parseArray(parser, i, parseInfo.cryptInfo);
                            if (paramsDicts) {
                                const paramsArray = paramsDicts.value;
                                if (paramsArray.length === 1) {
                                    this.DecodeParms = paramsArray[0];
                                    i = paramsDicts.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /DecodeParms property value");
                        }
                        throw new Error(`Unsupported /DecodeParms property value type: ${paramsEntryType}`);
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        const streamStart = parser.findNewLineIndex("straight", streamStartIndex.end + 1);
        const streamEnd = parser.findNewLineIndex("reverse", streamEndIndex.start - 1);
        const streamBytes = parser.sliceCharCodes(streamStart, streamEnd);
        const encodedData = ((_b = parseInfo.cryptInfo) === null || _b === void 0 ? void 0 : _b.ref) && parseInfo.cryptInfo.streamCryptor
            ? parseInfo.cryptInfo.streamCryptor.decrypt(streamBytes, parseInfo.cryptInfo.ref)
            : streamBytes;
        this._streamData = encodedData;
    }
    setStreamData(data) {
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new Error("Can't set emprty stream data");
        }
        let params;
        if (this.DecodeParms) {
            params = this.DecodeParms;
        }
        else {
            let columns;
            let i = 10;
            while (true) {
                if (data.length % i === 0) {
                    columns = i;
                    break;
                }
                i--;
            }
            params = new DecodeParamsDict();
            params.setIntProp("/Predictor", flatePredictors.PNG_UP);
            params.setIntProp("/Columns", columns);
            this.DecodeParms = params;
        }
        const encodedData = FlateDecoder.Encode(data, (params === null || params === void 0 ? void 0 : params.getIntProp("/Predictor")) || flatePredictors.NONE, (params === null || params === void 0 ? void 0 : params.getIntProp("/Columns")) || 1, (params === null || params === void 0 ? void 0 : params.getIntProp("/Colors")) || 1, (params === null || params === void 0 ? void 0 : params.getIntProp("/BitsPerComponent")) || 8);
        this._streamData = encodedData;
        this.Length = encodedData.length;
        this.DL = data.length;
        this._decodedStreamData = data;
    }
    decodeStreamData() {
        let decodedData;
        switch (this.Filter) {
            case streamFilters.FLATE:
                if (this.DecodeParms) {
                    const params = this.DecodeParms;
                    decodedData = FlateDecoder.Decode(this._streamData, params.getIntProp("/Predictor") || flatePredictors.NONE, params.getIntProp("/Columns") || 1, params.getIntProp("/Colors") || 1, params.getIntProp("/BitsPerComponent") || 8);
                }
                else {
                    decodedData = FlateDecoder.Decode(this._streamData);
                }
                break;
            default:
                decodedData = new Uint8Array(this._streamData);
                break;
        }
        this._decodedStreamData = decodedData;
    }
}

class TextStream extends PdfStream {
    constructor(type = null) {
        super(type);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TextStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getText() {
        return null;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        return superBytes;
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
    }
}

class HexString {
    constructor(literal, hex, bytes) {
        this._literal = literal;
        this._hex = hex;
        this._bytes = bytes;
    }
    get literal() {
        return this._literal;
    }
    get hex() {
        return this._hex.slice();
    }
    get bytes() {
        return this._bytes.slice();
    }
    static parse(parser, start, cryptInfo = null, skipEmpty = true) {
        const bounds = parser.getHexBounds(start, skipEmpty);
        if (!bounds) {
            return null;
        }
        let bytes = parser.sliceCharCodes(bounds.start + 1, bounds.end - 1);
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.decrypt(bytes, cryptInfo.ref);
        }
        const hex = HexString.fromBytes(bytes);
        return { value: hex, start: bounds.start, end: bounds.end };
    }
    static parseArray(parser, start, cryptInfo = null, skipEmpty = true) {
        const arrayBounds = parser.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const hexes = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = HexString.parse(parser, i, cryptInfo, skipEmpty);
            if (!current) {
                break;
            }
            hexes.push(current.value);
            i = current.end + 1;
        }
        return { value: hexes, start: arrayBounds.start, end: arrayBounds.end };
    }
    static fromBytes(bytes) {
        const literal = new TextDecoder().decode(bytes);
        const hex = hexStringToBytes(literal);
        return new HexString(literal, hex, bytes);
    }
    static fromHexBytes(hex) {
        let literal = "";
        hex.forEach(x => literal += x.toString(16).padStart(2, "0"));
        const bytes = new TextEncoder().encode(literal);
        return new HexString(literal, hex, bytes);
    }
    static fromString(literal) {
        const hex = hexStringToBytes(literal);
        const bytes = new TextEncoder().encode(literal);
        return new HexString(literal, hex, bytes);
    }
    ;
    toArray(cryptInfo) {
        return new Uint8Array([
            ...keywordCodes.STR_HEX_START,
            ...this._bytes,
            ...keywordCodes.STR_HEX_END,
        ]);
    }
}

class IndexedColorSpaceArray {
    constructor(baseColorSpace, highestValue, lookupArray) {
        switch (baseColorSpace) {
            case colorSpaces.GRAYSCALE:
                this.componentsNumber = 1;
                break;
            case colorSpaces.RGB:
                this.componentsNumber = 3;
                break;
            case colorSpaces.CMYK:
                this.componentsNumber = 4;
                break;
            default:
                throw new Error(`Unsupported base color space for indexed color space: ${baseColorSpace}`);
        }
        this.baseColorSpace = baseColorSpace;
        if (lookupArray.length !== this.componentsNumber * (highestValue + 1)) {
            throw new Error(`Invalid lookup array length: ${lookupArray.length}`);
        }
        this.highestValue = highestValue;
        this.lookupArray = lookupArray;
    }
    static parse(parseInfo, skipEmpty = true) {
        const { parser, bounds, cryptInfo } = parseInfo;
        let i;
        if (skipEmpty) {
            i = parser.findNonSpaceIndex("straight", bounds.start);
        }
        const start = i;
        if (i < 0 || i > parser.maxIndex
            || parser.getCharCode(i) !== codes.L_BRACKET) {
            console.log("Color space array start not found");
            return null;
        }
        i++;
        const type = parser.parseNameAt(i);
        if (!type || type.value !== "/Indexed") {
            console.log("Array is not representing an indexed color space");
            return null;
        }
        i = type.end + 1;
        const base = parser.parseNameAt(i);
        if (!base) {
            console.log("Can't parse base color space name of the indexed color space");
            return null;
        }
        i = base.end + 2;
        const highestValue = parser.parseNumberAt(i);
        if (!highestValue || isNaN(highestValue.value)) {
            console.log("Can't parse the highest value of the indexed color space");
            return null;
        }
        i = highestValue.end + 1;
        let lookupArray;
        const lookupEntryType = parser.getValueTypeAt(i);
        if (lookupEntryType === valueTypes.REF) {
            try {
                const lookupId = ObjectId.parseRef(parser, i);
                const lookupParseInfo = parseInfo.parseInfoGetter(lookupId.value.id);
                const lookupStream = TextStream.parse(lookupParseInfo);
                lookupArray = lookupStream.value.decodedStreamData;
                i = lookupId.end + 1;
            }
            catch (e) {
                throw new Error(`Can't parse indexed color array lookup ref: ${e.message}`);
            }
        }
        else if (lookupEntryType === valueTypes.STRING_HEX) {
            const lookupHex = HexString.parse(parser, i, cryptInfo);
            if (lookupHex) {
                lookupArray = lookupHex.value.hex;
                i = lookupHex.end + 1;
            }
            else {
                throw new Error("Can't parse indexed color array lookup hex string");
            }
        }
        try {
            const colorSpace = new IndexedColorSpaceArray(base.value, highestValue.value, lookupArray);
            return {
                value: colorSpace,
                start,
                end: i - 1,
            };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const encoder = new TextEncoder();
        const bytes = [];
        bytes.push(codes.L_BRACKET, ...encoder.encode("/Indexed "), ...encoder.encode(this.baseColorSpace + " "), ...encoder.encode(this.highestValue + " "), ...HexString.fromHexBytes(this.lookupArray).toArray(cryptInfo), codes.R_BRACKET);
        return new Uint8Array(bytes);
    }
    getColor(index) {
        switch (this.baseColorSpace) {
            case colorSpaces.GRAYSCALE:
                const gray = this.lookupArray[index];
                return [gray, gray, gray];
            case colorSpaces.RGB:
                return [
                    this.lookupArray[index * 3],
                    this.lookupArray[index * 3 + 1],
                    this.lookupArray[index * 3 + 2],
                ];
            case colorSpaces.CMYK:
                const c = this.lookupArray[index * 4] / 255;
                const m = this.lookupArray[index * 4 + 1] / 255;
                const y = this.lookupArray[index * 4 + 2] / 255;
                const k = this.lookupArray[index * 4 + 3] / 255;
                return [
                    255 * (1 - c) * (1 - k),
                    255 * (1 - m) * (1 - k),
                    255 * (1 - y) * (1 - k),
                ];
        }
    }
}

var __awaiter$9 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ImageStream extends PdfStream {
    constructor() {
        super(streamTypes.FORM_XOBJECT);
        this.Subtype = "/Image";
        this.ImageMask = false;
        this.Interpolate = false;
        this.SMaskInData = 0;
    }
    get sMask() {
        return this._sMask;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ImageStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        if (this.Width) {
            bytes.push(...encoder.encode("/Width "), ...encoder.encode(" " + this.Width));
        }
        if (this.Height) {
            bytes.push(...encoder.encode("/Width "), ...encoder.encode(" " + this.Height));
        }
        if (this.ColorSpace) {
            if (this._indexedColorSpace) {
                bytes.push(...encoder.encode("/ColorSpace "), ...this._indexedColorSpace.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/ColorSpace "), ...encoder.encode(this.ColorSpace));
            }
        }
        if (this.BitsPerComponent) {
            bytes.push(...encoder.encode("/BitsPerComponent "), ...encoder.encode(" " + this.BitsPerComponent));
        }
        bytes.push(...encoder.encode("/ImageMask "), ...encoder.encode(" " + !!this.ImageMask));
        if (this.Mask) {
            bytes.push(...encoder.encode("/Mask "), codes.L_BRACKET);
            this.Mask.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.Decode) {
            bytes.push(...encoder.encode("/Decode "), codes.L_BRACKET);
            this.Decode.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        bytes.push(...encoder.encode("/Interpolate "), ...encoder.encode(" " + !!this.Interpolate));
        if (this.SMask) {
            bytes.push(...encoder.encode("/SMask "), ...this.SMask.toArray(cryptInfo));
        }
        if (this.SMaskInData) {
            bytes.push(...encoder.encode("/SMaskInData "), ...encoder.encode(" " + this.SMaskInData));
        }
        if (this.Matte) {
            bytes.push(...encoder.encode("/Matte "), codes.L_BRACKET);
            this.Matte.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.Metadata) {
            bytes.push(...encoder.encode("/Metadata "), codes.WHITESPACE, ...this.Metadata.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    getImageUrlAsync() {
        return __awaiter$9(this, void 0, void 0, function* () {
            if (this._imageUrl) {
                URL.revokeObjectURL(this._imageUrl);
            }
            if (this.Filter === streamFilters.DCT
                || this.Filter === streamFilters.JBIG2
                || this.Filter === streamFilters.JPX) {
                const blob = new Blob([this.decodedStreamData], {
                    type: "application/octet-binary",
                });
                const imageUrl = URL.createObjectURL(blob);
                this._imageUrl = imageUrl;
                return imageUrl;
            }
            if (this.Filter === streamFilters.FLATE) {
                const length = this.Width * this.Height;
                let alpha;
                if (this.sMask) {
                    alpha = this.sMask.decodedStreamData;
                    if (alpha.length !== length) {
                        throw new Error(`Invalid alpha mask data length: ${alpha.length} (must be ${length})`);
                    }
                }
                else {
                    alpha = new Uint8Array(length).fill(255);
                }
                const data = new Uint8ClampedArray(length * 4);
                for (let i = 0; i < length; i++) {
                    const [r, g, b] = this.getColor(i);
                    data[i * 4] = r;
                    data[i * 4 + 1] = g;
                    data[i * 4 + 2] = b;
                    data[i * 4 + 3] = alpha[i];
                }
                const imageData = new ImageData(data, this.Width, this.Height);
                const urlPromise = new Promise((resolve, reject) => {
                    const canvas = document.createElement("canvas");
                    canvas.width = this.Width;
                    canvas.height = this.Height;
                    canvas.getContext("2d").putImageData(imageData, 0, 0);
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        resolve(url);
                    });
                });
                const imageUrl = yield urlPromise;
                this._imageUrl = imageUrl;
                return imageUrl;
            }
            throw new Error(`Unsupported image filter type: ${this.Filter}`);
        });
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    case "/Width":
                    case "/Height":
                    case "/BitsPerComponent":
                    case "/SMaskInData":
                    case "/StructParent":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Decode":
                        i = this.parseNumberArrayProp(name, parser, i, false);
                        break;
                    case "/Matte":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/Interpolate":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/SMask":
                    case "/Metadata":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/ColorSpace":
                        const colorSpaceEntryType = parser.getValueTypeAt(i);
                        if (colorSpaceEntryType === valueTypes.NAME) {
                            const colorSpaceName = parser.parseNameAt(i);
                            if (colorSpaceName) {
                                this.ColorSpace = colorSpaceName.value;
                                i = colorSpaceName.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /ColorSpace name");
                        }
                        else if (colorSpaceEntryType === valueTypes.ARRAY) {
                            const colorSpaceArrayBounds = parser.getArrayBoundsAt(i);
                            if (colorSpaceArrayBounds) {
                                const indexedColorSpace = IndexedColorSpaceArray.parse({
                                    parser,
                                    bounds: colorSpaceArrayBounds,
                                    cryptInfo: parseInfo.cryptInfo,
                                    parseInfoGetter: parseInfo.parseInfoGetter,
                                });
                                if (indexedColorSpace) {
                                    this.ColorSpace = colorSpaces.SPECIAL_INDEXED;
                                    this._indexedColorSpace = indexedColorSpace.value;
                                    i = colorSpaceArrayBounds.end + 1;
                                    break;
                                }
                                throw new Error("Can't parse /ColorSpace object:" +
                                    parser.sliceChars(colorSpaceArrayBounds.start, colorSpaceArrayBounds.end));
                            }
                            throw new Error("Can't parse /ColorSpace value array");
                        }
                        else if (colorSpaceEntryType === valueTypes.REF) {
                            const colorSpaceRef = ObjectId.parseRef(parser, i);
                            if (colorSpaceRef) {
                                const colorSpaceParseInfo = parseInfo.parseInfoGetter(colorSpaceRef.value.id);
                                if (colorSpaceParseInfo) {
                                    const indexedColorSpace = IndexedColorSpaceArray.parse(colorSpaceParseInfo);
                                    if (indexedColorSpace) {
                                        this.ColorSpace = colorSpaces.SPECIAL_INDEXED;
                                        this._indexedColorSpace = indexedColorSpace.value;
                                        i = colorSpaceRef.end + 1;
                                        break;
                                    }
                                    throw new Error("Can't parse /ColorSpace object:" +
                                        colorSpaceParseInfo.parser.sliceChars(colorSpaceParseInfo.bounds.start, colorSpaceParseInfo.bounds.end));
                                }
                            }
                            throw new Error("Can't parse /ColorSpace ref");
                        }
                        throw new Error(`Unsupported /ColorSpace property value type: ${colorSpaceEntryType}`);
                    case "/ImageMask":
                        const imageMask = parser.parseBoolAt(i, false);
                        if (imageMask) {
                            this.ImageMask = imageMask.value;
                            i = imageMask.end + 1;
                            if (this.ImageMask) {
                                this.BitsPerComponent = 1;
                            }
                        }
                        else {
                            throw new Error("Can't parse /ImageMask property value");
                        }
                        break;
                    case "/Mask":
                        const maskEntryType = parser.getValueTypeAt(i);
                        if (maskEntryType === valueTypes.REF) {
                            const maskStreamId = ObjectId.parseRef(parser, i);
                            if (!maskStreamId) {
                                throw new Error("Can't parse /Mask value reference: failed to parse ref");
                            }
                            const maskParseInfo = parseInfo.parseInfoGetter(maskStreamId.value.id);
                            if (!maskParseInfo) {
                                throw new Error("Can't parse /Mask value reference: failed to get image parse info");
                            }
                            const maskStream = ImageStream.parse(maskParseInfo);
                            if (!maskStream) {
                                throw new Error("Can't parse /Mask value reference: failed to parse image stream");
                            }
                            const maskStreamParser = new DataParser(new Uint8Array([
                                codes.L_BRACKET,
                                ...maskStream.value.decodedStreamData,
                                codes.R_BRACKET,
                            ]));
                            if (!maskStreamParser) {
                                throw new Error("Can't parse /Mask value reference: failed to get decoded image data");
                            }
                            const maskArray = maskStreamParser.parseNumberArrayAt(0, false);
                            if (!maskArray) {
                                throw new Error("Can't parse /Mask value reference: failed to parse decoded image data");
                            }
                            this.Mask = maskArray.value;
                            i = maskStreamId.end + 1;
                            break;
                        }
                        else if (maskEntryType === valueTypes.ARRAY) {
                            const maskArray = parser.parseNumberArrayAt(i, false);
                            if (maskArray) {
                                this.Mask = maskArray.value;
                                i = maskArray.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /Mask property value");
                        }
                        throw new Error(`Unsupported /Mask property value type: ${maskEntryType}`);
                    case "/OC":
                    case "/Intent":
                    case "/Alternates":
                    case "/ID":
                    case "/OPI":
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Width && !this.Height) {
            throw new Error("Not all required properties parsed");
        }
        if (this.ImageMask && (this.BitsPerComponent !== 1 || this.ColorSpace)) {
            throw new Error("Mutually exclusive properties found");
        }
        if (!this.Decode && !(this.Filter === streamFilters.JPX && !this.ImageMask)) {
            switch (this.ColorSpace) {
                case colorSpaces.GRAYSCALE:
                    this.Decode = [0, 1];
                    break;
                case colorSpaces.RGB:
                    this.Decode = [0, 1, 0, 1, 0, 1];
                    break;
                case colorSpaces.CMYK:
                    this.Decode = [0, 1, 0, 1, 0, 1, 0, 1];
                    break;
                case colorSpaces.SPECIAL_INDEXED:
                    this.Decode = [0, Math.pow(2, this.BitsPerComponent || 1) - 1];
                    break;
                default:
                    this.Decode = [0, 1];
                    break;
            }
        }
        if (!this.DecodeParms) {
            this.DecodeParms = new DecodeParamsDict();
        }
        if (!this.DecodeParms.getIntProp("/BitsPerComponent")) {
            this.DecodeParms.setIntProp("/BitsPerComponent", this.BitsPerComponent);
        }
        if (!this.DecodeParms.getIntProp("/Columns")) {
            this.DecodeParms.setIntProp("/Columns", this.Width);
        }
        if (!this.DecodeParms.getIntProp("/Colors")) {
            switch (this.ColorSpace) {
                case colorSpaces.GRAYSCALE:
                case colorSpaces.SPECIAL_INDEXED:
                    this.DecodeParms.setIntProp("/Colors", 1);
                    break;
                case colorSpaces.RGB:
                    this.DecodeParms.setIntProp("/Colors", 3);
                    break;
                case colorSpaces.CMYK:
                    this.DecodeParms.setIntProp("/Colors", 4);
                    break;
                default:
                    this.DecodeParms.setIntProp("/Colors", 1);
                    break;
            }
        }
        if (this.SMask) {
            const sMaskParseInfo = parseInfo.parseInfoGetter(this.SMask.id);
            if (!sMaskParseInfo) {
                throw new Error(`Can't get parse info for ref: ${this.SMask.id} ${this.sMask.generation} R`);
            }
            const sMask = ImageStream.parse(sMaskParseInfo);
            if (!sMask) {
                throw new Error(`Can't parse SMask: ${this.SMask.id} ${this.sMask.generation} R`);
            }
            this._sMask = sMask.value;
        }
    }
    getColor(index) {
        var _a;
        const data = this.decodedStreamData;
        switch (this.ColorSpace) {
            case colorSpaces.GRAYSCALE:
                const gray = data[index];
                return [gray, gray, gray];
            case colorSpaces.RGB:
                return [
                    data[index * 3],
                    data[index * 3 + 1],
                    data[index * 3 + 2],
                ];
            case colorSpaces.CMYK:
                const c = data[index * 4] / 255;
                const m = data[index * 4 + 1] / 255;
                const y = data[index * 4 + 2] / 255;
                const k = data[index * 4 + 3] / 255;
                return [
                    255 * (1 - c) * (1 - k),
                    255 * (1 - m) * (1 - k),
                    255 * (1 - y) * (1 - k),
                ];
            case colorSpaces.SPECIAL_INDEXED:
                return ((_a = this._indexedColorSpace) === null || _a === void 0 ? void 0 : _a.getColor(index)) || [0, 0, 0];
        }
    }
}

class ObjectMapDict extends PdfDict {
    constructor() {
        super(null);
        this._objectIdMap = new Map();
        this._dictParserMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ObjectMapDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getObjectId(name) {
        return this._objectIdMap.get(name);
    }
    *getObjectIds() {
        for (const pair of this._objectIdMap) {
            yield pair;
        }
        return;
    }
    getDictParser(name) {
        return this._dictParserMap.get(name);
    }
    *getDictParsers() {
        for (const pair of this._dictParserMap) {
            yield pair;
        }
        return;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        this._objectIdMap.forEach((v, k) => {
            bytes.push(...encoder.encode(k), codes.WHITESPACE, ...v.toArray(cryptInfo));
        });
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    default:
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.REF) {
                            const id = ObjectId.parseRef(parser, i);
                            if (id) {
                                this._objectIdMap.set(name, id.value);
                                i = id.end + 1;
                                break;
                            }
                        }
                        else if (entryType === valueTypes.DICTIONARY) {
                            const dictBounds = parser.getDictBoundsAt(i);
                            if (dictBounds) {
                                const dictParseInfo = {
                                    parser: new DataParser(parser.sliceCharCodes(dictBounds.start, dictBounds.end)),
                                    bounds: {
                                        start: 0,
                                        end: dictBounds.end - dictBounds.start,
                                        contentStart: dictBounds.contentStart - dictBounds.start,
                                        contentEnd: dictBounds.contentEnd - dictBounds.start,
                                    },
                                    cryptInfo: parseInfo.cryptInfo,
                                };
                                this._dictParserMap.set(name, dictParseInfo);
                                i = dictBounds.end + 1;
                                break;
                            }
                        }
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class FontDict extends PdfDict {
    constructor() {
        super(dictTypes.FONT);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new FontDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(" " + this.Subtype));
        }
        if (this.BaseFont) {
            bytes.push(...encoder.encode("/BaseFont "), ...encoder.encode(" " + this.BaseFont));
        }
        if (this.Encoding) {
            bytes.push(...encoder.encode("/Encoding "), ...encoder.encode(" " + this.Encoding));
        }
        if (this.ToUnicode) {
            bytes.push(...encoder.encode("/G "), codes.WHITESPACE, ...this.ToUnicode.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i, true);
                        if (subtype) {
                            if (subtype.value === "/Type1" || subtype.value === "/TrueType") {
                                this.Subtype = subtype.value;
                                i = subtype.end + 1;
                                break;
                            }
                            throw new Error(`Font type is not supported: ${subtype.value}`);
                        }
                        throw new Error("Can't parse /Subtype property value");
                    case "/BaseFont":
                    case "/Encoding":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/ToUnicode":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class SoftMaskDict extends PdfDict {
    constructor() {
        super(dictTypes.SOFT_MASK);
        this.TR = "/Identity";
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new SoftMaskDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        if (this.G) {
            bytes.push(...encoder.encode("/G "), codes.WHITESPACE, ...this.G.toArray(cryptInfo));
        }
        if (this.BC) {
            bytes.push(...encoder.encode("/BC "), codes.L_BRACKET);
            this.BC.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.TR) {
            bytes.push(...encoder.encode("/TR "), ...encoder.encode(" " + this.TR));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/S":
                        const softMaskType = parser.parseNameAt(i, true);
                        if (softMaskType && Object.values(softMaskTypes)
                            .includes(softMaskType.value)) {
                            this.S = softMaskType.value;
                            i = softMaskType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    case "/G":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/BC":
                        i = this.parseNumberArrayProp(name, parser, i);
                        break;
                    case "/TR":
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class GraphicsStateDict extends PdfDict {
    constructor() {
        super(dictTypes.GRAPHICS_STATE);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new GraphicsStateDict();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.LW) {
            bytes.push(...encoder.encode("/LW "), ...encoder.encode(" " + this.LW));
        }
        if (this.LC) {
            bytes.push(...encoder.encode("/LC "), ...encoder.encode(" " + this.LC));
        }
        if (this.LJ) {
            bytes.push(...encoder.encode("/LJ "), ...encoder.encode(" " + this.LJ));
        }
        if (this.ML) {
            bytes.push(...encoder.encode("/ML "), ...encoder.encode(" " + this.ML));
        }
        if (this.D) {
            bytes.push(...encoder.encode("/D "), codes.L_BRACKET, codes.L_BRACKET, ...encoder.encode("" + this.D[0][0]), ...encoder.encode(" " + this.D[0][1]), codes.R_BRACKET, ...encoder.encode(" " + this.D[1]), codes.R_BRACKET);
        }
        if (this.RI) {
            bytes.push(...encoder.encode("/RI "), ...encoder.encode(this.RI));
        }
        if (this.OP) {
            bytes.push(...encoder.encode("/OP "), ...encoder.encode(" " + this.OP));
        }
        if (this.op) {
            bytes.push(...encoder.encode("/op "), ...encoder.encode(" " + this.op));
        }
        if (this.OPM) {
            bytes.push(...encoder.encode("/OPM "), ...encoder.encode(" " + this.OPM));
        }
        if (this.Font) {
            bytes.push(...encoder.encode("/Font "), codes.L_BRACKET, ...this.Font[0].toArray(cryptInfo), ...encoder.encode(" " + this.Font[1]), codes.R_BRACKET);
        }
        if (this.FL) {
            bytes.push(...encoder.encode("/FL "), ...encoder.encode(" " + this.FL));
        }
        if (this.SM) {
            bytes.push(...encoder.encode("/SM "), ...encoder.encode(" " + this.SM));
        }
        if (this.SA) {
            bytes.push(...encoder.encode("/SA "), ...encoder.encode(" " + this.SA));
        }
        if (this.BM) {
            bytes.push(...encoder.encode("/BM "), ...encoder.encode(this.BM));
        }
        if (this.SMask) {
            if (this.SMask instanceof SoftMaskDict) {
                bytes.push(...encoder.encode("/SMask "), ...this.SMask.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/SMask "), ...encoder.encode(this.SMask));
            }
        }
        if (this.CA) {
            bytes.push(...encoder.encode("/CA "), ...encoder.encode(" " + this.CA));
        }
        if (this.ca) {
            bytes.push(...encoder.encode("/ca "), ...encoder.encode(" " + this.ca));
        }
        if (this.AIS) {
            bytes.push(...encoder.encode("/AIS "), ...encoder.encode(" " + this.AIS));
        }
        if (this.TK) {
            bytes.push(...encoder.encode("/TK "), ...encoder.encode(" " + this.TK));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toParams() {
        const params = {};
        if (!isNaN(this.LW)) {
            params.strokeWidth = this.LW;
        }
        if (!isNaN(this.LC)) {
            switch (this.LC) {
                case lineCapStyles.BUTT:
                    params.strokeLineCap = "butt";
                    break;
                case lineCapStyles.ROUND:
                    params.strokeLineCap = "round";
                    break;
                case lineCapStyles.SQUARE:
                    params.strokeLineCap = "square";
                    break;
            }
        }
        if (!isNaN(this.LJ)) {
            switch (this.LJ) {
                case lineJoinStyles.BEVEL:
                    params.strokeLineJoin = "bevel";
                    break;
                case lineJoinStyles.ROUND:
                    params.strokeLineJoin = "round";
                    break;
                case lineJoinStyles.MITER:
                    params.strokeLineJoin = "miter";
                    break;
            }
        }
        if (this.ML) {
            params.strokeMiterLimit = this.ML;
        }
        if (this.D) {
            params.strokeDashArray = `${this.D[0][0]} ${this.D[0][1]}`;
            params.strokeDashOffset = this.D[1];
        }
        if (this.Font) ;
        if (this.BM) {
            switch (this.BM) {
                case "/Normal":
                    params.mixBlendMode = "normal";
                    break;
                case "/Multiply":
                    params.mixBlendMode = "multiply";
                    break;
                case "/Screen":
                    params.mixBlendMode = "screen";
                    break;
                case "/Overlay":
                    params.mixBlendMode = "overlay";
                    break;
                case "/Darken":
                    params.mixBlendMode = "darken";
                    break;
                case "/Lighten":
                    params.mixBlendMode = "lighten";
                    break;
                case "/ColorDodge":
                    params.mixBlendMode = "color-dodge";
                    break;
                case "/ColorBurn":
                    params.mixBlendMode = "color-burn";
                    break;
                case "/HardLight":
                    params.mixBlendMode = "hard-light";
                    break;
                case "/SoftLight":
                    params.mixBlendMode = "soft-light";
                    break;
                case "/Difference":
                    params.mixBlendMode = "difference";
                    break;
                case "/Exclusion":
                    params.mixBlendMode = "exclusion";
                    break;
                default:
                    throw new Error(`Unsupported blend mode: ${this.BM}`);
            }
        }
        if (this.SMask) ;
        if (this.CA) {
            params.strokeAlpha = this.CA;
        }
        if (this.ca) {
            params.fillAlpha = this.ca;
        }
        if (this.AIS) ;
        return params;
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/LC":
                        const lineCap = parser.parseNumberAt(i, true);
                        if (lineCap && Object.values(lineCapStyles)
                            .includes(lineCap.value)) {
                            this.LC = lineCap.value;
                            i = lineCap.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /LC property value");
                        }
                        break;
                    case "/OPM":
                        const overprintMode = parser.parseNumberAt(i, true);
                        if (overprintMode && ([0, 1].includes(overprintMode.value))) {
                            this.OPM = overprintMode.value;
                            i = overprintMode.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /OPM property value");
                        }
                        break;
                    case "/LJ":
                        const lineJoin = parser.parseNumberAt(i, true);
                        if (lineJoin && Object.values(lineJoinStyles)
                            .includes(lineJoin.value)) {
                            this.LJ = lineJoin.value;
                            i = lineJoin.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /LJ property value");
                        }
                        break;
                    case "/RI":
                        const intent = parser.parseNameAt(i, true);
                        if (intent && Object.values(renderingIntents)
                            .includes(intent.value)) {
                            this.RI = intent.value;
                            i = intent.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /RI property value");
                        }
                        break;
                    case "/BM":
                        const blendMode = parser.parseNameAt(i, true);
                        if (blendMode && Object.values(blendModes)
                            .includes(blendMode.value)) {
                            this.BM = blendMode.value;
                            i = blendMode.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /BM property value");
                        }
                        break;
                    case "/SMask":
                        const sMaskEntryType = parser.getValueTypeAt(i);
                        if (sMaskEntryType === valueTypes.NAME) {
                            const sMaskName = parser.parseNameAt(i);
                            if (sMaskName) {
                                this.SMask = sMaskName.value;
                                i = sMaskName.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /SMask property name");
                        }
                        else if (sMaskEntryType === valueTypes.DICTIONARY) {
                            const sMaskDictBounds = parser.getDictBoundsAt(i);
                            if (sMaskDictBounds) {
                                const sMaskDict = SoftMaskDict.parse({ parser, bounds: sMaskDictBounds });
                                if (sMaskDict) {
                                    this.SMask = sMaskDict.value;
                                    i = sMaskDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /SMask value dictionary");
                        }
                        throw new Error(`Unsupported /SMask property value type: ${sMaskEntryType}`);
                    case "/Font":
                        const fontEntryType = parser.getValueTypeAt(i);
                        if (fontEntryType === valueTypes.ARRAY) {
                            const fontArrayBounds = parser.getArrayBoundsAt(i);
                            if (fontArrayBounds) {
                                const fontRef = ObjectId.parse(parser, fontArrayBounds.start + 1);
                                if (fontRef) {
                                    const fontSize = parser.parseNumberAt(fontRef.end + 1);
                                    if (fontSize) {
                                        this.Font = [fontRef.value, fontSize.value];
                                        i = fontArrayBounds.end + 1;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /Font property value type: ${fontEntryType}`);
                        }
                        throw new Error("Can't parse /Font property value");
                    case "/D":
                        const dashEntryType = parser.getValueTypeAt(i);
                        if (dashEntryType === valueTypes.ARRAY) {
                            const dashArrayBounds = parser.getArrayBoundsAt(i);
                            if (dashArrayBounds) {
                                const dashArray = parser.parseNumberArrayAt(dashArrayBounds.start + 1);
                                if (dashArray) {
                                    const dashPhase = parser.parseNumberAt(dashArray.end + 1);
                                    if (dashPhase) {
                                        this.D = [[dashArray.value[0], dashArray.value[1]], dashPhase.value];
                                        i = dashArrayBounds.end + 1;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /D property value type: ${dashEntryType}`);
                        }
                        throw new Error("Can't parse /D property value");
                    case "/OP":
                    case "/op":
                    case "/SA":
                    case "/AIS":
                    case "/TK":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/LW":
                    case "/ML":
                    case "/FL":
                    case "/SM":
                    case "/CA":
                    case "/ca":
                        i = this.parseNumberProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class ResourceDict extends PdfDict {
    constructor(streamParsers) {
        super(null);
        this._gsMap = new Map();
        this._fontsMap = new Map();
        this._xObjectsMap = new Map();
        this._streamParsers = streamParsers;
    }
    static parse(parseInfo, streamParsers) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ResourceDict(streamParsers);
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this._gsMap.size) {
            bytes.push(...encoder.encode("/ExtGState "));
            bytes.push(...keywordCodes.DICT_START);
            for (const [name, gsDict] of this._gsMap) {
                bytes.push(...encoder.encode(name.slice(10)), codes.WHITESPACE);
                if (gsDict.ref) {
                    bytes.push(...ObjectId.fromRef(gsDict.ref).toArray(cryptInfo));
                }
                else {
                    bytes.push(...gsDict.toArray(cryptInfo));
                }
            }
            bytes.push(...keywordCodes.DICT_END);
        }
        if (this._xObjectsMap.size) {
            bytes.push(...encoder.encode("/XObject "), ...keywordCodes.DICT_START);
            for (const [name, xObject] of this._xObjectsMap) {
                const ref = xObject.ref;
                if (!ref) {
                    throw new Error("XObject has no reference");
                }
                bytes.push(...encoder.encode(name.slice(8)), codes.WHITESPACE);
                bytes.push(...ObjectId.fromRef(ref).toArray(cryptInfo));
            }
            bytes.push(...keywordCodes.DICT_END);
        }
        if (this.ColorSpace) {
            bytes.push(...encoder.encode("/ColorSpace "), ...this.ColorSpace.toArray(cryptInfo));
        }
        if (this.Pattern) {
            bytes.push(...encoder.encode("/Pattern "), ...this.Pattern.toArray(cryptInfo));
        }
        if (this.Shading) {
            bytes.push(...encoder.encode("/Shading "), ...this.Shading.toArray(cryptInfo));
        }
        if (this.Font) {
            bytes.push(...encoder.encode("/Font "), ...this.Font.toArray(cryptInfo));
        }
        if (this.Properties) {
            bytes.push(...encoder.encode("/Properties "), ...this.Properties.toArray(cryptInfo));
        }
        if (this.ProcSet) {
            bytes.push(...encoder.encode("/ProcSet "), codes.L_BRACKET);
            this.ProcSet.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(x)));
            bytes.push(codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    getGraphicsState(name) {
        return this._gsMap.get(name);
    }
    *getGraphicsStates() {
        for (const pair of this._gsMap) {
            yield pair;
        }
        return;
    }
    setGraphicsState(name, state) {
        this._gsMap.set(`/ExtGState${name}`, state);
        this._edited = true;
    }
    getFont(name) {
        return this._fontsMap.get(name);
    }
    *getFonts() {
        for (const pair of this._fontsMap) {
            yield pair;
        }
        return;
    }
    getXObject(name) {
        return this._xObjectsMap.get(name);
    }
    *getXObjects() {
        for (const pair of this._xObjectsMap) {
            yield pair;
        }
        return;
    }
    setXObject(name, xObject) {
        this._xObjectsMap.set(`/XObject${name}`, xObject);
        this._edited = true;
    }
    fillMaps(parseInfoGetter, cryptInfo) {
        this._gsMap.clear();
        this._fontsMap.clear();
        this._xObjectsMap.clear();
        if (this.ExtGState) {
            for (const [name, objectId] of this.ExtGState.getObjectIds()) {
                const streamParseInfo = parseInfoGetter(objectId.id);
                if (!streamParseInfo) {
                    continue;
                }
                const stream = GraphicsStateDict.parse(streamParseInfo);
                if (stream) {
                    this._gsMap.set(`/ExtGState${name}`, stream.value);
                }
            }
            for (const [name, parseInfo] of this.ExtGState.getDictParsers()) {
                const dict = GraphicsStateDict.parse(parseInfo);
                if (dict) {
                    this._gsMap.set(`/ExtGState${name}`, dict.value);
                }
            }
        }
        if (this.XObject && this._streamParsers) {
            for (const [name, objectId] of this.XObject.getObjectIds()) {
                const streamParseInfo = parseInfoGetter(objectId.id);
                if (!streamParseInfo) {
                    continue;
                }
                const stream = streamParseInfo.parser
                    .findSubarrayIndex(keywordCodes.FORM, {
                    direction: "straight",
                    minIndex: streamParseInfo.bounds.start,
                    maxIndex: streamParseInfo.bounds.end,
                })
                    ? this._streamParsers.xform(streamParseInfo)
                    : this._streamParsers.image(streamParseInfo);
                if (stream) {
                    this._xObjectsMap.set(`/XObject${name}`, stream.value);
                }
            }
        }
        if (this.Font) {
            for (const [name, objectId] of this.Font.getObjectIds()) {
                const dictParseInfo = parseInfoGetter(objectId.id);
                if (!dictParseInfo) {
                    continue;
                }
                const dict = FontDict.parse(dictParseInfo);
                if (dict) {
                    this._fontsMap.set(`/Font${name}`, dict.value);
                }
            }
        }
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/ExtGState":
                    case "/ColorSpace":
                    case "/Pattern":
                    case "/Shading":
                    case "/XObject":
                    case "/Font":
                    case "/Properties":
                        const mapEntryType = parser.getValueTypeAt(i);
                        if (mapEntryType === valueTypes.REF) {
                            const mapDictId = ObjectId.parseRef(parser, i);
                            if (mapDictId && parseInfo.parseInfoGetter) {
                                const mapParseInfo = parseInfo.parseInfoGetter(mapDictId.value.id);
                                if (mapParseInfo) {
                                    const mapDict = ObjectMapDict.parse(mapParseInfo);
                                    if (mapDict) {
                                        this[name.slice(1)] = mapDict.value;
                                        i = mapDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error(`Can't parse ${name} value reference`);
                        }
                        else if (mapEntryType === valueTypes.DICTIONARY) {
                            const mapBounds = parser.getDictBoundsAt(i);
                            if (mapBounds) {
                                const map = ObjectMapDict.parse({ parser, bounds: mapBounds });
                                if (map) {
                                    this[name.slice(1)] = map.value;
                                    i = mapBounds.end + 1;
                                    break;
                                }
                                else {
                                    throw new Error(`Can't parse ${name} value dictionary`);
                                }
                            }
                            throw new Error(`Can't parse ${name} dictionary bounds`);
                        }
                        throw new Error(`Unsupported /Resources property value type: ${mapEntryType}`);
                    case "/ProcSet":
                        i = this.parseNameArrayProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (parseInfo.parseInfoGetter) {
            this.fillMaps(parseInfo.parseInfoGetter, parseInfo.cryptInfo);
        }
    }
}

class MeasureDict extends PdfDict {
    constructor() {
        super(dictTypes.MEASURE);
        this.Subtype = "/RL";
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new MeasureDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class GroupDict extends PdfDict {
    constructor() {
        super(dictTypes.GROUP);
        this.S = "/Transparency";
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/S":
                        const intent = parser.parseNameAt(i, true);
                        if (intent) {
                            if (Object.values(groupDictTypes).includes(intent.value)) {
                                this.S = intent.value;
                                i = intent.end + 1;
                            }
                            else {
                                throw new Error(`Ivalid dict subtype: '${intent.value}'`);
                            }
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class TransparencyGroupDict extends GroupDict {
    constructor() {
        super();
        this.I = false;
        this.K = false;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TransparencyGroupDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.CS) {
            bytes.push(...encoder.encode("/CS "), ...encoder.encode(this.CS));
        }
        if (this.I) {
            bytes.push(...encoder.encode("/I "), ...encoder.encode(" " + this.I));
        }
        if (this.K) {
            bytes.push(...encoder.encode("/K "), ...encoder.encode(" " + this.K));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        if (this.S !== "/Transparency") {
            throw new Error("Not a transparency dict");
        }
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/CS":
                        const colorSpaceEntryType = parser.getValueTypeAt(i);
                        if (colorSpaceEntryType === valueTypes.NAME) {
                            const colorSpaceName = parser.parseNameAt(i);
                            if (colorSpaceName) {
                                this.CS = colorSpaceName.value;
                                i = colorSpaceName.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /CS property name");
                        }
                        else if (colorSpaceEntryType === valueTypes.ARRAY) {
                            const colorSpaceArrayBounds = parser.getArrayBoundsAt(i);
                            if (colorSpaceArrayBounds) {
                                i = colorSpaceArrayBounds.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /CS value dictionary");
                        }
                        throw new Error(`Unsupported /CS property value type: ${colorSpaceEntryType}`);
                    case "/I":
                    case "/K":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class XFormStream extends PdfStream {
    constructor() {
        super(streamTypes.FORM_XOBJECT);
        this.Subtype = "/Form";
        this.FormType = 1;
        this.Matrix = [1, 0, 0, 1, 0, 0];
    }
    get matrix() {
        const apMatrix = new Mat3();
        if (this.Matrix) {
            const [m0, m1, m3, m4, m6, m7] = this.Matrix;
            apMatrix.set(m0, m1, 0, m3, m4, 0, m6, m7, 1);
        }
        return apMatrix;
    }
    set matrix(matrix) {
        if (!matrix) {
            return;
        }
        this.Matrix = [...matrix.toFloatShortArray()];
    }
    get bBox() {
        return {
            ll: new Vec2(this.BBox[0], this.BBox[1]),
            lr: new Vec2(this.BBox[2], this.BBox[1]),
            ur: new Vec2(this.BBox[2], this.BBox[3]),
            ul: new Vec2(this.BBox[0], this.BBox[3]),
        };
    }
    get transformedBBox() {
        const matrix = new Mat3();
        if (this.Matrix) {
            const [m0, m1, m3, m4, m6, m7] = this.Matrix;
            matrix.set(m0, m1, 0, m3, m4, 0, m6, m7, 1);
        }
        const bBoxLL = new Vec2(this.BBox[0], this.BBox[1]);
        const bBoxLR = new Vec2(this.BBox[2], this.BBox[1]);
        const bBoxUR = new Vec2(this.BBox[2], this.BBox[3]);
        const bBoxUL = new Vec2(this.BBox[0], this.BBox[3]);
        return {
            ll: Vec2.applyMat3(bBoxLL, matrix),
            lr: Vec2.applyMat3(bBoxLR, matrix),
            ur: Vec2.applyMat3(bBoxUR, matrix),
            ul: Vec2.applyMat3(bBoxUL, matrix),
        };
    }
    get edited() {
        return this._edited || this.Resources.edited;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new XFormStream();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        if (this.FormType) {
            bytes.push(...encoder.encode("/FormType "), ...encoder.encode(" " + this.FormType));
        }
        if (this.BBox) {
            bytes.push(...encoder.encode("/BBox "), codes.L_BRACKET, ...encoder.encode(this.BBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.BBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.BBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.BBox[3] + ""), codes.R_BRACKET);
        }
        if (this.Matrix) {
            bytes.push(...encoder.encode("/Matrix "), codes.L_BRACKET, ...encoder.encode(this.Matrix[0] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[1] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[2] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[3] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[4] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[5] + ""), codes.R_BRACKET);
        }
        if (this.Resources) {
            bytes.push(...encoder.encode("/Resources "), ...this.Resources.toArray(cryptInfo));
        }
        if (this.Metadata) {
            bytes.push(...encoder.encode("/Metadata "), codes.WHITESPACE, ...this.Metadata.toArray(cryptInfo));
        }
        if (this.LastModified) {
            bytes.push(...encoder.encode("/LastModified "), ...this.LastModified.toArray(cryptInfo));
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.StructParents) {
            bytes.push(...encoder.encode("/StructParents "), ...encoder.encode(" " + this.StructParents));
        }
        if (this.Measure) {
            bytes.push(...encoder.encode("/Measure "), ...this.Measure.toArray(cryptInfo));
        }
        if (this.Group) {
            bytes.push(...encoder.encode("/Group "), ...this.Group.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    case "/FormType":
                        const formType = parser.parseNumberAt(i, false);
                        if (formType) {
                            if (formType.value !== 1) {
                                throw new Error(`Ivalid form type: '${formType.value}' instead of '1'`);
                            }
                            i = formType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /FormType property value");
                        }
                        break;
                    case "/BBox":
                    case "/Matrix":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/LastModified":
                        i = this.parseDateProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/Metadata":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/StructParent":
                    case "/StructParents":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Resources":
                        const resEntryType = parser.getValueTypeAt(i);
                        if (resEntryType === valueTypes.REF) {
                            const resDictId = ObjectId.parseRef(parser, i);
                            if (resDictId && parseInfo.parseInfoGetter) {
                                const resParseInfo = parseInfo.parseInfoGetter(resDictId.value.id);
                                if (resParseInfo) {
                                    const resDict = ResourceDict.parse(resParseInfo, { xform: XFormStream.parse, image: ImageStream.parse });
                                    if (resDict) {
                                        this.Resources = resDict.value;
                                        i = resDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Resources value reference");
                        }
                        else if (resEntryType === valueTypes.DICTIONARY) {
                            const resDictBounds = parser.getDictBoundsAt(i);
                            if (resDictBounds) {
                                if (resDictBounds.contentStart) {
                                    const resDict = ResourceDict.parse({
                                        parser,
                                        bounds: resDictBounds,
                                        parseInfoGetter: parseInfo.parseInfoGetter,
                                    }, { xform: XFormStream.parse, image: ImageStream.parse });
                                    if (resDict) {
                                        this.Resources = resDict.value;
                                    }
                                    else {
                                        throw new Error("Can't parse /Resources value dictionary");
                                    }
                                }
                                i = resDictBounds.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /Resources dictionary bounds");
                        }
                        throw new Error(`Unsupported /Resources property value type: ${resEntryType}`);
                    case "/Measure":
                        const measureEntryType = parser.getValueTypeAt(i);
                        if (measureEntryType === valueTypes.REF) {
                            const measureDictId = ObjectId.parseRef(parser, i);
                            if (measureDictId && parseInfo.parseInfoGetter) {
                                const measureParseInfo = parseInfo.parseInfoGetter(measureDictId.value.id);
                                if (measureParseInfo) {
                                    const measureDict = MeasureDict.parse(measureParseInfo);
                                    if (measureDict) {
                                        this.Measure = measureDict.value;
                                        i = measureDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Measure value reference");
                        }
                        else if (measureEntryType === valueTypes.DICTIONARY) {
                            const measureDictBounds = parser.getDictBoundsAt(i);
                            if (measureDictBounds) {
                                const measureDict = MeasureDict
                                    .parse({ parser, bounds: measureDictBounds, cryptInfo: parseInfo.cryptInfo });
                                if (measureDict) {
                                    this.Measure = measureDict.value;
                                    i = measureDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /Measure value dictionary");
                        }
                        throw new Error(`Unsupported /Measure property value type: ${measureEntryType}`);
                    case "/Group":
                        const groupEntryType = parser.getValueTypeAt(i);
                        if (groupEntryType === valueTypes.REF) {
                            const groupDictId = ObjectId.parseRef(parser, i);
                            if (groupDictId && parseInfo.parseInfoGetter) {
                                const groupParseInfo = parseInfo.parseInfoGetter(groupDictId.value.id);
                                if (groupParseInfo) {
                                    const groupDict = TransparencyGroupDict.parse(groupParseInfo);
                                    if (groupDict) {
                                        this.Group = groupDict.value;
                                        i = groupDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Group value reference");
                        }
                        else if (groupEntryType === valueTypes.DICTIONARY) {
                            const groupDictBounds = parser.getDictBoundsAt(i);
                            if (groupDictBounds) {
                                const groupDict = TransparencyGroupDict
                                    .parse({ parser, bounds: groupDictBounds, cryptInfo: parseInfo.cryptInfo });
                                if (groupDict) {
                                    this.Group = groupDict.value;
                                    i = groupDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /Group value dictionary");
                        }
                        throw new Error(`Unsupported /Group property value type: ${groupEntryType}`);
                    case "/OC":
                    case "/OPI":
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.BBox) {
            throw new Error("Not all required properties parsed");
        }
    }
}

function getRandomUuid() {
    return v4();
}

function buildCloudCurveFromPolyline(polylinePoints, maxArcSize) {
    if (!polylinePoints || polylinePoints.length < 2) {
        return null;
    }
    if (isNaN(maxArcSize) || maxArcSize <= 0) {
        throw new Error(`Invalid maximal arc size ${maxArcSize}`);
    }
    const start = polylinePoints[0].clone();
    const curves = [];
    const zeroVec = new Vec2();
    const lengthVec = new Vec2();
    let i;
    let j;
    let lineStart;
    let lineEnd;
    let lineLength;
    let arcCount;
    let arcSize;
    let halfArcSize;
    let arcStart;
    let arcEnd;
    for (i = 0; i < polylinePoints.length - 1; i++) {
        lineStart = polylinePoints[i];
        lineEnd = polylinePoints[i + 1];
        lineLength = Vec2.substract(lineEnd, lineStart).getMagnitude();
        if (!lineLength) {
            continue;
        }
        lengthVec.set(lineLength, 0);
        const matrix = mat3From4Vec2(zeroVec, lengthVec, lineStart, lineEnd);
        arcCount = Math.ceil(lineLength / maxArcSize);
        arcSize = lineLength / arcCount;
        halfArcSize = arcSize / 2;
        for (j = 0; j < arcCount; j++) {
            arcStart = j * arcSize;
            arcEnd = (j + 1) * arcSize;
            const curve = [
                new Vec2(arcStart, -halfArcSize).applyMat3(matrix),
                new Vec2(arcEnd, -halfArcSize).applyMat3(matrix),
                new Vec2(arcEnd, 0).applyMat3(matrix),
            ];
            curves.push(curve);
        }
    }
    return {
        start,
        curves,
    };
}
function buildCloudCurveFromEllipse(rx, ry, maxArcSize, matrix) {
    matrix || (matrix = new Mat3());
    const center = new Vec2();
    const ellipseCircumferenceApprox = Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
    const segmentsNumber = Math.ceil(ellipseCircumferenceApprox / maxArcSize / 4) * 4;
    const maxSegmentLength = Math.ceil(ellipseCircumferenceApprox / segmentsNumber);
    const points = [];
    const current = new Vec2(center.x + rx, center.y);
    const next = new Vec2();
    let angle = 0;
    let distance;
    points.push(current.clone().applyMat3(matrix));
    for (let i = 0; i < segmentsNumber; i++) {
        distance = 0;
        while (distance < maxSegmentLength) {
            angle += 0.25 / 180 * Math.PI;
            next.set(rx * Math.cos(angle) + center.x, ry * Math.sin(angle) + center.y);
            distance += getDistance(current.x, current.y, next.x, next.y);
            current.setFromVec2(next);
        }
        points.push(current.clone().applyMat3(matrix));
    }
    const curveData = buildCloudCurveFromPolyline(points, maxArcSize);
    return curveData;
}
function buildSquigglyLine(start, end, maxWaveSize) {
    if (!start || !end) {
        return null;
    }
    if (isNaN(maxWaveSize) || maxWaveSize <= 0) {
        throw new Error(`Invalid maximal squiggle size ${maxWaveSize}`);
    }
    const lineLength = Vec2.substract(start, end).getMagnitude();
    if (!lineLength) {
        return null;
    }
    const resultPoints = [start.clone()];
    const zeroVec = new Vec2();
    const lengthVec = new Vec2(lineLength, 0);
    const matrix = mat3From4Vec2(zeroVec, lengthVec, start, end);
    const waveCount = Math.ceil(lineLength / maxWaveSize);
    const waveSize = lineLength / waveCount;
    const halfWaveSize = waveSize / 2;
    for (let i = 0; i < waveCount; i++) {
        resultPoints.push(new Vec2(i * waveSize + halfWaveSize, -halfWaveSize).applyMat3(matrix), new Vec2((i + 1) * waveSize, 0).applyMat3(matrix));
    }
    return resultPoints;
}
const bezierConstant = 0.551915;
const selectionStrokeWidth = 20;

class TextState {
    constructor(params) {
        Object.assign(this, TextState.defaultParams, params);
    }
    clone(params) {
        const copy = new TextState(this);
        if (params) {
            return Object.assign(copy, params);
        }
        return copy;
    }
}
TextState.defaultParams = {
    fontFamily: "helvetica, sans-serif",
    fontSize: "12px",
    lineHeight: "1",
    letterSpacing: "normal",
    wordSpacing: "normal",
    textHorScale: 1,
    textRenderMode: textRenderModes.FILL,
    textVertAlign: "0",
    textKnockOut: true,
};

class GraphicsState {
    constructor(params) {
        var _a, _b, _c, _d;
        Object.assign(this, GraphicsState.defaultParams, params);
        this.matrix = (_a = this.matrix) === null || _a === void 0 ? void 0 : _a.clone();
        this.textState = (_b = this.textState) === null || _b === void 0 ? void 0 : _b.clone();
        this.strokeColor = (_c = this.strokeColor) === null || _c === void 0 ? void 0 : _c.clone();
        this.fillColor = (_d = this.fillColor) === null || _d === void 0 ? void 0 : _d.clone();
    }
    get stroke() {
        const { x: r, y: g, z: b } = this.strokeColor;
        const a = this.strokeAlpha;
        return `rgba(${r},${g},${b},${a})`;
    }
    get fill() {
        const { x: r, y: g, z: b } = this.fillColor;
        const a = this.fillAlpha;
        return `rgba(${r},${g},${b},${a})`;
    }
    clone(params) {
        const copy = new GraphicsState(this);
        if (params) {
            return Object.assign(copy, params);
        }
        return copy;
    }
    setColor(type, ...params) {
        let r, g, b;
        switch (params.length) {
            case 1:
                r = g = b = params[0] * 255;
                break;
            case 3:
                r = params[0] * 255;
                g = params[1] * 255;
                b = params[2] * 255;
                break;
            case 4:
                const [c, m, y, k] = params;
                r = 255 * (1 - c) * (1 - k);
                g = 255 * (1 - m) * (1 - k);
                b = 255 * (1 - y) * (1 - k);
                break;
        }
        if (type === "stroke") {
            this.strokeColor.set(r, g, b);
        }
        else {
            this.fillColor.set(r, g, b);
        }
    }
}
GraphicsState.defaultParams = {
    matrix: new Mat3(),
    textState: new TextState(),
    strokeColorSpace: "rgb",
    strokeAlpha: 1,
    strokeColor: new Vec3(),
    fillColorSpace: "rgb",
    fillAlpha: 1,
    fillColor: new Vec3(),
    strokeWidth: 1,
    strokeMiterLimit: 10,
    strokeLineCap: "square",
    strokeLineJoin: "miter",
};

var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AppearanceStreamRenderer {
    constructor(stream, rect, objectName) {
        this._clipPaths = [];
        this._graphicsStates = [];
        if (!stream) {
            throw new Error("Stream is not defined");
        }
        this._stream = stream;
        this._objectName = objectName;
        const { matAA } = AppearanceStreamRenderer.calcBBoxToRectMatrices(stream.BBox, rect, stream.Matrix);
        const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
        clipPath.id = `clip0_${objectName}`;
        clipPath.innerHTML = `<rect x="${rect[0]}" y="${rect[1]}" width="${rect[2] - rect[0]}" height="${rect[3] - rect[1]}" />`;
        this._clipPaths.push(clipPath);
        this._graphicsStates.push(new GraphicsState({ matrix: matAA, clipPath }));
    }
    get state() {
        return this._graphicsStates[this._graphicsStates.length - 1];
    }
    static calcBBoxToRectMatrices(bBox, rect, matrix) {
        const matAP = new Mat3();
        if (matrix) {
            const [m0, m1, m3, m4, m6, m7] = matrix;
            matAP.set(m0, m1, 0, m3, m4, 0, m6, m7, 1);
        }
        const bBoxLL = new Vec2(bBox[0], bBox[1]);
        const bBoxLR = new Vec2(bBox[2], bBox[1]);
        const bBoxUR = new Vec2(bBox[2], bBox[3]);
        const bBoxUL = new Vec2(bBox[0], bBox[3]);
        const { min: appBoxMin, max: appBoxMax } = vecMinMax(Vec2.applyMat3(bBoxLL, matAP), Vec2.applyMat3(bBoxLR, matAP), Vec2.applyMat3(bBoxUR, matAP), Vec2.applyMat3(bBoxUL, matAP));
        const rectMin = new Vec2(rect[0], rect[1]);
        const rectMax = new Vec2(rect[2], rect[3]);
        const matA = mat3From4Vec2(appBoxMin, appBoxMax, rectMin, rectMax);
        const matAA = Mat3.fromMat3(matAP).multiply(matA);
        return { matAP, matA, matAA };
    }
    static parseNextCommand(parser, i) {
        const parameters = [];
        let operator;
        command: while (!operator) {
            const nextValueType = parser.getValueTypeAt(i, true);
            switch (nextValueType) {
                case valueTypes.NUMBER:
                    const numberResult = parser.parseNumberAt(i, true);
                    parameters.push(numberResult.value);
                    i = numberResult.end + 1;
                    break;
                case valueTypes.NAME:
                    const nameResult = parser.parseNameAt(i, true);
                    parameters.push(nameResult.value);
                    i = nameResult.end + 1;
                    break;
                case valueTypes.ARRAY:
                    const arrayBounds = parser.getArrayBoundsAt(i);
                    const numberArrayResult = parser.parseNumberArrayAt(i, true);
                    if (numberArrayResult) {
                        const dashArray = numberArrayResult.value;
                        if (dashArray.length === 2) {
                            parameters.push(...dashArray);
                        }
                        else if (dashArray.length === 1) {
                            parameters.push(dashArray[0], 0);
                        }
                        else {
                            parameters.push(3, 0);
                        }
                    }
                    else {
                        throw new Error(`Invalid appearance stream array: 
            ${parser.sliceChars(arrayBounds.start, arrayBounds.end)}`);
                    }
                    i = arrayBounds.end + 1;
                    break;
                case valueTypes.STRING_LITERAL:
                    const literalResult = LiteralString.parse(parser, i);
                    parameters.push(literalResult.value.literal);
                    i = literalResult.end + 1;
                    break;
                case valueTypes.STRING_HEX:
                    const hexResult = HexString.parse(parser, i);
                    parameters.push(hexResult.value.hex);
                    i = hexResult.end + 1;
                    break;
                case valueTypes.UNKNOWN:
                    const operatorResult = parser.parseStringAt(i);
                    operator = operatorResult.value;
                    i = operatorResult.end + 1;
                    break command;
                default:
                    throw new Error(`Invalid appearance stream value type: ${nextValueType}`);
            }
        }
        return { endIndex: i, parameters, operator };
    }
    renderAsync() {
        return __awaiter$8(this, void 0, void 0, function* () {
            this.reset();
            const svg = this.createSvgElement();
            svg.append(...yield this.drawStreamAsync(this._stream));
            svg.append(...this._clipPaths);
            return svg;
        });
    }
    reset() {
        this._graphicsStates.length = 1;
        this._clipPaths.length = 1;
    }
    pushState(params) {
        const lastState = this._graphicsStates[this._graphicsStates.length - 1];
        const newState = lastState.clone(params);
        this._graphicsStates.push(newState);
    }
    popState() {
        if (this._graphicsStates.length === 1) {
            return null;
        }
        return this._graphicsStates.pop();
    }
    createSvgElement() {
        const element = document.createElementNS("http://www.w3.org/2000/svg", "g");
        return element;
    }
    drawPath(d, stroke, fill, close = false, evenOdd = false) {
        if (close && d[d.length - 1] !== "Z") {
            d += " Z";
        }
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("transform", `matrix(${this.state.matrix.toFloatShortArray().join(" ")})`);
        path.setAttribute("d", d);
        if (this.state.mixBlendMode && this.state.mixBlendMode !== "normal") ;
        if (fill) {
            path.setAttribute("fill", this.state.fill);
            path.setAttribute("fill-rule", evenOdd ? "evenodd" : "nonzero");
        }
        else {
            path.setAttribute("fill", "none");
        }
        if (stroke) {
            path.setAttribute("stroke", this.state.stroke);
            path.setAttribute("stroke-width", this.state.strokeWidth + "");
            path.setAttribute("stroke-miterlimit", this.state.strokeMiterLimit + "");
            path.setAttribute("stroke-linecap", this.state.strokeLineCap);
            path.setAttribute("stroke-linejoin", this.state.strokeLineJoin);
            if (this.state.strokeDashArray) {
                path.setAttribute("stroke-dasharray", this.state.strokeDashArray);
            }
            if (this.state.strokeDashOffset) {
                path.setAttribute("stroke-dashoffset", this.state.strokeDashOffset + "");
            }
        }
        else {
            path.setAttribute("stroke", "none");
        }
        const svg = this.createSvgElement();
        svg.setAttribute("clip-path", `url(#${this._clipPaths[this._clipPaths.length - 1].id})`);
        svg.append(path);
        const clonedSvg = this.createSvgElement();
        clonedSvg.classList.add("svg-annot-selection-alias");
        const clonedPath = path.cloneNode(true);
        const clonedPathStrokeWidth = !stroke || this.state.strokeWidth < selectionStrokeWidth
            ? selectionStrokeWidth
            : this.state.strokeWidth;
        clonedPath.setAttribute("stroke-width", clonedPathStrokeWidth + "");
        clonedPath.setAttribute("stroke", "transparent");
        clonedPath.setAttribute("fill", fill ? "transparent" : "none");
        clonedSvg.append(clonedPath);
        return [svg, clonedSvg];
    }
    drawText(value) {
        throw new Error("Method is not implemented");
    }
    drawTextGroup(parser) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        let i = 0;
        while (i !== -1) {
            const { endIndex, parameters, operator } = AppearanceStreamRenderer.parseNextCommand(parser, i);
            i = parser.skipEmpty(endIndex + 1);
        }
        return [g];
    }
    drawStreamAsync(stream) {
        return __awaiter$8(this, void 0, void 0, function* () {
            const parser = new DataParser(stream.decodedStreamData);
            const svgElements = [];
            const lastCoord = new Vec2();
            let lastOperator;
            let d = "";
            let i = 0;
            while (i !== -1) {
                const { endIndex, parameters, operator } = AppearanceStreamRenderer.parseNextCommand(parser, i);
                i = parser.skipEmpty(endIndex + 1);
                switch (operator) {
                    case "q":
                        this.pushState();
                        break;
                    case "Q":
                        this.popState();
                        break;
                    case "gs":
                        const externalState = this._stream.Resources.getGraphicsState(`/ExtGState${parameters[0]}`);
                        if (!externalState) {
                            throw new Error("External state specified in appearance stream not found");
                        }
                        const params = externalState.toParams();
                        Object.assign(this.state, params);
                        break;
                    case "cm":
                        const [m0, m1, m3, m4, m6, m7] = parameters;
                        const matrix = new Mat3().set(m0, m1, 0, m3, m4, 0, m6, m7, 1);
                        this.state.matrix = matrix.multiply(this.state.matrix);
                        break;
                    case "w":
                        this.state.strokeWidth = +parameters[0] || 1;
                        break;
                    case "J":
                        switch (parameters[0]) {
                            case lineCapStyles.ROUND:
                                this.state.strokeLineCap = "round";
                                break;
                            case lineCapStyles.SQUARE:
                                this.state.strokeLineCap = "square";
                                break;
                            case lineCapStyles.BUTT:
                            default:
                                this.state.strokeLineCap = "butt";
                                break;
                        }
                        break;
                    case "j":
                        switch (parameters[0]) {
                            case lineJoinStyles.BEVEL:
                                this.state.strokeLineJoin = "bevel";
                                break;
                            case lineJoinStyles.ROUND:
                                this.state.strokeLineJoin = "round";
                                break;
                            case lineJoinStyles.MITER:
                            default:
                                this.state.strokeLineJoin = "miter";
                                break;
                        }
                        break;
                    case "M":
                        this.state.strokeMiterLimit = +parameters[0] || 10;
                        break;
                    case "d":
                        this.state.strokeDashArray = `${parameters[0]} ${parameters[1]}`;
                        this.state.strokeDashOffset = +parameters[2];
                        break;
                    case "CS":
                        switch (parameters[0]) {
                            case colorSpaces.GRAYSCALE:
                                this.state.strokeColorSpace = "grayscale";
                                break;
                            case colorSpaces.RGB:
                                this.state.strokeColorSpace = "rgb";
                                break;
                            case colorSpaces.CMYK:
                                this.state.strokeColorSpace = "cmyk";
                                break;
                            default:
                                throw new Error("Unsupported color space in appearance stream");
                        }
                        break;
                    case "cs":
                        switch (parameters[0]) {
                            case colorSpaces.GRAYSCALE:
                                this.state.fillColorSpace = "grayscale";
                                break;
                            case colorSpaces.RGB:
                                this.state.fillColorSpace = "rgb";
                                break;
                            case colorSpaces.CMYK:
                                this.state.fillColorSpace = "cmyk";
                                break;
                            default:
                                throw new Error("Unsupported color space in appearance stream");
                        }
                        break;
                    case "G":
                        this.state.strokeColorSpace = "grayscale";
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "g":
                        this.state.fillColorSpace = "grayscale";
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "RG":
                        this.state.strokeColorSpace = "rgb";
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "rg":
                        this.state.fillColorSpace = "rgb";
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "K":
                        this.state.strokeColorSpace = "cmyk";
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "k":
                        this.state.fillColorSpace = "cmyk";
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "SC":
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "cs":
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "ri":
                    case "i":
                        break;
                    case "m":
                        const move = new Vec2(+parameters[0], +parameters[1]);
                        d += ` M ${move.x} ${move.y}`;
                        lastCoord.setFromVec2(move);
                        break;
                    case "l":
                        const line = new Vec2(+parameters[0], +parameters[1]);
                        d += ` L ${line.x} ${line.y}`;
                        lastCoord.setFromVec2(line);
                        break;
                    case "re":
                        const rMin = new Vec2(+parameters[0], +parameters[1]);
                        const rMax = new Vec2(+parameters[2], +parameters[3]).add(rMin);
                        d += ` M ${rMin.x} ${rMin.y} L ${rMax.x} ${rMin.y} L ${rMax.x} ${rMax.y} L ${rMin.x} ${rMax.y} L ${rMin.x} ${rMin.y}`;
                        lastCoord.setFromVec2(rMin);
                        break;
                    case "c":
                        const cControl1 = new Vec2(+parameters[0], +parameters[1]);
                        const cControl2 = new Vec2(+parameters[2], +parameters[3]);
                        const cEnd = new Vec2(+parameters[4], +parameters[5]);
                        d += ` C ${cControl1.x} ${cControl1.y}, ${cControl2.x} ${cControl2.y}, ${cEnd.x} ${cEnd.y}`;
                        lastCoord.setFromVec2(cEnd);
                        break;
                    case "v":
                        const vControl2 = new Vec2(+parameters[0], +parameters[1]);
                        const vEnd = new Vec2(+parameters[2], +parameters[3]);
                        d += ` C ${lastCoord.x} ${lastCoord.y}, ${vControl2.x} ${vControl2.y}, ${vEnd.x} ${vEnd.y}`;
                        lastCoord.setFromVec2(vEnd);
                        break;
                    case "y":
                        const yControl1 = new Vec2(+parameters[0], +parameters[1]);
                        const yEnd = new Vec2(+parameters[2], +parameters[3]);
                        d += ` C ${yControl1.x} ${yControl1.y}, ${yEnd.x} ${yEnd.y}, ${yEnd.x} ${yEnd.y}`;
                        lastCoord.setFromVec2(yEnd);
                        break;
                    case "h":
                        d += " Z";
                        break;
                    case "S":
                        svgElements.push(...this.drawPath(d, true, false));
                        d = "";
                        break;
                    case "s":
                        svgElements.push(...this.drawPath(d, true, false, true));
                        d = "";
                        break;
                    case "F":
                    case "f":
                        svgElements.push(...this.drawPath(d, false, true, true));
                        d = "";
                        break;
                    case "F*":
                    case "f*":
                        svgElements.push(...this.drawPath(d, false, true, true, true));
                        d = "";
                        break;
                    case "B":
                        svgElements.push(...this.drawPath(d, true, true, false, false));
                        d = "";
                        break;
                    case "B*":
                        svgElements.push(...this.drawPath(d, true, true, false, true));
                        d = "";
                        break;
                    case "b":
                        svgElements.push(...this.drawPath(d, true, true, true, false));
                        d = "";
                        break;
                    case "b*":
                        svgElements.push(...this.drawPath(d, true, true, true, true));
                        d = "";
                        break;
                    case "n":
                        if (lastOperator === "W" || lastOperator === "W*") {
                            if (d[d.length - 1] !== "Z") {
                                d += " Z";
                            }
                            const clippingPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                            clippingPath.setAttribute("d", d);
                            const lastCpIndex = this._clipPaths.length - 1;
                            const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
                            clipPath.setAttribute("clip-rule", lastOperator === "W" ? "nonzero" : "evenodd");
                            clipPath.setAttribute("clip-path", `url(#${this._clipPaths[lastCpIndex]})`);
                            clipPath.id = `clip${lastCpIndex + 1}_${this._objectName}`;
                            clipPath.append(clippingPath);
                            this._clipPaths.push(clipPath);
                            this.state.clipPath = clipPath;
                        }
                        d = "";
                        break;
                    case "W":
                        break;
                    case "W*":
                        break;
                    case "BT":
                        const textObjectEnd = parser.findSubarrayIndex([codes.E, codes.T], {
                            closedOnly: true,
                            minIndex: i,
                        });
                        if (textObjectEnd) {
                            const textGroup = this.drawTextGroup(new DataParser(parser.sliceCharCodes(i, textObjectEnd.start - 1)));
                            svgElements.push(...textGroup);
                            i = parser.skipEmpty(textObjectEnd.end + 1);
                            break;
                        }
                        throw new Error("Can't find the appearance stream text object end");
                    case "Do":
                        const innerStream = stream.Resources.getXObject((`/XObject${parameters[0]}`));
                        if (!innerStream) {
                            throw new Error(`External object not found in the appearance stream resources: ${parameters[0]}`);
                        }
                        if (innerStream instanceof XFormStream) {
                            const [im0, im1, im3, im4, im6, im7] = innerStream.Matrix;
                            const innerMat = new Mat3().set(im0, im1, 0, im3, im4, 0, im6, im7, 1);
                            this.pushState();
                            this.state.matrix = innerMat.multiply(this.state.matrix);
                            const innerStreamSvgElements = yield this.drawStreamAsync(innerStream);
                            svgElements.push(...innerStreamSvgElements);
                            this.popState();
                        }
                        else if (innerStream instanceof ImageStream) {
                            const url = yield innerStream.getImageUrlAsync();
                            if (!url) {
                                throw new Error("Can't get image url from external image stream");
                            }
                            const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
                            image.onerror = e => {
                                console.log(`Loading external image stream failed: ${e}`);
                            };
                            image.setAttribute("href", url);
                            image.setAttribute("width", innerStream.Width + "");
                            image.setAttribute("height", innerStream.Height + "");
                            const imageMatrix = new Mat3()
                                .applyTranslation(-innerStream.Width / 2, -innerStream.Height / 2)
                                .applyScaling(1, -1)
                                .applyTranslation(innerStream.Width / 2, innerStream.Height / 2)
                                .applyScaling(1 / innerStream.Width, 1 / innerStream.Height)
                                .multiply(this.state.matrix);
                            image.setAttribute("transform", `matrix(${imageMatrix.toFloatShortArray().join(" ")})`);
                            const imageWrapper = this.createSvgElement();
                            imageWrapper.setAttribute("clip-path", `url(#${this._clipPaths[this._clipPaths.length - 1].id})`);
                            imageWrapper.append(image);
                            svgElements.push(imageWrapper);
                        }
                        else {
                            throw new Error(`Unsupported appearance stream external object: ${parameters[0]}`);
                        }
                        break;
                    default:
                        throw new Error(`Unsupported appearance stream operator: ${operator}`);
                }
                lastOperator = operator;
            }
            return svgElements;
        });
    }
}

const borderStyles = {
    SOLID: "/S",
    DASHED: "/D",
    BEVELED: "/B",
    INSET: "/I",
    UNDERLINE: "/U",
    NONE: "/N",
};
class BorderStyleDict extends PdfDict {
    constructor() {
        super(dictTypes.BORDER_STYLE);
        this.W = 1;
        this.S = borderStyles.SOLID;
        this.D = [3, 0];
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new BorderStyleDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.W) {
            bytes.push(...encoder.encode("/W "), ...encoder.encode(" " + this.W));
        }
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        if (this.D) {
            bytes.push(...encoder.encode("/D "), codes.L_BRACKET, ...encoder.encode(this.D[0] + ""), codes.WHITESPACE, ...encoder.encode(this.D[1] + ""), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        var _a, _b;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/W":
                        i = this.parseNumberProp(name, parser, i, true);
                        break;
                    case "/S":
                        const style = parser.parseNameAt(i, true);
                        if (style && Object.values(borderStyles).includes(style.value)) {
                            this.S = style.value;
                            i = style.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    case "/D":
                        const dashGap = parser.parseNumberArrayAt(i, true);
                        if (dashGap) {
                            this.D = [
                                (_a = dashGap.value[0]) !== null && _a !== void 0 ? _a : 3,
                                (_b = dashGap.value[1]) !== null && _b !== void 0 ? _b : 0,
                            ];
                            i = dashGap.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /D property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class AppearanceDict extends PdfDict {
    constructor() {
        super(null);
        this._streamsMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new AppearanceDict();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getStream(key) {
        return this._streamsMap.get(key);
    }
    *getStreams() {
        for (const pair of this._streamsMap) {
            yield pair[1];
        }
        return;
    }
    setStream(key, stream) {
        this._streamsMap.set(key, stream);
        this._edited = true;
    }
    clearStreams() {
        this._streamsMap.clear();
        this._edited = true;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        const nStream = this._streamsMap.get("/N");
        if (nStream) {
            bytes.push(...encoder.encode("/N "));
            bytes.push(...ObjectId.fromRef(nStream.ref).toArray(cryptInfo));
        }
        else if (this.N) {
            bytes.push(...encoder.encode("/N "));
            if (this.N instanceof ObjectMapDict) {
                bytes.push(...this.N.toArray(cryptInfo));
            }
            else {
                bytes.push(...this.N.toArray(cryptInfo));
            }
        }
        const rStream = this._streamsMap.get("/R");
        if (rStream) {
            bytes.push(...encoder.encode("/R "));
            bytes.push(...ObjectId.fromRef(rStream.ref).toArray(cryptInfo));
        }
        else if (this.R) {
            bytes.push(...encoder.encode("/R "));
            if (this.R instanceof ObjectMapDict) {
                bytes.push(...this.R.toArray(cryptInfo));
            }
            else {
                bytes.push(...this.R.toArray(cryptInfo));
            }
        }
        const dStream = this._streamsMap.get("/D");
        if (dStream) {
            bytes.push(...encoder.encode("/D "));
            bytes.push(...ObjectId.fromRef(dStream.ref).toArray(cryptInfo));
        }
        else if (this.D) {
            bytes.push(...encoder.encode("/D "));
            if (this.D instanceof ObjectMapDict) {
                bytes.push(...this.D.toArray(cryptInfo));
            }
            else {
                bytes.push(...this.D.toArray(cryptInfo));
            }
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    fillStreamsMap(parseInfoGetter) {
        this._streamsMap.clear();
        for (const prop of ["N", "R", "D"]) {
            if (this[prop]) {
                if (this[prop] instanceof ObjectId) {
                    const streamParseInfo = parseInfoGetter(this[prop].id);
                    if (!streamParseInfo) {
                        continue;
                    }
                    const stream = XFormStream.parse(streamParseInfo);
                    if (!stream) {
                        continue;
                    }
                    if (stream) {
                        this._streamsMap.set(`/${prop}`, stream.value);
                    }
                }
                else {
                    for (const [name, objectId] of this[prop].getProps()) {
                        const streamParseInfo = parseInfoGetter(objectId.id);
                        if (!streamParseInfo) {
                            continue;
                        }
                        const stream = XFormStream.parse(streamParseInfo);
                        if (stream) {
                            this._streamsMap.set(`/${prop}${name}`, stream.value);
                        }
                    }
                }
            }
        }
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/N":
                        const nEntryType = parser.getValueTypeAt(i);
                        if (nEntryType === valueTypes.REF) {
                            const nRefId = ObjectId.parseRef(parser, i);
                            if (nRefId) {
                                this.N = nRefId.value;
                                i = nRefId.end + 1;
                                break;
                            }
                        }
                        else if (nEntryType === valueTypes.DICTIONARY) {
                            const nDictBounds = parser.getDictBoundsAt(i);
                            if (nDictBounds) {
                                const nSubDict = ObjectMapDict.parse({ parser, bounds: nDictBounds });
                                if (nSubDict) {
                                    this.N = nSubDict.value;
                                    i = nSubDict.end + 1;
                                    break;
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /N property value type: ${nEntryType}`);
                        }
                        throw new Error("Can't parse /N property value");
                    case "/R":
                        const rEntryType = parser.getValueTypeAt(i);
                        if (rEntryType === valueTypes.REF) {
                            const rRefId = ObjectId.parseRef(parser, i);
                            if (rRefId) {
                                this.R = rRefId.value;
                                i = rRefId.end + 1;
                                break;
                            }
                        }
                        else if (rEntryType === valueTypes.DICTIONARY) {
                            const rDictBounds = parser.getDictBoundsAt(i);
                            if (rDictBounds) {
                                const rSubDict = ObjectMapDict.parse({ parser, bounds: rDictBounds });
                                if (rSubDict) {
                                    this.R = rSubDict.value;
                                    i = rSubDict.end + 1;
                                    break;
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /R property value type: ${rEntryType}`);
                        }
                        throw new Error("Can't parse /R property value");
                    case "/D":
                        const dEntryType = parser.getValueTypeAt(i);
                        if (dEntryType === valueTypes.REF) {
                            const dRefId = ObjectId.parseRef(parser, i);
                            if (dRefId) {
                                this.D = dRefId.value;
                                i = dRefId.end + 1;
                                break;
                            }
                        }
                        else if (dEntryType === valueTypes.DICTIONARY) {
                            const dDictBounds = parser.getDictBoundsAt(i);
                            if (dDictBounds) {
                                const dSubDict = ObjectMapDict.parse({ parser, bounds: dDictBounds });
                                if (dSubDict) {
                                    this.D = dSubDict.value;
                                    i = dSubDict.end + 1;
                                    break;
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /D property value type: ${dEntryType}`);
                        }
                        throw new Error("Can't parse /D property value");
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.N) {
            throw new Error("Not all required properties parsed");
        }
        if (parseInfo.parseInfoGetter) {
            this.fillStreamsMap(parseInfo.parseInfoGetter);
        }
    }
}

const borderEffects = {
    NONE: "/S",
    CLOUDY: "/C",
};
class BorderEffectDict extends PdfDict {
    constructor() {
        super(null);
        this.S = borderEffects.NONE;
        this.L = 0;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new BorderEffectDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        if (this.L) {
            bytes.push(...encoder.encode("/L "), ...encoder.encode(" " + this.L));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/S":
                        const style = parser.parseNameAt(i, true);
                        if (style && Object.values(borderEffects).includes(style.value)) {
                            this.S = style.value;
                            i = style.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    case "/L":
                        i = this.parseNumberProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class BorderArray {
    constructor(hCornerR, vCornerR, width, dash, gap) {
        this.hCornerR = hCornerR !== null && hCornerR !== void 0 ? hCornerR : 0;
        this.vCornerR = vCornerR !== null && vCornerR !== void 0 ? vCornerR : 0;
        this.width = width !== null && width !== void 0 ? width : 1;
        this.dash = dash !== null && dash !== void 0 ? dash : 3;
        this.gap = gap !== null && gap !== void 0 ? gap : 0;
    }
    static parse(parser, start, skipEmpty = true) {
        if (skipEmpty) {
            start = parser.findNonSpaceIndex("straight", start);
        }
        if (start < 0 || start > parser.maxIndex
            || parser.getCharCode(start) !== codes.L_BRACKET) {
            return null;
        }
        const hCornerR = parser.parseNumberAt(start + 1);
        if (!hCornerR || isNaN(hCornerR.value)) {
            return null;
        }
        const vCornerR = parser.parseNumberAt(hCornerR.end + 2);
        if (!vCornerR || isNaN(vCornerR.value)) {
            return null;
        }
        const width = parser.parseNumberAt(vCornerR.end + 2);
        if (!width || isNaN(width.value)) {
            return null;
        }
        const next = parser.findNonSpaceIndex("straight", width.end + 1);
        if (!next) {
            return null;
        }
        else if (parser.getCharCode(next) === codes.R_BRACKET) {
            return {
                value: new BorderArray(hCornerR.value, vCornerR.value, width.value),
                start,
                end: next,
            };
        }
        else if (parser.getCharCode(next) === codes.L_BRACKET) {
            const dash = parser.parseNumberAt(next + 1);
            if (!dash || isNaN(dash.value)) {
                return null;
            }
            const gap = parser.parseNumberAt(dash.end + 2);
            if (!gap || isNaN(gap.value)) {
                return null;
            }
            const dashEnd = parser.findNonSpaceIndex("straight", gap.end + 1);
            if (!dashEnd || parser.getCharCode(dashEnd) !== codes.R_BRACKET) {
                return null;
            }
            const arrayEnd = parser.findNonSpaceIndex("straight", dashEnd + 1);
            if (!arrayEnd || parser.getCharCode(arrayEnd) !== codes.R_BRACKET) {
                return null;
            }
            return {
                value: new BorderArray(hCornerR.value, vCornerR.value, width.value, dash.value, gap.value),
                start,
                end: arrayEnd,
            };
        }
        return null;
    }
    toArray(cryptInfo) {
        const source = this.dash && this.gap
            ? `[${this.hCornerR} ${this.vCornerR} ${this.width}]`
            : `[${this.hCornerR} ${this.vCornerR} ${this.width} [${this.dash} ${this.gap}]]`;
        return new TextEncoder().encode(source);
    }
}

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AnnotationDict extends PdfDict {
    constructor(subType) {
        super(dictTypes.ANNOTATION);
        this.F = 4;
        this.Border = new BorderArray(0, 0, 1);
        this._currentAngle = 0;
        this._tempTransformationMatrix = new Mat3();
        this._tempStartPoint = new Vec2();
        this._tempVecX = new Vec2();
        this._tempVecY = new Vec2();
        this._svgId = getRandomUuid();
        this.onSvgPointerEnter = (e) => {
            if (this.$onPointerEnterAction) {
                this.$onPointerEnterAction(e);
            }
        };
        this.onSvgPointerLeave = (e) => {
            if (this.$onPointerLeaveAction) {
                this.$onPointerLeaveAction(e);
            }
        };
        this.onSvgPointerDown = (e) => {
            if (!this.$pageId) {
                return;
            }
            if (this.$onPointerDownAction) {
                this.$onPointerDownAction(e);
            }
            this.onTranslationPointerDown(e);
        };
        this.onTranslationPointerDown = (e) => {
            if (!this.$translationEnabled || !e.isPrimary) {
                return;
            }
            document.addEventListener("pointerup", this.onTranslationPointerUp);
            document.addEventListener("pointerout", this.onTranslationPointerUp);
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                this._tempStartPoint.setFromVec2(this.convertClientCoordsToPage(e.clientX, e.clientY));
                document.addEventListener("pointermove", this.onTranslationPointerMove);
            }, 200);
        };
        this.onTranslationPointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const current = this.convertClientCoordsToPage(e.clientX, e.clientY);
            this._tempTransformationMatrix.reset()
                .applyTranslation(current.x - this._tempStartPoint.x, current.y - this._tempStartPoint.y);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._tempTransformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onTranslationPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.removeEventListener("pointermove", this.onTranslationPointerMove);
            document.removeEventListener("pointerup", this.onTranslationPointerUp);
            document.removeEventListener("pointerout", this.onTranslationPointerUp);
            this.applyTempTransform();
            this.updateRenderAsync();
        };
        this.onRotationHandlePointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.addEventListener("pointerup", this.onRotationHandlePointerUp);
            document.addEventListener("pointerout", this.onRotationHandlePointerUp);
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                document.addEventListener("pointermove", this.onRotationHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onRotationHandlePointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const centerX = (this.Rect[0] + this.Rect[2]) / 2;
            const centerY = (this.Rect[1] + this.Rect[3]) / 2;
            const clientCenter = this.convertPageCoordsToClient(centerX, centerY);
            const currentRotation = this.getCurrentRotation();
            const angle = Math.atan2(e.clientY - clientCenter.y, e.clientX - clientCenter.x) + Math.PI / 2 - currentRotation;
            this._currentAngle = angle;
            this._tempTransformationMatrix.reset()
                .applyTranslation(-centerX, -centerY)
                .applyRotation(angle)
                .applyTranslation(centerX, centerY);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._tempTransformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onRotationHandlePointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.removeEventListener("pointermove", this.onRotationHandlePointerMove);
            document.removeEventListener("pointerup", this.onRotationHandlePointerUp);
            document.removeEventListener("pointerout", this.onRotationHandlePointerUp);
            this.applyTempTransform();
            this.updateRenderAsync();
        };
        this.onScaleHandlePointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.addEventListener("pointerup", this.onScaleHandlePointerUp);
            document.addEventListener("pointerout", this.onScaleHandlePointerUp);
            const target = e.target;
            const { ll, lr, ur, ul } = this.getLocalBB();
            const handleName = target.dataset["handleName"];
            switch (handleName) {
                case "ll":
                    this._tempStartPoint.setFromVec2(ur);
                    this._tempVecX.setFromVec2(ul).substract(ur);
                    this._tempVecY.setFromVec2(lr).substract(ur);
                    break;
                case "lr":
                    this._tempStartPoint.setFromVec2(ul);
                    this._tempVecX.setFromVec2(ur).substract(ul);
                    this._tempVecY.setFromVec2(ll).substract(ul);
                    break;
                case "ur":
                    this._tempStartPoint.setFromVec2(ll);
                    this._tempVecX.setFromVec2(lr).substract(ll);
                    this._tempVecY.setFromVec2(ul).substract(ll);
                    break;
                case "ul":
                    this._tempStartPoint.setFromVec2(lr);
                    this._tempVecX.setFromVec2(ll).substract(lr);
                    this._tempVecY.setFromVec2(ur).substract(lr);
                    break;
                default:
                    throw new Error(`Invalid handle name: ${handleName}`);
            }
            this._tempX = this._tempVecX.getMagnitude();
            this._tempY = this._tempVecY.getMagnitude();
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                document.addEventListener("pointermove", this.onScaleHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onScaleHandlePointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const currentBoxDiagonal = this.convertClientCoordsToPage(e.clientX, e.clientY)
                .substract(this._tempStartPoint);
            const currentBoxDiagonalLength = currentBoxDiagonal.getMagnitude();
            const cos = Math.abs(currentBoxDiagonal.dotProduct(this._tempVecX))
                / currentBoxDiagonalLength / this._tempX;
            const currentXSideLength = cos * currentBoxDiagonalLength;
            const currentYSideLength = Math.sqrt(currentBoxDiagonalLength * currentBoxDiagonalLength
                - currentXSideLength * currentXSideLength);
            const scaleX = currentXSideLength / this._tempX;
            const scaleY = currentYSideLength / this._tempY;
            const annotCenterX = (this.Rect[0] + this.Rect[2]) / 2;
            const annotCenterY = (this.Rect[1] + this.Rect[3]) / 2;
            const currentRotation = this.getCurrentRotation();
            this._tempTransformationMatrix.reset()
                .applyTranslation(-annotCenterX, -annotCenterY)
                .applyRotation(-currentRotation)
                .applyScaling(scaleX, scaleY)
                .applyRotation(currentRotation)
                .applyTranslation(annotCenterX, annotCenterY);
            const translation = this._tempStartPoint.clone().substract(this._tempStartPoint.clone().applyMat3(this._tempTransformationMatrix));
            this._tempTransformationMatrix.applyTranslation(translation.x, translation.y);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._tempTransformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onScaleHandlePointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.removeEventListener("pointermove", this.onScaleHandlePointerMove);
            document.removeEventListener("pointerup", this.onScaleHandlePointerUp);
            document.removeEventListener("pointerout", this.onScaleHandlePointerUp);
            this.applyTempTransform();
            this.updateRenderAsync();
        };
        this.Subtype = subType;
    }
    get apStream() {
        var _a;
        if (!this._apStream) {
            const streams = (_a = this.AP) === null || _a === void 0 ? void 0 : _a.getStreams();
            if (streams) {
                this._apStream = [...streams][0];
            }
        }
        return this._apStream;
    }
    set apStream(value) {
        this._apStream = value;
        this._edited = true;
    }
    get lastRenderResult() {
        return this._svg;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        if (this.Rect) {
            bytes.push(...encoder.encode("/Rect "), codes.L_BRACKET, ...encoder.encode(this.Rect[0] + ""), codes.WHITESPACE, ...encoder.encode(this.Rect[1] + ""), codes.WHITESPACE, ...encoder.encode(this.Rect[2] + ""), codes.WHITESPACE, ...encoder.encode(this.Rect[3] + ""), codes.R_BRACKET);
        }
        if (this.Contents) {
            bytes.push(...encoder.encode("/Contents "), ...this.Contents.toArray(cryptInfo));
        }
        if (this.P) {
            bytes.push(...encoder.encode("/P "), codes.WHITESPACE, ...this.P.toArray(cryptInfo));
        }
        if (this.NM) {
            bytes.push(...encoder.encode("/NM "), ...this.NM.toArray(cryptInfo));
        }
        if (this.M) {
            bytes.push(...encoder.encode("/M "), ...this.M.toArray(cryptInfo));
        }
        if (this.F) {
            bytes.push(...encoder.encode("/F "), ...encoder.encode(" " + this.F));
        }
        if (this.AS) {
            bytes.push(...encoder.encode("/AS "), ...encoder.encode(this.AS));
        }
        if (this.Border) {
            bytes.push(...encoder.encode("/Border "), ...this.Border.toArray(cryptInfo));
        }
        if (this.BS) {
            bytes.push(...encoder.encode("/BS "), ...this.BS.toArray(cryptInfo));
        }
        if (this.BE) {
            bytes.push(...encoder.encode("/BE "), ...this.BE.toArray(cryptInfo));
        }
        if (this.C) {
            bytes.push(...encoder.encode("/C "), codes.L_BRACKET);
            this.C.forEach(x => bytes.push(...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.apStream) {
            if (!this.AP) {
                this.AP = new AppearanceDict();
            }
            const apStreamRef = this.apStream.ref;
            if (!apStreamRef) {
                throw new Error("Appearance stream has no reference");
            }
            this.AP.N = ObjectId.fromRef(apStreamRef);
            this.AP.R = null;
            this.AP.D = null;
            this.AP.clearStreams();
            this.AP.setStream("/N", this.apStream);
            bytes.push(...encoder.encode("/AP "), ...this.AP.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    renderAsync() {
        return __awaiter$7(this, void 0, void 0, function* () {
            if (!this._svg) {
                this._svg = this.renderMainElement();
            }
            yield this.updateRenderAsync();
            return this._svg;
        });
    }
    moveTo(pageX, pageY) {
        const width = this.Rect[2] - this.Rect[0];
        const height = this.Rect[3] - this.Rect[1];
        const x = pageX - width / 2;
        const y = pageY - height / 2;
        const mat = Mat3.buildTranslate(x, y);
        this.applyCommonTransform(mat);
    }
    toDto() {
        var _a, _b, _c;
        return {
            annotationType: "/Ink",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: this["CreationDate"].date.toISOString() || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_a = this["T"]) === null || _a === void 0 ? void 0 : _a.literal,
            textContent: (_b = this.Contents) === null || _b === void 0 ? void 0 : _b.literal,
            rect: this.Rect,
            matrix: (_c = this.apStream) === null || _c === void 0 ? void 0 : _c.Matrix,
        };
    }
    setTextContent(text) {
        const dict = this._proxy || this;
        if (!text) {
            dict.Contents = null;
        }
        const literalString = LiteralString.fromString(text);
        dict.Contents = literalString;
        dict.M = DateString.fromDate(new Date());
    }
    parseProps(parseInfo) {
        var _a;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    case "/Rect":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/P":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Contents":
                    case "/NM":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/M":
                        const date = DateString.parse(parser, i, parseInfo.cryptInfo);
                        if (date) {
                            this.M = date.value;
                            i = date.end + 1;
                            break;
                        }
                        else {
                            const dateLiteral = LiteralString.parse(parser, i, parseInfo.cryptInfo);
                            if (dateLiteral) {
                                this.M = dateLiteral.value;
                                i = dateLiteral.end + 1;
                                break;
                            }
                        }
                        throw new Error("Can't parse /M property value");
                    case "/C":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/F":
                    case "/StructParent":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Border":
                        const borderArray = BorderArray.parse(parser, i);
                        if (borderArray) {
                            this.Border = borderArray.value;
                            i = borderArray.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Border property value");
                        }
                        break;
                    case "/BS":
                        const bsEntryType = parser.getValueTypeAt(i);
                        if (bsEntryType === valueTypes.REF) {
                            const bsDictId = ObjectId.parseRef(parser, i);
                            if (bsDictId && parseInfo.parseInfoGetter) {
                                const bsParseInfo = parseInfo.parseInfoGetter(bsDictId.value.id);
                                if (bsParseInfo) {
                                    const bsDict = BorderStyleDict.parse(bsParseInfo);
                                    if (bsDict) {
                                        this.BS = bsDict.value;
                                        i = bsDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /BS value reference");
                        }
                        else if (bsEntryType === valueTypes.DICTIONARY) {
                            const bsDictBounds = parser.getDictBoundsAt(i);
                            if (bsDictBounds) {
                                const bsDict = BorderStyleDict.parse({ parser, bounds: bsDictBounds });
                                if (bsDict) {
                                    this.BS = bsDict.value;
                                    i = bsDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /BS value dictionary");
                        }
                        throw new Error(`Unsupported /BS property value type: ${bsEntryType}`);
                    case "/BE":
                        const beEntryType = parser.getValueTypeAt(i);
                        if (beEntryType === valueTypes.REF) {
                            const bsDictId = ObjectId.parseRef(parser, i);
                            if (bsDictId && parseInfo.parseInfoGetter) {
                                const bsParseInfo = parseInfo.parseInfoGetter(bsDictId.value.id);
                                if (bsParseInfo) {
                                    const bsDict = BorderEffectDict.parse(bsParseInfo);
                                    if (bsDict) {
                                        this.BE = bsDict.value;
                                        i = bsDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /BE value reference");
                        }
                        else if (beEntryType === valueTypes.DICTIONARY) {
                            const bsDictBounds = parser.getDictBoundsAt(i);
                            if (bsDictBounds) {
                                const bsDict = BorderEffectDict.parse({ parser, bounds: bsDictBounds });
                                if (bsDict) {
                                    this.BE = bsDict.value;
                                    i = bsDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /BE value dictionary");
                        }
                        throw new Error(`Unsupported /BE property value type: ${beEntryType}`);
                    case "/AP":
                        const apEntryType = parser.getValueTypeAt(i);
                        if (apEntryType === valueTypes.REF) {
                            const apDictId = ObjectId.parseRef(parser, i);
                            if (apDictId && parseInfo.parseInfoGetter) {
                                const apParseInfo = parseInfo.parseInfoGetter(apDictId.value.id);
                                if (apParseInfo) {
                                    const apDict = AppearanceDict.parse(apParseInfo);
                                    if (apDict) {
                                        this.AP = apDict.value;
                                        i = apDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /AP value reference");
                        }
                        else if (apEntryType === valueTypes.DICTIONARY) {
                            const apDictBounds = parser.getDictBoundsAt(i);
                            if (apDictBounds) {
                                const apDict = AppearanceDict.parse({
                                    parser,
                                    bounds: apDictBounds,
                                    parseInfoGetter: parseInfo.parseInfoGetter,
                                });
                                if (apDict) {
                                    this.AP = apDict.value;
                                    i = apDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /AP value dictionary");
                        }
                        throw new Error(`Unsupported /AP property value type: ${apEntryType}`);
                    case "/AS":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/OC":
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Subtype || !this.Rect) {
            throw new Error("Not all required properties parsed");
        }
        this.$name = ((_a = this.NM) === null || _a === void 0 ? void 0 : _a.literal) || getRandomUuid();
        this.$pageRect = parseInfo.rect;
    }
    getCurrentRotation() {
        var _a;
        const matrix = (_a = this.apStream) === null || _a === void 0 ? void 0 : _a.matrix;
        if (!matrix) {
            return 0;
        }
        const { r } = matrix.getTRS();
        return r;
    }
    getLocalBB() {
        let bBoxLL;
        let bBoxLR;
        let bBoxUR;
        let bBoxUL;
        if (this._bBox) {
            return this._bBox;
        }
        else if (this.apStream) {
            const { ll: apTrBoxLL, lr: apTrBoxLR, ur: apTrBoxUR, ul: apTrBoxUL } = this.apStream.transformedBBox;
            const { min: boxMin, max: boxMax } = vecMinMax(apTrBoxLL, apTrBoxLR, apTrBoxUR, apTrBoxUL);
            const rectMin = new Vec2(this.Rect[0], this.Rect[1]);
            const rectMax = new Vec2(this.Rect[2], this.Rect[3]);
            const mat = mat3From4Vec2(boxMin, boxMax, rectMin, rectMax, true);
            bBoxLL = apTrBoxLL.applyMat3(mat);
            bBoxLR = apTrBoxLR.applyMat3(mat);
            bBoxUR = apTrBoxUR.applyMat3(mat);
            bBoxUL = apTrBoxUL.applyMat3(mat);
        }
        else if (this.Rect) {
            bBoxLL = new Vec2(this.Rect[0], this.Rect[1]);
            bBoxLR = new Vec2(this.Rect[2], this.Rect[1]);
            bBoxUR = new Vec2(this.Rect[2], this.Rect[3]);
            bBoxUL = new Vec2(this.Rect[0], this.Rect[3]);
        }
        else {
            bBoxLL = new Vec2();
            bBoxLR = new Vec2();
            bBoxUR = new Vec2();
            bBoxUL = new Vec2();
        }
        this._bBox = {
            ll: bBoxLL,
            lr: bBoxLR,
            ur: bBoxUR,
            ul: bBoxUL,
        };
        return this._bBox;
    }
    convertClientCoordsToPage(clientX, clientY) {
        const { x, y, width, height } = this._svgBox.getBoundingClientRect();
        const rectMinScaled = new Vec2(x, y);
        const rectMaxScaled = new Vec2(x + width, y + height);
        const pageScale = (rectMaxScaled.x - rectMinScaled.x) / (this.Rect[2] - this.Rect[0]);
        const pageLowerLeft = new Vec2(x - this.Rect[0] * pageScale, y + height + (this.Rect[1] * pageScale));
        const position = new Vec2((clientX - pageLowerLeft.x) / pageScale, (pageLowerLeft.y - clientY) / pageScale);
        return position;
    }
    convertPageCoordsToClient(pageX, pageY) {
        const { x, y, width, height } = this._svgBox.getBoundingClientRect();
        const rectMinScaled = new Vec2(x, y);
        const rectMaxScaled = new Vec2(x + width, y + height);
        const pageScale = (rectMaxScaled.x - rectMinScaled.x) / (this.Rect[2] - this.Rect[0]);
        const pageLowerLeft = new Vec2(x - this.Rect[0] * pageScale, y + height + (this.Rect[1] * pageScale));
        const position = new Vec2(pageLowerLeft.x + (pageX * pageScale), pageLowerLeft.y - (pageY * pageScale));
        return position;
    }
    applyRectTransform(matrix) {
        const dict = this._proxy || this;
        const bBox = dict.getLocalBB();
        bBox.ll.applyMat3(matrix);
        bBox.lr.applyMat3(matrix);
        bBox.ur.applyMat3(matrix);
        bBox.ul.applyMat3(matrix);
        const { min: newRectMin, max: newRectMax } = vecMinMax(bBox.ll, bBox.lr, bBox.ur, bBox.ul);
        dict.Rect = [newRectMin.x, newRectMin.y, newRectMax.x, newRectMax.y];
    }
    applyCommonTransform(matrix) {
        this.applyRectTransform(matrix);
        const dict = this._proxy || this;
        const stream = dict.apStream;
        if (stream) {
            const newApMatrix = Mat3.multiply(stream.matrix, matrix);
            dict.apStream.matrix = newApMatrix;
        }
        dict.M = DateString.fromDate(new Date());
    }
    applyTempTransform() {
        if (this._transformationTimer) {
            clearTimeout(this._transformationTimer);
            this._transformationTimer = null;
            return;
        }
        this._svgContentCopy.remove();
        this._svgContentCopyUse.setAttribute("transform", "matrix(1 0 0 1 0 0)");
        this.applyCommonTransform(this._tempTransformationMatrix);
        this._tempTransformationMatrix.reset();
    }
    renderRect() {
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.classList.add("svg-annot-rect");
        rect.setAttribute("data-annotation-name", this.$name);
        rect.setAttribute("x", this.Rect[0] + "");
        rect.setAttribute("y", this.Rect[1] + "");
        rect.setAttribute("width", this.Rect[2] - this.Rect[0] + "");
        rect.setAttribute("height", this.Rect[3] - this.Rect[1] + "");
        return rect;
    }
    renderBox() {
        const { ll, lr, ur, ul } = this.getLocalBB();
        const boxPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        boxPath.classList.add("svg-annot-box");
        boxPath.setAttribute("data-annotation-name", this.$name);
        boxPath.setAttribute("d", `M ${ll.x} ${ll.y} L ${lr.x} ${lr.y} L ${ur.x} ${ur.y} L ${ul.x} ${ul.y} Z`);
        return boxPath;
    }
    renderMainElement() {
        const mainSvg = document.createElementNS("http://www.w3.org/2000/svg", "g");
        mainSvg.classList.add("svg-annotation");
        mainSvg.setAttribute("data-annotation-name", this.$name);
        mainSvg.addEventListener("pointerdown", this.onSvgPointerDown);
        mainSvg.addEventListener("pointerenter", this.onSvgPointerEnter);
        mainSvg.addEventListener("pointerleave", this.onSvgPointerLeave);
        return mainSvg;
    }
    renderContentCopy() {
        const copy = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const copyDefs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const copySymbol = document.createElementNS("http://www.w3.org/2000/svg", "symbol");
        copySymbol.id = this._svgId + "_symbol";
        const copySymbolUse = document.createElementNS("http://www.w3.org/2000/svg", "use");
        copySymbolUse.setAttribute("href", `#${this._svgId}`);
        if (this.$pageRect) {
            copySymbolUse.setAttribute("viewBox", `${this.$pageRect[0]} ${this.$pageRect[1]} ${this.$pageRect[2]} ${this.$pageRect[3]}`);
        }
        copySymbol.append(copySymbolUse);
        copyDefs.append(copySymbol);
        const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
        use.setAttribute("href", `#${this._svgId}_symbol`);
        use.setAttribute("opacity", "0.2");
        copy.append(copyDefs, use);
        return { copy, use };
    }
    renderApAsync() {
        return __awaiter$7(this, void 0, void 0, function* () {
            const stream = this.apStream;
            if (stream) {
                try {
                    const renderer = new AppearanceStreamRenderer(stream, this.Rect, this.$name);
                    return yield renderer.renderAsync();
                }
                catch (e) {
                    console.log(`Annotation stream render error: ${e.message}`);
                }
            }
            return null;
        });
    }
    renderContent() {
        return null;
    }
    renderScaleHandles() {
        const bBox = this.getLocalBB();
        const handles = [];
        ["ll", "lr", "ur", "ul"].forEach(x => {
            const handle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            handle.classList.add("svg-annot-handle-scale");
            handle.setAttribute("data-handle-name", x);
            handle.setAttribute("cx", bBox[x].x + "");
            handle.setAttribute("cy", bBox[x].y + "");
            handle.addEventListener("pointerdown", this.onScaleHandlePointerDown);
            handles.push(handle);
        });
        return handles;
    }
    renderRotationHandle() {
        const centerX = (this.Rect[0] + this.Rect[2]) / 2;
        const centerY = (this.Rect[1] + this.Rect[3]) / 2;
        const currentRotation = this.getCurrentRotation();
        const rotationGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        rotationGroup.classList.add("svg-annot-rotation");
        rotationGroup.setAttribute("data-handle-name", "center");
        const rotationGroupCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        rotationGroupCircle.classList.add("circle", "dashed");
        rotationGroupCircle.setAttribute("cx", centerX + "");
        rotationGroupCircle.setAttribute("cy", centerY + "");
        const handleMatrix = new Mat3()
            .applyTranslation(-centerX, -centerY + 35)
            .applyRotation(currentRotation)
            .applyTranslation(centerX, centerY);
        const handleCenter = new Vec2(centerX, centerY).applyMat3(handleMatrix);
        const rotationGroupLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        rotationGroupLine.classList.add("dashed");
        rotationGroupLine.setAttribute("x1", centerX + "");
        rotationGroupLine.setAttribute("y1", centerY + "");
        rotationGroupLine.setAttribute("x2", handleCenter.x + "");
        rotationGroupLine.setAttribute("y2", handleCenter.y + "");
        const centerRectHandle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        centerRectHandle.classList.add("svg-annot-handle-rotation");
        centerRectHandle.setAttribute("data-handle-name", "center");
        centerRectHandle.setAttribute("cx", handleCenter.x + "");
        centerRectHandle.setAttribute("cy", handleCenter.y + "");
        centerRectHandle.addEventListener("pointerdown", this.onRotationHandlePointerDown);
        rotationGroup.append(rotationGroupCircle, rotationGroupLine, centerRectHandle);
        return rotationGroup;
    }
    renderHandles() {
        return [...this.renderScaleHandles(), this.renderRotationHandle()];
    }
    updateRenderAsync() {
        return __awaiter$7(this, void 0, void 0, function* () {
            if (!this._svg) {
                return;
            }
            this._svg.innerHTML = "";
            const content = this.renderContent() || (yield this.renderApAsync());
            if (!content) {
                this._svgBox = null;
                this._svgContent = null;
                this._svgContentCopy = null;
                this._svgContentCopyUse = null;
                return;
            }
            content.id = this._svgId;
            content.classList.add("svg-annotation-content");
            content.setAttribute("data-annotation-name", this.$name);
            const { copy, use } = this.renderContentCopy();
            const rect = this.renderRect();
            const box = this.renderBox();
            const handles = this.renderHandles();
            this._svg.append(rect, box, content, ...handles);
            this._svgBox = box;
            this._svgContent = content;
            this._svgContentCopy = copy;
            this._svgContentCopyUse = use;
        });
    }
}

const markupAnnotationReplyTypes = {
    REPLY: "/R",
    GROUP: "/Group",
};
class MarkupAnnotation extends AnnotationDict {
    constructor(subType) {
        super(subType);
        this.RT = markupAnnotationReplyTypes.REPLY;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.T) {
            bytes.push(...encoder.encode("/T "), ...this.T.toArray(cryptInfo));
        }
        if (this.Popup) {
            bytes.push(...encoder.encode("/Popup "), codes.WHITESPACE, ...this.Popup.toArray(cryptInfo));
        }
        if (this.RC) {
            bytes.push(...encoder.encode("/RC "), ...this.RC.toArray(cryptInfo));
        }
        if (this.CA) {
            bytes.push(...encoder.encode("/CA "), ...encoder.encode(" " + this.CA));
        }
        if (this.CreationDate) {
            bytes.push(...encoder.encode("/CreationDate "), ...this.CreationDate.toArray(cryptInfo));
        }
        if (this.Subj) {
            bytes.push(...encoder.encode("/Subj "), ...this.Subj.toArray(cryptInfo));
        }
        if (this.IRT) {
            bytes.push(...encoder.encode("/IRT "), codes.WHITESPACE, ...this.IRT.toArray(cryptInfo));
        }
        if (this.RT) {
            bytes.push(...encoder.encode("/RT "), ...encoder.encode(this.RT));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/T":
                    case "/Subj":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/Popup":
                    case "/IRT":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/RC":
                        const rcEntryType = parser.getValueTypeAt(i);
                        if (rcEntryType === valueTypes.REF) {
                            const rsObjectId = ObjectId.parseRef(parser, i);
                            if (rsObjectId && parseInfo.parseInfoGetter) {
                                const rcParseInfo = parseInfo.parseInfoGetter(rsObjectId.value.id);
                                if (rcParseInfo) {
                                    const rcObjectType = rcParseInfo.type
                                        || rcParseInfo.parser.getValueTypeAt(rcParseInfo.bounds.contentStart);
                                    if (rcObjectType === valueTypes.STRING_LITERAL) {
                                        const popupTextFromIndirectLiteral = LiteralString
                                            .parse(rcParseInfo.parser, rcParseInfo.bounds.contentStart);
                                        if (popupTextFromIndirectLiteral) {
                                            this.RC = popupTextFromIndirectLiteral.value;
                                            i = rsObjectId.end + 1;
                                            break;
                                        }
                                    }
                                    else if (rcObjectType === valueTypes.DICTIONARY) {
                                        const popupTextStream = TextStream.parse(rcParseInfo);
                                        if (popupTextStream) {
                                            const popupTextFromStream = popupTextStream.value.getText();
                                            this.RC = LiteralString.fromString(popupTextFromStream);
                                            i = rsObjectId.end + 1;
                                            break;
                                        }
                                    }
                                    else {
                                        throw new Error(`Unsupported /RC property value type: ${rcObjectType}`);
                                    }
                                }
                            }
                            throw new Error("Can't parse /RC value reference");
                        }
                        else if (rcEntryType === valueTypes.STRING_LITERAL) {
                            const popupTextFromLiteral = LiteralString.parse(parser, i, parseInfo.cryptInfo);
                            if (popupTextFromLiteral) {
                                this.RC = popupTextFromLiteral.value;
                                i = popupTextFromLiteral.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /RC property value");
                        }
                        throw new Error(`Unsupported /RC property value type: ${rcEntryType}`);
                    case "/CA":
                        i = this.parseNumberProp(name, parser, i, true);
                        break;
                    case "/CreationDate":
                        i = this.parseDateProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/RT":
                        const replyType = parser.parseNameAt(i, true);
                        if (replyType && Object.values(markupAnnotationReplyTypes)
                            .includes(replyType.value)) {
                            this.RT = replyType.value;
                            i = replyType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /RT property value");
                        }
                        break;
                    case "/ExData":
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Subtype || !this.Rect) {
            throw new Error("Not all required properties parsed");
        }
    }
    getColorRect() {
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 1;
        if (this.C) {
            if (this.C.length === 1) {
                const gray = this.C[0];
                r = g = b = gray;
            }
            else if (this.C.length === 3) {
                [r, g, b] = this.C;
            }
            else if (this.C.length === 4) {
                const [c, m, y, k] = this.C;
                r = (1 - c) * (1 - k);
                g = (1 - m) * (1 - k);
                b = (1 - y) * (1 - k);
            }
        }
        if (!isNaN(this.CA)) {
            a = this.CA;
        }
        const color = [r, g, b, a];
        return color;
    }
}

class DocumentDataUpdater {
    constructor(sourceBytes, lastXref, referenceData, authResult) {
        this.writeImageXObject = (obj) => {
            const sMask = obj.sMask;
            if (this.isNew(sMask)) {
                const newMaskRef = this.writeIndirectObject(sMask);
                obj.SMask = ObjectId.fromRef(newMaskRef);
            }
            else if (sMask.edited) {
                this.writeUpdatedIndirectObject(sMask);
            }
            if (this.isNew(obj)) {
                return this.writeIndirectObject(obj);
            }
            else if (obj.edited) {
                return this.writeUpdatedIndirectObject(obj);
            }
            else {
                return {
                    id: obj.id,
                    generation: obj.generation,
                    byteOffset: this._refData.getOffset(obj.id)
                };
            }
        };
        this._lastXref = lastXref;
        this._refData = referenceData;
        this._changeData = new ReferenceDataChange(referenceData);
        this._writer = new DataWriter(sourceBytes);
        this._stringCryptor = authResult === null || authResult === void 0 ? void 0 : authResult.stringCryptor;
        this._streamCryptor = authResult === null || authResult === void 0 ? void 0 : authResult.streamCryptor;
    }
    getDataWithUpdatedAnnotations(data) {
        for (const { page, supportedAnnotations: annotations, allAnnotationIds: refArray } of data) {
            if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
                continue;
            }
            for (const annotation of annotations) {
                if (annotation.deleted) {
                    if (!annotation.ref) {
                        continue;
                    }
                    const refIndex = refArray.findIndex(x => x.id === annotation.id);
                    refArray.splice(refIndex, 1);
                    this._changeData.setRefFree(annotation.id);
                    if (annotation instanceof MarkupAnnotation && annotation.Popup) {
                        this._changeData.setRefFree(annotation.Popup.id);
                    }
                }
                else if (!annotation.ref || annotation.edited) {
                    const apStream = annotation.apStream;
                    if (apStream) {
                        this.writeFormXObject(apStream);
                    }
                    if (this.isNew(annotation)) {
                        const newAnnotRef = this.writeIndirectObject(annotation);
                        refArray.push(ObjectId.fromRef(newAnnotRef));
                    }
                    else {
                        this.writeUpdatedIndirectObject(annotation);
                    }
                }
            }
            if (page.Annots instanceof ObjectId
                && this._changeData.isUsedInSource(page.Annots.id)) {
                const annotsRef = {
                    id: page.Annots.id,
                    generation: page.Annots.generation,
                    byteOffset: this._writer.offset
                };
                const annotsCryptInfo = {
                    ref: annotsRef,
                    streamCryptor: this._streamCryptor,
                    stringCryptor: this._stringCryptor,
                };
                this._changeData.updateUsedRef(annotsRef);
                this._writer.writeIndirectArray(annotsCryptInfo, refArray);
            }
            else {
                const newAnnotsRef = this._changeData.takeFreeRef(this._writer.offset, true);
                const annotsCryptInfo = {
                    ref: newAnnotsRef,
                    streamCryptor: this._streamCryptor,
                    stringCryptor: this._stringCryptor,
                };
                this._writer.writeIndirectArray(annotsCryptInfo, refArray);
                page.Annots = ObjectId.fromRef(newAnnotsRef);
            }
            this.writeUpdatedIndirectObject(page);
        }
        this.writeXref();
        const bytes = this._writer.getCurrentData();
        return bytes;
    }
    isNew(obj) {
        return !obj.ref || !this._changeData.isUsedInSource(obj.id);
    }
    writeIndirectObject(obj) {
        const newRef = this._changeData.takeFreeRef(this._writer.offset, true);
        const newObjCryptInfo = {
            ref: newRef,
            streamCryptor: this._streamCryptor,
            stringCryptor: this._stringCryptor,
        };
        this._writer.writeIndirectObject(newObjCryptInfo, obj);
        obj.ref = newRef;
        return newRef;
    }
    writeUpdatedIndirectObject(obj) {
        const objRef = {
            id: obj.id,
            generation: obj.generation,
            byteOffset: this._writer.offset
        };
        const objCryptInfo = {
            ref: objRef,
            streamCryptor: this._streamCryptor,
            stringCryptor: this._stringCryptor,
        };
        this._changeData.updateUsedRef(objRef);
        this._writer.writeIndirectObject(objCryptInfo, obj);
        return objRef;
    }
    writeFormXObject(obj) {
        const resources = obj.Resources;
        if (resources && resources.edited) {
            [...resources.getXObjects()].forEach(([name, xObj]) => {
                if (xObj instanceof ImageStream) {
                    this.writeImageXObject(xObj);
                }
                else if (xObj instanceof XFormStream) {
                    this.writeFormXObject(xObj);
                }
            });
        }
        if (this.isNew(obj)) {
            return this.writeIndirectObject(obj);
        }
        else if (obj.edited) {
            return this.writeUpdatedIndirectObject(obj);
        }
        else {
            return {
                id: obj.id,
                generation: obj.generation,
                byteOffset: this._refData.getOffset(obj.id)
            };
        }
    }
    writeXref() {
        const newXrefOffset = this._writer.offset;
        const newXrefRef = this._changeData.takeFreeRef(newXrefOffset, true);
        const newXrefEntries = this._changeData.exportEntries();
        const newXref = this._lastXref.createUpdate(newXrefEntries, newXrefOffset);
        this._writer.writeIndirectObject({ ref: newXrefRef }, newXref);
        this._writer.writeEof(newXrefOffset);
        return newXrefOffset;
    }
}

function bytesToWordArray(data) {
    return CryptoES.lib.WordArray.create(data);
}
function wordArrayToBytes(wordArray) {
    return int32ArrayToBytes(wordArray.words).slice(0, wordArray.sigBytes);
}
function md5(data) {
    if (data instanceof Uint8Array) {
        data = bytesToWordArray(data);
    }
    const result = CryptoES.MD5(data);
    return result;
}
function rc4(data, key) {
    if (data instanceof Uint8Array) {
        data = bytesToWordArray(data);
    }
    if (key instanceof Uint8Array) {
        key = bytesToWordArray(key);
    }
    const result = CryptoES.RC4.encrypt(data, key).ciphertext;
    return result;
}
function aes(data, key, decrypt = false) {
    if (data instanceof Uint8Array) {
        data = bytesToWordArray(data);
    }
    if (key instanceof Uint8Array) {
        key = bytesToWordArray(key);
    }
    if (decrypt) {
        const ivWordArray = CryptoES.lib.WordArray.create(data.words.slice(0, 4));
        const d = CryptoES.algo.AES.createDecryptor(key, {
            mode: CryptoES.mode.CBC,
            iv: ivWordArray,
            padding: CryptoES.pad.Pkcs7,
        });
        const result = d.finalize(data);
        return result;
    }
    else {
        const ivWordArray = CryptoES.lib.WordArray.random(16);
        const e = CryptoES.algo.AES.createEncryptor(key, {
            mode: CryptoES.mode.CBC,
            iv: ivWordArray,
            padding: CryptoES.pad.Pkcs7,
        });
        const result = e.finalize(data);
        return result;
    }
}

const AESV2_KEY_PADDING = [
    0x73, 0x41, 0x6C, 0x54,
];
class AESV2DataCryptor {
    constructor(key) {
        if (!key) {
            throw new Error("Empty key");
        }
        if (key.length !== 16) {
            throw new Error(`Invalid key length: ${key.length} (shall be 16)`);
        }
        this._n = key.length;
        this._key = key;
        this._tempKey = new Uint8Array(key.length + 9);
    }
    encrypt(data, ref) {
        return this.run(data, ref.id, ref.generation);
    }
    decrypt(data, ref) {
        return this.run(data, ref.id, ref.generation, true);
    }
    run(data, id, generation, decrypt = false) {
        const idBytes = int32ToBytes(id, true);
        const genBytes = int32ToBytes(generation, true);
        this._tempKey.set(this._key, 0);
        this._tempKey.set(idBytes.subarray(0, 3), this._n);
        this._tempKey.set(genBytes.subarray(0, 2), this._n + 3);
        this._tempKey.set(AESV2_KEY_PADDING, this._n + 5);
        const hash = wordArrayToBytes(md5(this._tempKey));
        const n = Math.min(this._n + 5, 16);
        const key = hash.slice(0, n);
        const result = wordArrayToBytes(aes(data, key, decrypt));
        return decrypt
            ? result.slice(16)
            : result;
    }
}

class AESV3DataCryptor {
    constructor(key) {
        if (!key) {
            throw new Error("Empty key");
        }
        if (key.length !== 32) {
            throw new Error(`Invalid key length: ${key.length} (shall be 32)`);
        }
        this._n = key.length;
        this._key = key;
    }
    encrypt(data, ref) {
        return this.run(data, ref.id, ref.generation);
    }
    decrypt(data, ref) {
        return this.run(data, ref.id, ref.generation, true);
    }
    run(data, id, generation, decrypt = false) {
        const result = wordArrayToBytes(aes(data, this._key, decrypt));
        return decrypt
            ? result.slice(16)
            : result;
    }
}

class IdentityDataCryptor {
    constructor() {
    }
    encrypt(data, ref) {
        return data;
    }
    decrypt(data, ref) {
        return data;
    }
}

class RC4DataCryptor {
    constructor(key) {
        if (!key) {
            throw new Error("Empty key");
        }
        if (key.length < 5 || key.length > 16) {
            throw new Error(`Invalid key length: ${key.length} (shall be a multiple of 8 in the range from 40 to 128)`);
        }
        this._n = key.length;
        this._key = key;
        this._tempKey = new Uint8Array(key.length + 5);
    }
    encrypt(data, ref) {
        const idBytes = int32ToBytes(ref.id, true);
        const genBytes = int32ToBytes(ref.generation, true);
        this._tempKey.set(this._key, 0);
        this._tempKey.set(idBytes.slice(0, 3), this._n);
        this._tempKey.set(genBytes.slice(0, 2), this._n + 3);
        const hash = wordArrayToBytes(md5(this._tempKey));
        const n = Math.min(this._n + 5, 16);
        const key = hash.slice(0, n);
        const encrypted = wordArrayToBytes(rc4(data, key));
        return encrypted;
    }
    decrypt(data, ref) {
        return this.encrypt(data, ref);
    }
}

const PASSWORD_32_PADDING = [
    0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41,
    0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,
    0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80,
    0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A,
];
class DataCryptHandler {
    constructor(options, fileId) {
        const { filter, version, revision, permissions, encryptMetadata, keyLength, stringKeyLength, streamKeyLength, stringMethod, streamMethod, oPasswordHash, uPasswordHash, oEncPasswordHash, uEncPasswordHash, perms } = options;
        if (filter !== "/Standard") {
            throw new Error(`Unsupported filter name: ${filter}`);
        }
        if (![1, 2, 4, 5].includes(version)) {
            throw new Error(`Unsupported algorithm version: ${version}`);
        }
        if (![2, 3, 4, 5, 6].includes(revision)) {
            throw new Error(`Unsupported algorithm revision: ${revision}`);
        }
        if (isNaN(permissions)) {
            throw new Error("Permissions not provided");
        }
        if (!oPasswordHash || !uPasswordHash) {
            throw new Error("Password hash not provided");
        }
        this._filter = filter;
        this._version = version;
        this._revision = revision;
        this._permissions = permissions;
        this._keyLength = keyLength;
        this._encryptMetadata = encryptMetadata;
        this._stringKeyLength = stringKeyLength;
        this._streamKeyLength = streamKeyLength;
        this._stringMethod = stringMethod;
        this._streamMethod = streamMethod;
        this._oPasswordHash = oPasswordHash;
        this._uPasswordHash = uPasswordHash;
        this._oEncPasswordHash = oEncPasswordHash;
        this._uEncPasswordHash = uEncPasswordHash;
        this._perms = perms;
        this._fileId = fileId;
    }
    authenticate(password) {
        const version = this._version;
        const stringMethod = this._stringMethod;
        const streamMethod = this._streamMethod;
        let owner = false;
        const ownerAuthenticated = this.authOwnerPassword(password);
        if (ownerAuthenticated) {
            owner = true;
        }
        else {
            const userAuthenticated = this.authUserPassword(password);
            if (!userAuthenticated) {
                return null;
            }
        }
        const key = this._lastEncryptionKey;
        switch (version) {
            case 1:
                const rc4_40 = new RC4DataCryptor(key);
                return {
                    owner,
                    stringCryptor: rc4_40,
                    streamCryptor: rc4_40,
                };
            case 2:
                const rc4_128 = new RC4DataCryptor(key);
                return {
                    owner,
                    stringCryptor: rc4_128,
                    streamCryptor: rc4_128,
                };
            case 4:
                let v4stringCryptor;
                if (!stringMethod || stringMethod === cryptMethods.NONE) {
                    v4stringCryptor = new IdentityDataCryptor();
                }
                else if (stringMethod === cryptMethods.RC4) {
                    v4stringCryptor = new RC4DataCryptor(key);
                }
                else if (stringMethod === cryptMethods.AES_128) {
                    v4stringCryptor = new AESV2DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${stringMethod}`);
                }
                let v4streamCryptor;
                if (!streamMethod || streamMethod === cryptMethods.NONE) {
                    v4streamCryptor = new IdentityDataCryptor();
                }
                else if (streamMethod === cryptMethods.RC4) {
                    v4streamCryptor = new RC4DataCryptor(key);
                }
                else if (streamMethod === cryptMethods.AES_128) {
                    v4streamCryptor = new AESV2DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${streamMethod}`);
                }
                return {
                    owner,
                    stringCryptor: v4stringCryptor,
                    streamCryptor: v4streamCryptor,
                };
            case 5:
                let v5stringCryptor;
                if (!stringMethod || stringMethod === cryptMethods.NONE) {
                    v4stringCryptor = new IdentityDataCryptor();
                }
                else if (stringMethod === cryptMethods.AES_256) {
                    v4stringCryptor = new AESV3DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${stringMethod}`);
                }
                let v5streamCryptor;
                if (!streamMethod || streamMethod === cryptMethods.NONE) {
                    v4streamCryptor = new IdentityDataCryptor();
                }
                else if (streamMethod === cryptMethods.AES_256) {
                    v4streamCryptor = new AESV3DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${streamMethod}`);
                }
                return {
                    owner,
                    stringCryptor: v5stringCryptor,
                    streamCryptor: v5streamCryptor,
                };
        }
    }
    padPassword32(password) {
        if (!password) {
            return new Uint8Array(PASSWORD_32_PADDING);
        }
        const bytes = new TextEncoder().encode(password);
        const padded = new Uint8Array(32);
        padded.set(bytes.slice(0, 32));
        if (bytes.length < 32) {
            padded.set(PASSWORD_32_PADDING.slice(0, 32 - bytes.length), bytes.length);
        }
        return padded;
    }
    computeEncryptionKey(password) {
        if ([2, 3, 4].includes(this._revision)) {
            const paddedPassword = this.padPassword32(password);
            const permissionsLe = int32ToBytes(this._permissions, true);
            const metadata = this._revision >= 4 && !this._encryptMetadata
                ? new Uint8Array([255, 255, 255, 255])
                : new Uint8Array(0);
            const dataToHash = new Uint8Array([
                ...paddedPassword,
                ...this._oPasswordHash,
                ...permissionsLe,
                ...this._fileId,
                ...metadata,
            ]);
            let hash = wordArrayToBytes(md5(dataToHash));
            const keyLength = this._keyLength >> 3;
            if (this._revision >= 3) {
                for (let i = 0; i < 50; i++) {
                    hash = wordArrayToBytes(md5(hash.slice(0, keyLength)));
                }
            }
            const encryptionKey = hash.slice(0, keyLength);
            this._lastEncryptionKey = encryptionKey;
            return encryptionKey;
        }
        else if (this._revision === 5) {
            throw new Error("Not implemented yet");
        }
        else if (this._revision === 6) {
            throw new Error("Not implemented yet");
        }
    }
    computeOHashEncryptionKey_R2R3R4(password) {
        const paddedPassword = this.padPassword32(password);
        let hash = md5(paddedPassword);
        if (this._revision >= 3) {
            for (let i = 0; i < 50; i++) {
                hash = md5(hash);
            }
        }
        const hashArray = wordArrayToBytes(hash);
        const keyLength = this._keyLength >> 3;
        return hashArray.slice(0, keyLength);
    }
    computeOHash_R2R3R4(oPassword, uPassword) {
        const key = this.computeOHashEncryptionKey_R2R3R4(oPassword || uPassword);
        const paddedUPassword = this.padPassword32(uPassword);
        let hash = rc4(paddedUPassword, key);
        if (this._revision >= 3) {
            for (let i = 1; i < 20; i++) {
                hash = rc4(hash, xorBytes(key, i));
            }
        }
        return wordArrayToBytes(hash);
    }
    computeUHash_R2(password) {
        const key = this.computeEncryptionKey(password);
        const padding = new Uint8Array(PASSWORD_32_PADDING);
        const u = wordArrayToBytes(rc4(padding, key));
        return u;
    }
    computeUHash_R3R4(password) {
        const key = this.computeEncryptionKey(password);
        const dataToHash = new Uint8Array([
            ...PASSWORD_32_PADDING,
            ...this._fileId,
        ]);
        let hash = md5(dataToHash);
        hash = rc4(hash, key);
        for (let i = 1; i < 20; i++) {
            hash = rc4(hash, xorBytes(key, i));
        }
        return wordArrayToBytes(hash);
    }
    authOwnerPassword(password) {
        if ([2, 3, 4].includes(this._revision)) {
            const ownerEncryptionKey = this.computeOHashEncryptionKey_R2R3R4(password);
            let userPasswordPadded;
            if (this._revision === 2) {
                userPasswordPadded = wordArrayToBytes(rc4(this._oPasswordHash, ownerEncryptionKey));
            }
            else {
                let hash = bytesToWordArray(this._oPasswordHash);
                for (let i = 19; i >= 0; i--) {
                    hash = rc4(hash, xorBytes(ownerEncryptionKey, i));
                }
                userPasswordPadded = wordArrayToBytes(hash);
            }
            const j = findSubarrayIndex(userPasswordPadded, new Uint8Array(PASSWORD_32_PADDING));
            const userPassword = new TextDecoder().decode(j === -1
                ? userPasswordPadded
                : userPasswordPadded.subarray(0, j));
            return this.authUserPassword(userPassword);
        }
        else if (this._revision === 5) {
            throw new Error("Not implemented yet");
        }
        else if (this._revision === 6) {
            throw new Error("Not implemented yet");
        }
    }
    authUserPassword(password) {
        let u;
        if (this._revision === 2) {
            u = this.computeUHash_R2(password);
            return arraysEqual(this._uPasswordHash, u);
        }
        else if (this._revision === 3 || this._revision === 4) {
            u = this.computeUHash_R3R4(password);
            return arraysEqual(this._uPasswordHash.subarray(0, 16), u);
        }
        else if (this._revision === 5) {
            throw new Error("Not implemented yet");
        }
        else if (this._revision === 6) {
            throw new Error("Not implemented yet");
        }
    }
}

class ObjectStream extends PdfStream {
    constructor() {
        super(streamTypes.OBJECT_STREAM);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ObjectStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getObjectData(id) {
        if (!this._streamData || !this.N || !this.First) {
            return null;
        }
        const parser = new DataParser(this.decodedStreamData);
        const offsetMap = new Map();
        let temp;
        let objectId;
        let byteOffset;
        let position = 0;
        for (let n = 0; n < this.N; n++) {
            temp = parser.parseNumberAt(position, false, false);
            objectId = temp.value;
            position = temp.end + 2;
            temp = parser.parseNumberAt(position, false, false);
            byteOffset = temp.value;
            position = temp.end + 2;
            offsetMap.set(objectId, byteOffset);
        }
        if (!offsetMap.has(id)) {
            return null;
        }
        const objectStart = this.First + offsetMap.get(id);
        const objectType = parser.getValueTypeAt(objectStart);
        if (objectType === null) {
            return;
        }
        let bounds;
        let value;
        switch (objectType) {
            case objectTypes.DICTIONARY:
                bounds = parser.getDictBoundsAt(objectStart, false);
                break;
            case objectTypes.ARRAY:
                bounds = parser.getArrayBoundsAt(objectStart, false);
                break;
            case objectTypes.STRING_LITERAL:
                const literalValue = LiteralString.parse(parser, objectStart);
                if (literalValue) {
                    bounds = { start: literalValue.start, end: literalValue.end };
                    value = literalValue;
                }
                break;
            case objectTypes.STRING_HEX:
                const hexValue = HexString.parse(parser, objectStart);
                if (hexValue) {
                    bounds = { start: hexValue.start, end: hexValue.end };
                    value = hexValue;
                }
                break;
            case objectTypes.NUMBER:
                const numValue = parser.parseNumberAt(objectStart);
                if (numValue) {
                    bounds = { start: numValue.start, end: numValue.end };
                    value = numValue;
                }
                break;
        }
        if (!bounds) {
            return null;
        }
        const bytes = parser.sliceCharCodes(bounds.start, bounds.end);
        if (!bytes.length) {
            throw new Error("Object byte array is empty");
        }
        return {
            parser: new DataParser(bytes),
            bounds: {
                start: 0,
                end: bytes.length - 1,
                contentStart: bounds.contentStart
                    ? bounds.contentStart - bounds.start
                    : undefined,
                contentEnd: bounds.contentEnd
                    ? bytes.length - 1 - (bounds.end - bounds.contentEnd)
                    : undefined,
            },
            type: objectType,
            value,
            cryptInfo: { ref: { id, generation: 0 } },
            streamId: this.id,
        };
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.N) {
            bytes.push(...encoder.encode("/N "), ...encoder.encode(" " + this.N));
        }
        if (this.First) {
            bytes.push(...encoder.encode("/First "), ...encoder.encode(" " + this.First));
        }
        if (this.Extends) {
            bytes.push(...encoder.encode("/Extends "), codes.WHITESPACE, ...this.Extends.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/N":
                    case "/First":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Extends":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class CryptFilterDict extends PdfDict {
    constructor() {
        super(dictTypes.CRYPT_FILTER);
        this.CFM = cryptMethods.NONE;
        this.AuthEvent = authEvents.DOC_OPEN;
        this.Length = 40;
        this.EncryptMetadata = true;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new CryptFilterDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.CFM) {
            bytes.push(...encoder.encode("/CFM "), ...encoder.encode(this.CFM));
        }
        if (this.AuthEvent) {
            bytes.push(...encoder.encode("/AuthEvent "), ...encoder.encode(this.AuthEvent));
        }
        if (this.Length) {
            bytes.push(...encoder.encode("/Length "), ...encoder.encode(" " + this.Length));
        }
        if (this.EncryptMetadata) {
            bytes.push(...encoder.encode("/EncryptMetadata "), ...encoder.encode(" " + this.EncryptMetadata));
        }
        if (this.Recipients) {
            if (this.Recipients instanceof HexString) {
                bytes.push(...encoder.encode("/Recipients "), ...this.Recipients.toArray(cryptInfo));
            }
            else {
                bytes.push(codes.L_BRACKET);
                this.Recipients.forEach(x => bytes.push(...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/CFM":
                        const method = parser.parseNameAt(i, true);
                        if (method && Object.values(cryptMethods)
                            .includes(method.value)) {
                            this.CFM = method.value;
                            i = method.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /CFM property value");
                        }
                        break;
                    case "/AuthEvent":
                        const authEvent = parser.parseNameAt(i, true);
                        if (authEvent && Object.values(authEvents)
                            .includes(authEvent.value)) {
                            this.AuthEvent = authEvent.value;
                            i = authEvent.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /AuthEvent property value");
                        }
                        break;
                    case "/Length":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/EncryptMetadata":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/Recipients":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.STRING_HEX) {
                            const recipient = HexString.parse(parser, i, parseInfo.cryptInfo);
                            if (recipient) {
                                this.Recipients = recipient.value;
                                i = recipient.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        else if (entryType === valueTypes.ARRAY) {
                            const recipients = HexString.parseArray(parser, i);
                            if (recipients) {
                                this.Recipients = recipients.value;
                                i = recipients.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        throw new Error(`Unsupported /Filter property value type: ${entryType}`);
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class CryptMapDict extends PdfDict {
    constructor() {
        super(null);
        this._filtersMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new CryptMapDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getProp(name) {
        return this._filtersMap.get(name);
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this._filtersMap.size) {
            this._filtersMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...v.toArray(cryptInfo)));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    default:
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.DICTIONARY) {
                            const dictBounds = parser.getDictBoundsAt(i);
                            if (dictBounds) {
                                const filter = CryptFilterDict.parse({ parser, bounds: dictBounds });
                                if (filter) {
                                    this._filtersMap.set(name, filter.value);
                                    i = filter.end + 1;
                                    break;
                                }
                            }
                        }
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class EncryptionDict extends PdfDict {
    constructor() {
        super(dictTypes.EMPTY);
        this.Filter = "/Standard";
        this.Length = 40;
        this.StmF = "/Identity";
        this.StrF = "/Identity";
        this.EncryptMetadata = true;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new EncryptionDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Filter) {
            bytes.push(...encoder.encode("/Filter "), ...encoder.encode(this.Filter));
        }
        if (this.SubFilter) {
            bytes.push(...encoder.encode("/SubFilter "), ...encoder.encode(this.SubFilter));
        }
        if (this.V) {
            bytes.push(...encoder.encode("/V "), ...encoder.encode(" " + this.V));
        }
        if (this.Length) {
            bytes.push(...encoder.encode("/Length "), ...encoder.encode(" " + this.Length));
        }
        if (this.CF) {
            bytes.push(...encoder.encode("/CF "), ...this.CF.toArray(cryptInfo));
        }
        if (this.StmF) {
            bytes.push(...encoder.encode("/StmF "), ...encoder.encode(this.StmF));
        }
        if (this.StrF) {
            bytes.push(...encoder.encode("/StrF "), ...encoder.encode(this.StrF));
        }
        if (this.EFF) {
            bytes.push(...encoder.encode("/EFF "), ...encoder.encode(this.EFF));
        }
        if (this.R) {
            bytes.push(...encoder.encode("/R "), ...encoder.encode(" " + this.R));
        }
        if (this.O) {
            bytes.push(...encoder.encode("/O "), ...this.O.toArray(cryptInfo));
        }
        if (this.U) {
            bytes.push(...encoder.encode("/U "), ...this.U.toArray(cryptInfo));
        }
        if (this.OE) {
            bytes.push(...encoder.encode("/OE "), ...this.OE.toArray(cryptInfo));
        }
        if (this.UE) {
            bytes.push(...encoder.encode("/UE "), ...this.UE.toArray(cryptInfo));
        }
        if (this.P) {
            bytes.push(...encoder.encode("/P "), ...encoder.encode(" " + this.P));
        }
        if (this.Perms) {
            bytes.push(...encoder.encode("/Perms "), ...this.Perms.toArray(cryptInfo));
        }
        if (this.U) {
            bytes.push(...encoder.encode("/U "), ...this.U.toArray(cryptInfo));
        }
        if (this.EncryptMetadata) {
            bytes.push(...encoder.encode("/EncryptMetadata "), ...encoder.encode(" " + this.EncryptMetadata));
        }
        if (this.Recipients) {
            if (this.Recipients instanceof HexString) {
                bytes.push(...encoder.encode("/Recipients "), ...this.Recipients.toArray(cryptInfo));
            }
            else {
                bytes.push(codes.L_BRACKET);
                this.Recipients.forEach(x => bytes.push(...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toCryptOptions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!this.V) {
            return null;
        }
        return {
            filter: this.Filter,
            version: this.V,
            revision: this.R,
            permissions: this.P,
            keyLength: this.Length,
            encryptMetadata: this.EncryptMetadata,
            stringKeyLength: (_a = this.stringFilter) === null || _a === void 0 ? void 0 : _a.Length,
            streamKeyLength: (_b = this.streamFilter) === null || _b === void 0 ? void 0 : _b.Length,
            stringMethod: (_c = this.stringFilter) === null || _c === void 0 ? void 0 : _c.CFM,
            streamMethod: (_d = this.streamFilter) === null || _d === void 0 ? void 0 : _d.CFM,
            oPasswordHash: (_e = this.O) === null || _e === void 0 ? void 0 : _e.bytes,
            uPasswordHash: (_f = this.U) === null || _f === void 0 ? void 0 : _f.bytes,
            oEncPasswordHash: (_g = this.OE) === null || _g === void 0 ? void 0 : _g.bytes,
            uEncPasswordHash: (_h = this.UE) === null || _h === void 0 ? void 0 : _h.bytes,
            perms: (_j = this.Perms) === null || _j === void 0 ? void 0 : _j.bytes,
        };
    }
    parseProps(parseInfo) {
        var _a, _b;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Filter":
                    case "/SubFilter":
                    case "/StmF":
                    case "/StrF":
                    case "/EFF":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/V":
                        const algorithm = parser.parseNumberAt(i, false);
                        if (algorithm && Object.values(cryptVersions)
                            .includes(algorithm.value)) {
                            this.V = algorithm.value;
                            i = algorithm.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /V property value");
                        }
                        break;
                    case "/R":
                        const revision = parser.parseNumberAt(i, false);
                        if (revision && Object.values(cryptRevisions)
                            .includes(revision.value)) {
                            this.R = revision.value;
                            i = revision.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /R property value");
                        }
                        break;
                    case "/Length":
                    case "/P":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/O":
                    case "/U":
                    case "/OE":
                    case "/UE":
                    case "/Perms":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/EncryptMetadata":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/CF":
                        const dictBounds = parser.getDictBoundsAt(i);
                        if (bounds) {
                            const cryptMap = CryptMapDict.parse({ parser, bounds: dictBounds });
                            if (cryptMap) {
                                this.CF = cryptMap.value;
                                i = cryptMap.end + 1;
                            }
                        }
                        else {
                            throw new Error("Can't parse /CF property value");
                        }
                        break;
                    case "/Recipients":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.STRING_HEX) {
                            const recipient = HexString.parse(parser, i, parseInfo.cryptInfo);
                            if (recipient) {
                                this.Recipients = recipient.value;
                                i = recipient.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        else if (entryType === valueTypes.ARRAY) {
                            const recipients = HexString.parseArray(parser, i);
                            if (recipients) {
                                this.Recipients = recipients.value;
                                i = recipients.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        throw new Error(`Unsupported /Filter property value type: ${entryType}`);
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Filter) {
            throw new Error("Not all required properties parsed");
        }
        if (this.Filter === "/Standard"
            && (!this.R
                || !this.O
                || !this.U
                || isNaN(this.P)
                || (this.V === 5 && (this.R < 5 || !this.OE || !this.UE || !this.Perms)))) {
            throw new Error("Not all required properties parsed");
        }
        if ((this.SubFilter === "adbe.pkcs7.s3" || this.SubFilter === "adbe.pkcs7.s4")
            && !this.Recipients) {
            throw new Error("Not all required properties parsed");
        }
        if (this.StrF !== "/Identity") {
            this.stringFilter = (_a = this.CF) === null || _a === void 0 ? void 0 : _a.getProp(this.StrF);
        }
        if (this.StmF !== "/Identity") {
            this.streamFilter = (_b = this.CF) === null || _b === void 0 ? void 0 : _b.getProp(this.StmF);
        }
    }
}

class TrailerStream extends PdfStream {
    constructor() {
        super(streamTypes.XREF);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TrailerStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Size) {
            bytes.push(...encoder.encode("/Size "), ...encoder.encode(" " + this.Size));
        }
        if (this.Prev) {
            bytes.push(...encoder.encode("/Prev "), ...encoder.encode(" " + this.Prev));
        }
        if (this.Root) {
            bytes.push(...encoder.encode("/Root "), codes.WHITESPACE, ...this.Root.toArray(cryptInfo));
        }
        if (this.Encrypt) {
            bytes.push(...encoder.encode("/Encrypt "), codes.WHITESPACE, ...this.Encrypt.toArray(cryptInfo));
        }
        if (this.Info) {
            bytes.push(...encoder.encode("/Info "), codes.WHITESPACE, ...this.Info.toArray(cryptInfo));
        }
        if (this.ID) {
            bytes.push(...encoder.encode("/ID "), codes.L_BRACKET, ...this.ID[0].toArray(cryptInfo), ...this.ID[1].toArray(cryptInfo), codes.R_BRACKET);
        }
        if (this.Index) {
            bytes.push(...encoder.encode("/Index "), codes.L_BRACKET);
            this.Index.forEach(x => bytes.push(...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.W) {
            bytes.push(...encoder.encode("/W "), codes.L_BRACKET, ...encoder.encode(this.W[0] + ""), codes.WHITESPACE, ...encoder.encode(this.W[1] + ""), codes.WHITESPACE, ...encoder.encode(this.W[2] + ""), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        var _a;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Size":
                    case "/Prev":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Root":
                    case "/Info":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Encrypt":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.REF) {
                            const encryptId = ObjectId.parseRef(parser, i);
                            if (encryptId) {
                                this.Encrypt = encryptId.value;
                                i = encryptId.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Encrypt property value");
                            }
                        }
                        throw new Error(`Unsupported /Encrypt property value type: ${entryType}`);
                    case "/ID":
                        const ids = HexString.parseArray(parser, i);
                        if (ids) {
                            this.ID = [ids.value[0], ids.value[1]];
                            i = ids.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /ID property value");
                        }
                        break;
                    case "/Index":
                    case "/W":
                        i = this.parseNumberArrayProp(name, parser, i, false);
                        break;
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.W || !this.Size || !this.Root || (this.Encrypt && !this.ID)) {
            throw new Error("Not all required properties parsed");
        }
        if (!((_a = this.Index) === null || _a === void 0 ? void 0 : _a.length)) {
            this.Index = [0, this.Size];
        }
    }
}

class XRef {
    constructor(type) {
        this._type = type;
    }
    get type() {
        return this._type;
    }
    get offset() {
        return this._offset;
    }
}

class XRefStream extends XRef {
    constructor(trailer, offset) {
        super(xRefTypes.STREAM);
        this._trailerStream = trailer;
        this._offset = offset;
    }
    get prev() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Prev;
    }
    get size() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Size;
    }
    get root() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get info() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get encrypt() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Encrypt;
    }
    get id() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.ID;
    }
    static createFrom(base, entries, offset) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !base) {
            return null;
        }
        const entriesSize = Math.max(...entries.map(x => x.id)) + 1;
        const size = Math.max(entriesSize, base.size);
        return XRefStream.create(entries, size, offset, base.root, base.offset, base.info, base.encrypt, base.id);
    }
    static create(entries, size, offset, root, prev, info, encrypt, id) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !size || !offset || !root) {
            return null;
        }
        const trailer = new TrailerStream();
        trailer.Size = size;
        trailer.Root = root;
        trailer.Prev = prev;
        trailer.Info = info;
        trailer.Encrypt = encrypt;
        trailer.ID = id;
        const w = [1, 4, 2];
        const wSum = w[0] + w[1] + w[2];
        const params = new DecodeParamsDict();
        params.setIntProp("/Predictor", flatePredictors.PNG_UP);
        params.setIntProp("/Columns", wSum);
        params.setIntProp("/Colors", 1);
        params.setIntProp("/BitsPerComponent", 8);
        const data = XRefEntry.toStreamBytes(entries, w);
        const stream = new XRefStream(trailer, offset);
        stream._trailerStream.Filter = streamFilters.FLATE;
        stream._trailerStream.DecodeParms = params;
        stream._trailerStream.W = w;
        stream._trailerStream.Index = data.index;
        stream._trailerStream.streamData = data.bytes;
        return stream;
    }
    static parse(parseInfo, offset) {
        if (!parseInfo) {
            return null;
        }
        const trailerStream = TrailerStream.parse(parseInfo);
        if (!trailerStream) {
            return null;
        }
        const xrefStream = new XRefStream(trailerStream.value, offset);
        return {
            value: xrefStream,
            start: null,
            end: null,
        };
    }
    createUpdate(entries, offset) {
        return XRefStream.createFrom(this, entries, offset);
    }
    getEntries() {
        if (!this._trailerStream) {
            return [];
        }
        const entries = XRefEntry.fromStreamBytes(this._trailerStream.decodedStreamData, this._trailerStream.W, this._trailerStream.Index);
        return entries;
    }
    toArray(cryptInfo) {
        return this._trailerStream.toArray(cryptInfo);
    }
}

class TrailerDict extends PdfDict {
    constructor() {
        super(dictTypes.EMPTY);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TrailerDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Size) {
            bytes.push(...encoder.encode("/Size "), ...encoder.encode(" " + this.Size));
        }
        if (this.Prev) {
            bytes.push(...encoder.encode("/Prev "), ...encoder.encode(" " + this.Prev));
        }
        if (this.Root) {
            bytes.push(...encoder.encode("/Root "), codes.WHITESPACE, ...this.Root.toArray(cryptInfo));
        }
        if (this.Encrypt) {
            bytes.push(...encoder.encode("/Encrypt "), codes.WHITESPACE, ...this.Encrypt.toArray(cryptInfo));
        }
        if (this.Info) {
            bytes.push(...encoder.encode("/Info "), codes.WHITESPACE, ...this.Info.toArray(cryptInfo));
        }
        if (this.ID) {
            bytes.push(...encoder.encode("/ID "), codes.L_BRACKET, ...this.ID[0].toArray(cryptInfo), ...this.ID[1].toArray(cryptInfo), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Size":
                    case "/Prev":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Root":
                    case "/Info":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Encrypt":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.REF) {
                            const encryptId = ObjectId.parseRef(parser, i);
                            if (encryptId) {
                                this.Encrypt = encryptId.value;
                                i = encryptId.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Encrypt property value");
                            }
                        }
                        throw new Error(`Unsupported /Encrypt property value type: ${entryType}`);
                    case "/ID":
                        const ids = HexString.parseArray(parser, i);
                        if (ids) {
                            this.ID = [ids.value[0], ids.value[1]];
                            i = ids.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /ID property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Size || !this.Root || (this.Encrypt && !this.ID)) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class XRefTable extends XRef {
    constructor(table, trailer, offset) {
        super(xRefTypes.TABLE);
        this._table = table;
        this._trailerDict = trailer;
        this._offset = offset;
    }
    get prev() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Prev;
    }
    get size() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Size;
    }
    get root() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get info() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get encrypt() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Encrypt;
    }
    get id() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.ID;
    }
    static createFrom(base, entries, offset) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !base) {
            return null;
        }
        const entriesSize = Math.max(...entries.map(x => x.id)) + 1;
        const size = Math.max(entriesSize, base.size);
        return XRefTable.create(entries, size, offset, base.root, base.offset, base.info, base.encrypt, base.id);
    }
    static create(entries, size, offset, root, prev, info, encrypt, id) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !size || !offset || !root) {
            return null;
        }
        const trailer = new TrailerDict();
        trailer.Size = size;
        trailer.Prev = prev;
        trailer.Root = root;
        trailer.Info = info;
        trailer.Encrypt = encrypt;
        trailer.ID = id;
        const data = XRefEntry.toTableBytes(entries);
        const table = new XRefTable(data, trailer, offset);
        return table;
    }
    static parse(parser, start, offset) {
        if (!parser || isNaN(start)) {
            return null;
        }
        const xrefTableBounds = parser.getXrefTableBoundsAt(start);
        if (!xrefTableBounds) {
            return null;
        }
        const trailerDictBounds = parser.getDictBoundsAt(xrefTableBounds.end + 1);
        if (!trailerDictBounds) {
            return null;
        }
        const table = parser.sliceCharCodes(xrefTableBounds.contentStart, xrefTableBounds.contentEnd);
        const trailerDict = TrailerDict.parse({ parser, bounds: trailerDictBounds });
        if (!trailerDict) {
            return null;
        }
        const xrefTable = new XRefTable(table, trailerDict.value, offset);
        return {
            value: xrefTable,
            start: null,
            end: null,
        };
    }
    createUpdate(entries, offset) {
        return XRefTable.createFrom(this, entries, offset);
    }
    getEntries() {
        if (!this._table.length) {
            return [];
        }
        const entries = XRefEntry.fromTableBytes(this._table);
        return entries;
    }
    toArray(cryptInfo) {
        const trailerBytes = this._trailerDict.toArray(cryptInfo);
        const bytes = [
            ...keywordCodes.XREF_TABLE, ...keywordCodes.END_OF_LINE,
            ...this._table,
            ...keywordCodes.TRAILER, ...keywordCodes.END_OF_LINE,
            ...trailerBytes, ...keywordCodes.END_OF_LINE,
        ];
        return new Uint8Array(bytes);
    }
}

class XrefParser {
    constructor(parser) {
        if (!parser) {
            throw new Error("Parser is not defined");
        }
        this._dataParser = parser;
    }
    parseXref(start, max) {
        if (!start) {
            return null;
        }
        const offset = start;
        const xrefTableIndex = this._dataParser.findSubarrayIndex(keywordCodes.XREF_TABLE, { minIndex: start, closedOnly: true });
        if (xrefTableIndex && xrefTableIndex.start === start) {
            const xrefStmIndexProp = this._dataParser.findSubarrayIndex(keywordCodes.XREF_HYBRID, { minIndex: start, maxIndex: max, closedOnly: true });
            if (xrefStmIndexProp) {
                const streamXrefIndex = this._dataParser.parseNumberAt(xrefStmIndexProp.end + 1);
                if (!streamXrefIndex) {
                    return null;
                }
                start = streamXrefIndex.value;
            }
            else {
                const xrefTable = XRefTable.parse(this._dataParser, start, offset);
                return xrefTable === null || xrefTable === void 0 ? void 0 : xrefTable.value;
            }
        }
        const id = ObjectId.parse(this._dataParser, start, false);
        if (!id) {
            return null;
        }
        const xrefStreamBounds = this._dataParser.getIndirectObjectBoundsAt(id.end + 1);
        if (!xrefStreamBounds) {
            return null;
        }
        const xrefStream = XRefStream.parse({ parser: this._dataParser, bounds: xrefStreamBounds }, offset);
        return xrefStream === null || xrefStream === void 0 ? void 0 : xrefStream.value;
    }
    parseAllXrefs(start) {
        const xrefs = [];
        let max = this._dataParser.maxIndex;
        let xref;
        while (start) {
            xref = this.parseXref(start, max);
            if (xref) {
                xrefs.push(xref);
                max = start;
                start = xref.prev;
            }
            else {
                break;
            }
        }
        return xrefs;
    }
}

class CatalogDict extends PdfDict {
    constructor() {
        super(dictTypes.CATALOG);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new CatalogDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Version) {
            bytes.push(...encoder.encode("/Version "), ...encoder.encode(this.Version));
        }
        if (this.Pages) {
            bytes.push(...encoder.encode("/Pages "), codes.WHITESPACE, ...this.Pages.toArray(cryptInfo));
        }
        if (this.Lang) {
            bytes.push(...encoder.encode("/Lang "), ...this.Lang.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Version":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/Pages":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Lang":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Pages) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class PageDict extends PdfDict {
    constructor() {
        super(dictTypes.PAGE);
        this.Rotate = 0;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new PageDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Parent) {
            bytes.push(...encoder.encode("/Parent "), codes.WHITESPACE, ...this.Parent.toArray(cryptInfo));
        }
        if (this.LastModified) {
            bytes.push(...encoder.encode("/LastModified "), ...this.LastModified.toArray(cryptInfo));
        }
        if (this.Resources) {
            bytes.push(...encoder.encode("/Resources "), ...this.Resources);
        }
        if (this.MediaBox) {
            bytes.push(...encoder.encode("/MediaBox "), codes.L_BRACKET, ...encoder.encode(this.MediaBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[3] + ""), codes.R_BRACKET);
        }
        if (this.CropBox) {
            bytes.push(...encoder.encode("/CropBox "), codes.L_BRACKET, ...encoder.encode(this.CropBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.CropBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.CropBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.CropBox[3] + ""), codes.R_BRACKET);
        }
        if (this.BleedBox) {
            bytes.push(...encoder.encode("/BleedBox "), codes.L_BRACKET, ...encoder.encode(this.BleedBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.BleedBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.BleedBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.BleedBox[3] + ""), codes.R_BRACKET);
        }
        if (this.TrimBox) {
            bytes.push(...encoder.encode("/TrimBox "), codes.L_BRACKET, ...encoder.encode(this.TrimBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.TrimBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.TrimBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.TrimBox[3] + ""), codes.R_BRACKET);
        }
        if (this.ArtBox) {
            bytes.push(...encoder.encode("/ArtBox "), codes.L_BRACKET, ...encoder.encode(this.ArtBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.ArtBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.ArtBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.ArtBox[3] + ""), codes.R_BRACKET);
        }
        if (this.Contents) {
            if (this.Contents instanceof ObjectId) {
                bytes.push(...encoder.encode("/Contents "), codes.WHITESPACE, ...this.Contents.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/Contents "), codes.L_BRACKET);
                this.Contents.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        if (this.Rotate) {
            bytes.push(...encoder.encode("/Rotate "), ...encoder.encode(" " + this.Rotate));
        }
        if (this.Thumb) {
            bytes.push(...encoder.encode("/Thumb "), codes.WHITESPACE, ...this.Thumb.toArray(cryptInfo));
        }
        if (this.B) {
            if (this.B instanceof ObjectId) {
                bytes.push(...encoder.encode("/B "), codes.WHITESPACE, ...this.B.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/B "), codes.L_BRACKET);
                this.B.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        if (this.Dur) {
            bytes.push(...encoder.encode("/Dur "), ...encoder.encode(" " + this.Dur));
        }
        if (this.Annots) {
            if (this.Annots instanceof ObjectId) {
                bytes.push(...encoder.encode("/Annots "), codes.WHITESPACE, ...this.Annots.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/Annots "), codes.L_BRACKET);
                this.Annots.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        if (this.Metadata) {
            bytes.push(...encoder.encode("/Metadata "), codes.WHITESPACE, ...this.Metadata.toArray(cryptInfo));
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.ID) {
            bytes.push(...encoder.encode("/ID "), codes.WHITESPACE, ...this.ID.toArray(cryptInfo));
        }
        if (this.PZ) {
            bytes.push(...encoder.encode("/PZ "), ...encoder.encode(" " + this.PZ));
        }
        if (this.Tabs) {
            bytes.push(...encoder.encode("/Tabs "), ...encoder.encode(this.Tabs));
        }
        if (this.TemplateInstantiated) {
            bytes.push(...encoder.encode("/TemplateInstantiated "), ...encoder.encode(this.TemplateInstantiated));
        }
        if (this.UserUnit) {
            bytes.push(...encoder.encode("/UserUnit "), ...encoder.encode(" " + this.UserUnit));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Parent":
                    case "/Thumb":
                    case "/Metadata":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/LastModified":
                        i = this.parseDateProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/Resources":
                        const resEntryType = parser.getValueTypeAt(i);
                        if (resEntryType === valueTypes.REF) {
                            const resDictId = ObjectId.parseRef(parser, i);
                            if (resDictId && parseInfo.parseInfoGetter) {
                                this.Resources = parser.sliceCharCodes(resDictId.start, resDictId.end);
                                i = resDictId.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /Resources value reference");
                        }
                        else if (resEntryType === valueTypes.DICTIONARY) {
                            const resDictBounds = parser.getDictBoundsAt(i);
                            if (resDictBounds) {
                                this.Resources = parser.sliceCharCodes(resDictBounds.start, resDictBounds.end);
                                i = resDictBounds.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /Resources dictionary bounds");
                        }
                        throw new Error(`Unsupported /Resources property value type: ${resEntryType}`);
                    case "/MediaBox":
                    case "/CropBox":
                    case "/BleedBox":
                    case "/TrimBox":
                    case "/ArtBox":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/Contents":
                    case "/B":
                    case "/Annots":
                        const refEntryType = parser.getValueTypeAt(i);
                        if (refEntryType === valueTypes.REF) {
                            const refArrayId = ObjectId.parseRef(parser, i);
                            if (refArrayId) {
                                this[name.slice(1)] = refArrayId.value;
                                i = refArrayId.end + 1;
                                break;
                            }
                        }
                        else if (refEntryType === valueTypes.ARRAY) {
                            const refIds = ObjectId.parseRefArray(parser, i);
                            if (refIds) {
                                this[name.slice(1)] = refIds.value;
                                i = refIds.end + 1;
                                break;
                            }
                        }
                        throw new Error(`Unsupported ${name} property value type: ${refEntryType}`);
                    case "/Rotate":
                    case "/Dur":
                    case "/StructParent":
                    case "/PZ":
                    case "/UserUnit":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/ID":
                        const webCaptureIdEntryType = parser.getValueTypeAt(i);
                        if (webCaptureIdEntryType === valueTypes.REF) {
                            const webCaptureRefId = ObjectId.parseRef(parser, i);
                            if (webCaptureRefId) {
                                if (webCaptureRefId && parseInfo.parseInfoGetter) {
                                    const webCaptureIdParseInfo = parseInfo.parseInfoGetter(webCaptureRefId.value.id);
                                    if (webCaptureIdParseInfo) {
                                        const webCaptureId = HexString.parse(webCaptureIdParseInfo.parser, webCaptureIdParseInfo.bounds.start, webCaptureIdParseInfo.cryptInfo);
                                        if (webCaptureId) {
                                            this.ID = webCaptureId.value;
                                            i = webCaptureRefId.end + 1;
                                            break;
                                        }
                                    }
                                }
                            }
                            throw new Error("Can't parse /ID property value");
                        }
                        else if (webCaptureIdEntryType === valueTypes.STRING_HEX) {
                            const webCaptureId = HexString.parse(parser, i, parseInfo.cryptInfo);
                            if (webCaptureId) {
                                this.ID = webCaptureId.value;
                                i = webCaptureId.end + 1;
                                break;
                            }
                        }
                        throw new Error(`Unsupported /ID property value type: ${webCaptureIdEntryType}`);
                    case "/Tabs":
                    case "/TemplateInstantiated":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Parent) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class PageTreeDict extends PdfDict {
    constructor() {
        super(dictTypes.PAGE_TREE);
        this.Rotate = 0;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new PageTreeDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Parent) {
            bytes.push(...encoder.encode("/Parent "), codes.WHITESPACE, ...this.Parent.toArray(cryptInfo));
        }
        if (this.Kids) {
            bytes.push(...encoder.encode("/Kids "), codes.L_BRACKET);
            this.Kids.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.Count) {
            bytes.push(...encoder.encode("/Count "), ...encoder.encode(" " + this.Count));
        }
        if (this.MediaBox) {
            bytes.push(...encoder.encode("/MediaBox "), codes.L_BRACKET, ...encoder.encode(this.MediaBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[3] + ""), codes.R_BRACKET);
        }
        if (this.Rotate) {
            bytes.push(...encoder.encode("/Rotate "), ...encoder.encode(" " + this.Rotate));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Parent":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Kids":
                        i = this.parseRefArrayProp(name, parser, i);
                        break;
                    case "/Count":
                    case "/Rotate":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/MediaBox":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Kids || isNaN(this.Count)) {
            throw new Error("Not all required properties parsed");
        }
    }
}

const stampTypes = {
    DRAFT: "/Draft",
    NOT_APPROVED: "/NotApproved",
    APPROVED: "/Approved",
    AS_IS: "/AsIs",
    FOR_COMMENT: "/ForComment",
    EXPERIMENTAL: "/Experimental",
    FINAL: "/Final",
    SOLD: "/Sold",
    EXPIRED: "/Expired",
    PUBLIC: "/ForPublicRelease",
    NOT_PUBLIC: "/NotForPublicRelease",
    DEPARTMENTAL: "/Departmental",
    CONFIDENTIAL: "/Confidential",
    SECRET: "/TopSecret",
};
const stampColors = {
    redColor: [0.804, 0, 0],
    greenColor: [0, 0.804, 0],
    blueColor: [0, 0, 0.804],
};
const stampBBox = [0, 0, 440, 120];
const stampRect = [0, 0, 220, 60];
const stampForms = {
    DRAFT: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  150 61 m
  150.047 65.947 149.114 70.413 147.2 74.4 c
  145.287 78.333 142.853 81.373 139.9 83.52 c
  137.68 85.127 135.24 86.263 132.58 86.93 c
  129.92 87.593 126.763 87.957 123.11 88.02 c
  106.91 88.29 l
  106.401 35.19 l
  123.001 34.912 l
  126.734 34.85 129.961 35.165 132.681 35.857 c
  135.394 36.524 137.681 37.507 139.541 38.807 c
  142.721 40.994 145.234 43.974 147.081 47.747 c
  148.941 51.5 149.898 55.934 149.951 61.047 c
  h
  137.8 61.097 m
  137.767 57.597 137.183 54.621 136.05 52.167 c
  134.937 49.687 133.183 47.764 130.79 46.397 c
  129.57 45.731 128.323 45.287 127.05 45.067 c
  125.797 44.827 123.897 44.728 121.35 44.77 c
  118.36 44.82 l
  118.678 78.12 l
  121.668 78.07 l
  124.481 78.023 126.541 77.846 127.848 77.538 c
  129.161 77.207 130.438 76.637 131.678 75.828 c
  133.818 74.362 135.381 72.432 136.368 70.038 c
  137.348 67.618 137.821 64.648 137.788 61.128 c
  f
  185 50 m
  184.987 48.667 184.74 47.53 184.259 46.59 c
  183.778 45.643 182.961 44.907 181.809 44.38 c
  181.002 44.013 180.066 43.802 178.999 43.749 c
  177.932 43.672 176.689 43.645 175.269 43.669 c
  170.989 43.74 l
  171.126 58.04 l
  174.756 57.979 l
  176.643 57.948 178.223 57.814 179.496 57.579 c
  180.769 57.344 181.833 56.837 182.686 56.059 c
  183.499 55.306 184.086 54.486 184.446 53.599 c
  184.827 52.686 185.011 51.483 184.996 49.989 c
  h
  203.8 86.6 m
  189.4 86.841 l
  176.7 67.541 l
  171.25 67.632 l
  171.437 87.132 l
  159.637 87.329 l
  159.128 34.229 l
  178.928 33.897 l
  181.635 33.852 183.965 33.991 185.918 34.315 c
  187.871 34.639 189.705 35.382 191.418 36.545 c
  193.151 37.705 194.531 39.228 195.558 41.115 c
  196.605 42.975 197.141 45.335 197.168 48.195 c
  197.206 52.122 196.446 55.335 194.888 57.835 c
  193.355 60.335 191.138 62.432 188.238 64.125 c
  f
  251 85.8 m
  238.8 86.004 l
  235.53 75.304 l
  218.53 75.588 l
  215.46 86.388 l
  203.56 86.587 l
  219.96 33.187 l
  233.56 32.959 l
  h
  232.6 65.6 m
  226.78 46.6 l
  221.33 65.8 l
  f
  290 42.3 m
  268.9 42.653 l
  268.995 52.543 l
  288.495 52.216 l
  288.593 62.516 l
  269.093 62.843 l
  269.31 85.543 l
  257.51 85.74 l
  257.001 32.64 l
  289.801 32.091 l
  f
  334 41.5 m
  319.7 41.739 l
  320.11 84.639 l
  308.31 84.837 l
  307.9 41.937 l
  293.6 42.176 l
  293.502 31.876 l
  333.902 31.199 l
  f
  `,
    APPROVED: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  88.9 86.4 m
  78 86.585 l
  75.08 76.895 l
  59.88 77.153 l
  57.14 86.933 l
  46.54 87.114 l
  61.24 38.714 l
  73.34 38.508 l
  h
  72.4 68.1 m
  67.21 50.9 l
  62.35 68.3 l
  f
  128 52.8 m
  128.02 54.953 127.72 57.073 127.098 59.16 c
  126.477 61.22 125.577 62.96 124.398 64.38 c
  122.785 66.307 120.975 67.77 118.968 68.77 c
  116.981 69.777 114.495 70.303 111.508 70.35 c
  104.938 70.462 l
  105.086 86.162 l
  94.586 86.341 l
  94.132 38.141 l
  111.532 37.846 l
  114.132 37.802 116.322 38.034 118.102 38.543 c
  119.902 39.03 121.492 39.79 122.872 40.823 c
  124.532 42.07 125.802 43.676 126.682 45.643 c
  127.582 47.61 128.045 49.986 128.072 52.773 c
  h
  117.1 53.276 m
  117.087 51.916 116.765 50.756 116.133 49.796 c
  115.501 48.816 114.771 48.139 113.943 47.766 c
  112.836 47.267 111.763 47.005 110.723 46.98 c
  109.676 46.933 108.283 46.924 106.543 46.954 c
  104.733 46.985 l
  104.869 61.385 l
  107.889 61.333 l
  109.682 61.303 111.156 61.149 112.309 60.87 c
  113.476 60.592 114.449 60.058 115.229 59.27 c
  115.902 58.57 116.379 57.744 116.659 56.79 c
  116.961 55.817 117.106 54.64 117.093 53.26 c
  f
  170 52.1 m
  170.02 54.253 169.72 56.373 169.098 58.46 c
  168.477 60.52 167.577 62.26 166.398 63.68 c
  164.785 65.607 162.975 67.07 160.968 68.07 c
  158.981 69.077 156.495 69.603 153.508 69.65 c
  146.938 69.762 l
  147.086 85.462 l
  136.586 85.641 l
  136.132 37.441 l
  153.532 37.146 l
  156.132 37.102 158.322 37.334 160.102 37.843 c
  161.902 38.33 163.492 39.09 164.872 40.123 c
  166.532 41.37 167.802 42.976 168.682 44.943 c
  169.582 46.91 170.045 49.286 170.072 52.073 c
  h
  159.1 52.576 m
  159.087 51.216 158.765 50.056 158.133 49.096 c
  157.501 48.116 156.771 47.439 155.943 47.066 c
  154.836 46.567 153.763 46.305 152.723 46.28 c
  151.676 46.233 150.283 46.224 148.543 46.254 c
  146.733 46.285 l
  146.869 60.685 l
  149.889 60.633 l
  151.682 60.603 153.156 60.449 154.309 60.17 c
  155.476 59.892 156.449 59.358 157.229 58.57 c
  157.902 57.87 158.379 57.044 158.659 56.09 c
  158.961 55.117 159.106 53.94 159.093 52.56 c
  f
  200 51.1 m
  199.989 49.893 199.768 48.863 199.339 48.01 c
  198.91 47.157 198.18 46.49 197.149 46.01 c
  196.429 45.677 195.592 45.487 194.639 45.438 c
  193.686 45.368 192.576 45.344 191.309 45.365 c
  187.489 45.43 l
  187.611 58.43 l
  190.851 58.375 l
  192.538 58.346 193.948 58.225 195.081 58.012 c
  196.214 57.799 197.161 57.342 197.921 56.642 c
  198.648 55.962 199.171 55.219 199.491 54.412 c
  199.831 53.585 199.995 52.492 199.982 51.132 c
  h
  216.8 84.2 m
  203.9 84.419 l
  192.6 66.919 l
  187.74 67.002 l
  187.906 84.702 l
  177.406 84.88 l
  176.952 36.68 l
  194.652 36.379 l
  197.072 36.338 199.152 36.464 200.892 36.758 c
  202.632 37.052 204.269 37.725 205.802 38.778 c
  207.349 39.831 208.579 41.211 209.492 42.918 c
  210.425 44.604 210.902 46.741 210.922 49.328 c
  210.956 52.888 210.279 55.801 208.892 58.068 c
  207.519 60.334 205.539 62.234 202.952 63.768 c
  f
  261 59.4 m
  261.073 67.067 259.263 73.2 255.57 77.8 c
  251.877 82.373 246.743 84.713 240.17 84.82 c
  233.597 84.932 228.43 82.765 224.67 78.32 c
  220.89 73.853 218.963 67.787 218.89 60.12 c
  218.817 52.387 220.627 46.253 224.32 41.72 c
  228.013 37.147 233.147 34.807 239.72 34.7 c
  246.273 34.589 251.44 36.755 255.22 41.2 c
  259.013 45.62 260.947 51.687 261.02 59.4 c
  h
  247.1 71.8 m
  248.113 70.313 248.857 68.577 249.33 66.59 c
  249.805 64.577 250.03 62.223 250.005 59.53 c
  249.978 56.643 249.671 54.19 249.084 52.17 c
  248.497 50.15 247.741 48.523 246.814 47.29 c
  245.867 46.01 244.777 45.09 243.544 44.53 c
  242.331 43.968 241.064 43.698 239.744 43.721 c
  238.404 43.744 237.144 44.045 235.964 44.626 c
  234.797 45.207 233.724 46.153 232.744 47.466 c
  231.837 48.686 231.101 50.369 230.534 52.516 c
  229.986 54.636 229.725 57.099 229.752 59.906 c
  229.779 62.773 230.077 65.216 230.645 67.236 c
  231.232 69.229 231.988 70.856 232.915 72.116 c
  233.842 73.376 234.922 74.296 236.155 74.876 c
  237.388 75.459 238.682 75.739 240.035 75.716 c
  241.388 75.693 242.675 75.369 243.895 74.745 c
  245.115 74.099 246.178 73.122 247.085 71.815 c
  f
  306 34.6 m
  291.5 83 l
  279.7 83.201 l
  264.3 35.301 l
  275.4 35.113 l
  285.6 68.813 l
  295.17 34.813 l
  f
  342 82.1 m
  312.4 82.603 l
  311.946 34.403 l
  341.546 33.9 l
  341.634 43.22 l
  322.534 43.544 l
  322.612 51.854 l
  340.312 51.553 l
  340.4 60.873 l
  322.7 61.174 l
  322.812 73.074 l
  341.912 72.75 l
  f
  389 57.3 m
  389.042 61.787 388.209 65.82 386.5 69.4 c
  384.793 72.967 382.62 75.72 379.98 77.66 c
  378 79.12 375.82 80.15 373.44 80.75 c
  371.067 81.351 368.25 81.68 364.99 81.735 c
  350.59 81.98 l
  350.136 33.78 l
  364.936 33.528 l
  368.269 33.471 371.146 33.757 373.566 34.384 c
  375.993 34.99 378.033 35.883 379.686 37.064 c
  382.526 39.044 384.769 41.744 386.416 45.164 c
  388.076 48.564 388.929 52.597 388.976 57.264 c
  h
  378.1 57.388 m
  378.07 54.222 377.55 51.525 376.54 49.298 c
  375.547 47.052 373.983 45.308 371.85 44.068 c
  370.763 43.461 369.65 43.058 368.51 42.858 c
  367.39 42.64 365.693 42.551 363.42 42.589 c
  360.76 42.634 l
  361.044 72.734 l
  363.704 72.689 l
  366.211 72.647 368.051 72.486 369.224 72.207 c
  370.391 71.907 371.531 71.391 372.644 70.657 c
  374.557 69.331 375.951 67.581 376.824 65.407 c
  377.704 63.214 378.127 60.521 378.094 57.327 c
  f
  `,
    NOT_APPROVED: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  57.1 85.5 m
  49.12 85.636 l
  35.32 55.036 l
  35.469 85.936 l
  27.879 86.066 l
  27.662 41.066 l
  37.562 40.897 l
  49.362 66.497 l
  49.238 40.697 l
  56.828 40.567 l
  f
  96.4 62.4 m
  96.435 69.533 94.995 75.267 92.08 79.6 c
  89.167 83.86 85.133 86.033 79.98 86.12 c
  74.82 86.208 70.753 84.175 67.78 80.02 c
  64.827 75.84 63.333 70.173 63.3 63.02 c
  63.265 55.82 64.705 50.087 67.62 45.82 c
  70.533 41.56 74.567 39.387 79.72 39.3 c
  84.867 39.212 88.933 41.245 91.92 45.4 c
  94.887 49.533 96.387 55.2 96.42 62.4 c
  h
  85.5 74 m
  86.3 72.62 86.89 71 87.27 69.14 c
  87.649 67.26 87.833 65.063 87.82 62.55 c
  87.807 59.85 87.573 57.56 87.118 55.68 c
  86.663 53.793 86.073 52.273 85.348 51.12 c
  84.608 49.927 83.755 49.067 82.788 48.54 c
  81.835 48.013 80.841 47.758 79.808 47.776 c
  78.761 47.794 77.771 48.073 76.838 48.612 c
  75.918 49.151 75.075 50.031 74.308 51.252 c
  73.595 52.392 73.011 53.962 72.558 55.962 c
  72.122 57.942 71.91 60.242 71.923 62.862 c
  71.936 65.542 72.163 67.822 72.603 69.702 c
  73.058 71.569 73.648 73.089 74.373 74.262 c
  75.1 75.435 75.946 76.295 76.913 76.842 c
  77.88 77.389 78.893 77.654 79.953 77.635 c
  81.02 77.617 82.033 77.318 82.993 76.738 c
  83.953 76.138 84.79 75.228 85.503 74.008 c
  f
  128 48 m
  118 48.172 l
  118.175 84.472 l
  109.895 84.614 l
  109.72 48.314 l
  99.72 48.486 l
  99.678 39.786 l
  127.978 39.301 l
  f
  178 83.4 m
  169.44 83.546 l
  167.18 74.496 l
  155.28 74.7 l
  153.1 83.83 l
  144.76 83.973 l
  156.36 38.773 l
  165.89 38.61 l
  h
  165.1 66.3 m
  161.08 50.2 l
  157.21 66.4 l
  f
  209 52.1 m
  209.01 54.113 208.768 56.09 208.274 58.03 c
  207.78 59.95 207.07 61.573 206.144 62.9 c
  204.871 64.693 203.447 66.057 201.874 66.99 c
  200.314 67.923 198.361 68.41 196.014 68.45 c
  190.864 68.538 l
  190.935 83.138 l
  182.655 83.28 l
  182.438 38.28 l
  196.038 38.047 l
  198.078 38.012 199.798 38.235 201.198 38.714 c
  202.611 39.173 203.858 39.886 204.938 40.854 c
  206.238 42.021 207.231 43.524 207.918 45.364 c
  208.618 47.204 208.974 49.421 208.988 52.014 c
  h
  200.44 52.518 m
  200.434 51.251 200.184 50.168 199.691 49.268 c
  199.198 48.348 198.628 47.715 197.981 47.368 c
  197.114 46.9 196.271 46.653 195.451 46.626 c
  194.631 46.58 193.538 46.568 192.171 46.592 c
  190.751 46.616 l
  190.816 60.116 l
  193.186 60.075 l
  194.593 60.051 195.749 59.911 196.656 59.653 c
  197.576 59.396 198.343 58.899 198.956 58.163 c
  199.485 57.51 199.861 56.74 200.086 55.853 c
  200.326 54.947 200.443 53.847 200.437 52.553 c
  f
  241 51.6 m
  241.01 53.613 240.768 55.59 240.274 57.53 c
  239.78 59.45 239.07 61.073 238.144 62.4 c
  236.871 64.193 235.447 65.557 233.874 66.49 c
  232.314 67.423 230.361 67.91 228.014 67.95 c
  222.864 68.038 l
  222.935 82.638 l
  214.655 82.78 l
  214.438 37.78 l
  228.038 37.547 l
  230.078 37.512 231.798 37.735 233.198 38.214 c
  234.611 38.673 235.858 39.386 236.938 40.354 c
  238.238 41.521 239.231 43.024 239.918 44.864 c
  240.618 46.704 240.974 48.921 240.988 51.514 c
  h
  232.44 52.018 m
  232.434 50.751 232.184 49.668 231.691 48.768 c
  231.198 47.848 230.628 47.215 229.981 46.868 c
  229.114 46.4 228.271 46.153 227.451 46.126 c
  226.631 46.08 225.538 46.068 224.171 46.092 c
  222.751 46.116 l
  222.816 59.616 l
  225.186 59.575 l
  226.593 59.551 227.749 59.411 228.656 59.153 c
  229.576 58.896 230.343 58.399 230.956 57.663 c
  231.485 57.01 231.861 56.24 232.086 55.353 c
  232.326 54.447 232.443 53.347 232.437 52.053 c
  f
  265 50.7 m
  264.995 49.573 264.825 48.61 264.49 47.81 c
  264.155 47.01 263.585 46.387 262.78 45.94 c
  262.218 45.627 261.565 45.447 260.82 45.4 c
  260.073 45.332 259.203 45.307 258.21 45.324 c
  255.21 45.375 l
  255.269 57.475 l
  257.809 57.432 l
  259.129 57.409 260.235 57.299 261.129 57.103 c
  262.022 56.906 262.769 56.479 263.369 55.823 c
  263.941 55.189 264.354 54.499 264.609 53.753 c
  264.878 52.986 265.01 51.966 265.004 50.693 c
  h
  278.1 81.7 m
  268 81.873 l
  259.17 65.573 l
  255.35 65.638 l
  255.43 82.138 l
  247.19 82.279 l
  246.973 37.279 l
  260.873 37.041 l
  262.773 37.009 264.406 37.132 265.773 37.41 c
  267.139 37.689 268.423 38.322 269.623 39.31 c
  270.836 40.297 271.799 41.59 272.513 43.19 c
  273.239 44.77 273.609 46.767 273.623 49.18 c
  273.639 52.5 273.099 55.217 272.003 57.33 c
  270.923 59.444 269.366 61.21 267.333 62.63 c
  f
  313 58.7 m
  313.035 65.833 311.595 71.567 308.68 75.9 c
  305.767 80.16 301.733 82.333 296.58 82.42 c
  291.42 82.508 287.353 80.475 284.38 76.32 c
  281.427 72.14 279.933 66.473 279.9 59.32 c
  279.865 52.12 281.305 46.387 284.22 42.12 c
  287.133 37.86 291.167 35.687 296.32 35.6 c
  301.467 35.512 305.533 37.545 308.52 41.7 c
  311.487 45.833 312.987 51.5 313.02 58.7 c
  h
  302.1 70.3 m
  302.9 68.92 303.49 67.3 303.87 65.44 c
  304.249 63.56 304.433 61.363 304.42 58.85 c
  304.407 56.15 304.173 53.86 303.718 51.98 c
  303.263 50.093 302.673 48.573 301.948 47.42 c
  301.208 46.227 300.355 45.367 299.388 44.84 c
  298.435 44.313 297.441 44.058 296.408 44.076 c
  295.361 44.094 294.371 44.373 293.438 44.912 c
  292.518 45.451 291.675 46.331 290.908 47.552 c
  290.195 48.692 289.611 50.262 289.158 52.262 c
  288.722 54.242 288.51 56.542 288.523 59.162 c
  288.536 61.842 288.763 64.122 289.203 66.002 c
  289.658 67.869 290.248 69.389 290.973 70.562 c
  291.7 71.735 292.546 72.595 293.513 73.142 c
  297.62 73.917 298.633 73.618 299.593 73.038 c
  300.553 72.438 301.39 71.528 302.103 70.308 c
  f
  348 35.6 m
  336.5 80.8 l
  327.23 80.959 l
  315.33 36.159 l
  324.02 36.01 l
  331.93 67.41 l
  339.54 35.71 l
  f
  376 80 m
  352.8 80.397 l
  352.583 35.397 l
  375.783 35 l
  375.825 43.7 l
  360.825 43.956 l
  360.863 51.716 l
  374.762 51.478 l
  374.804 60.178 l
  360.904 60.416 l
  360.958 71.516 l
  375.958 71.26 l
  f
  413 57 m
  413.02 61.187 412.357 64.953 411.01 68.3 c
  409.663 71.627 407.95 74.193 405.87 76 c
  404.31 77.353 402.597 78.31 400.73 78.87 c
  398.863 79.425 396.65 79.725 394.09 79.769 c
  382.79 79.963 l
  382.573 34.963 l
  394.173 34.764 l
  396.786 34.719 399.043 34.993 400.943 35.584 c
  402.843 36.155 404.443 36.992 405.743 38.094 c
  407.963 39.947 409.713 42.474 410.993 45.674 c
  412.286 48.854 412.943 52.621 412.963 56.974 c
  h
  404.44 57.056 m
  404.426 54.096 404.026 51.576 403.24 49.496 c
  402.467 47.396 401.243 45.766 399.57 44.606 c
  398.717 44.037 397.847 43.66 396.96 43.476 c
  396.08 43.269 394.75 43.181 392.97 43.212 c
  390.88 43.248 l
  391.016 71.348 l
  393.106 71.312 l
  395.073 71.278 396.516 71.133 397.436 70.876 c
  398.356 70.599 399.253 70.122 400.126 69.446 c
  401.626 68.213 402.726 66.583 403.426 64.556 c
  404.119 62.509 404.459 59.996 404.446 57.016 c
  f
  `,
    DEPARTMENTAL: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  56.4 63.1 m
  56.412 67.46 55.746 71.393 54.4 74.9 c
  53.06 78.36 51.36 81.03 49.3 82.91 c
  47.753 84.317 46.053 85.31 44.2 85.89 c
  26.42 86.996 l
  26.286 40.196 l
  37.786 40.009 l
  40.379 39.967 42.616 40.256 44.496 40.875 c
  46.376 41.474 47.959 42.35 49.246 43.505 c
  51.446 45.438 53.176 48.072 54.436 51.405 c
  55.709 54.718 56.353 58.652 56.366 63.205 c
  h
  47.92 63.143 m
  47.911 60.063 47.518 57.437 46.74 55.263 c
  45.98 53.077 44.773 51.377 43.12 50.163 c
  42.28 49.569 41.417 49.175 40.53 48.983 c
  39.663 48.767 38.347 48.673 36.58 48.701 c
  34.51 48.735 l
  34.594 78.035 l
  36.664 78.001 l
  38.617 77.97 40.047 77.821 40.954 77.554 c
  41.867 77.267 42.757 76.77 43.624 76.064 c
  45.117 74.784 46.207 73.088 46.894 70.974 c
  47.587 68.848 47.927 66.231 47.914 63.124 c
  f
  85.8 86 m
  62.8 86.373 l
  62.666 39.573 l
  85.666 39.2 l
  85.692 48.26 l
  70.892 48.501 l
  70.915 56.581 l
  84.715 56.357 l
  84.741 65.417 l
  70.941 65.641 l
  70.974 77.241 l
  85.774 77 l
  f
  119 53.4 m
  119.006 55.493 118.763 57.553 118.27 59.58 c
  117.777 61.58 117.071 63.27 116.15 64.65 c
  114.89 66.517 113.477 67.933 111.91 68.9 c
  110.363 69.867 108.43 70.37 106.11 70.41 c
  101.01 70.493 l
  101.054 85.793 l
  92.854 85.926 l
  92.72 39.126 l
  106.22 38.907 l
  108.24 38.874 109.943 39.108 111.33 39.61 c
  112.723 40.091 113.956 40.837 115.03 41.85 c
  116.316 43.063 117.296 44.63 117.97 46.55 c
  118.656 48.47 119.003 50.78 119.01 53.48 c
  h
  110.52 53.821 m
  110.516 52.501 110.271 51.374 109.784 50.441 c
  109.297 49.488 108.734 48.824 108.094 48.451 c
  107.241 47.962 106.407 47.703 105.594 47.674 c
  104.781 47.624 103.697 47.61 102.344 47.632 c
  100.934 47.655 l
  100.974 61.655 l
  103.324 61.617 l
  104.717 61.595 105.864 61.45 106.764 61.184 c
  107.677 60.918 108.437 60.401 109.044 59.634 c
  109.569 58.954 109.945 58.151 110.174 57.224 c
  110.413 56.278 110.531 55.134 110.527 53.794 c
  f
  154 84.9 m
  145.52 85.038 l
  143.29 75.608 l
  131.49 75.799 l
  129.32 85.299 l
  121.06 85.433 l
  132.66 38.433 l
  142.1 38.28 l
  h
  141.3 67.1 m
  137.34 50.4 l
  133.48 67.3 l
  f
  176 52 m
  175.997 50.827 175.83 49.823 175.5 48.99 c
  175.17 48.157 174.607 47.507 173.81 47.04 c
  173.254 46.713 172.604 46.525 171.86 46.474 c
  171.12 46.402 170.26 46.374 169.28 46.39 c
  166.31 46.438 l
  166.346 59.038 l
  168.866 58.998 l
  170.173 58.976 171.269 58.864 172.156 58.662 c
  173.036 58.458 173.776 58.015 174.376 57.332 c
  174.943 56.672 175.353 55.952 175.606 55.172 c
  175.874 54.372 176.006 53.312 176.003 51.992 c
  h
  188.9 84.3 m
  178.9 84.463 l
  170.18 67.463 l
  166.4 67.524 l
  166.449 84.724 l
  158.289 84.856 l
  158.155 38.056 l
  171.955 37.833 l
  173.835 37.803 175.452 37.934 176.805 38.226 c
  178.158 38.519 179.428 39.179 180.615 40.206 c
  181.815 41.233 182.765 42.58 183.465 44.246 c
  184.178 45.893 184.542 47.973 184.555 50.486 c
  184.565 53.946 184.025 56.776 182.935 58.976 c
  181.862 61.176 180.315 63.016 178.295 64.496 c
  f
  218 46.1 m
  208.07 46.261 l
  208.178 84.061 l
  199.978 84.194 l
  199.87 46.394 l
  189.94 46.555 l
  189.914 37.495 l
  218.014 37.039 l
  f
  256 83.2 m
  247.84 83.332 l
  247.75 51.932 l
  241.91 72.332 l
  236.25 72.424 l
  230.3 52.124 l
  230.39 83.524 l
  222.66 83.65 l
  222.526 36.85 l
  232.046 36.695 l
  239.266 60.095 l
  246.336 36.495 l
  255.856 36.34 l
  f
  287 82.7 m
  264 83.073 l
  263.866 36.273 l
  286.866 35.9 l
  286.892 44.96 l
  272.092 45.201 l
  272.115 53.281 l
  285.915 53.057 l
  285.941 62.117 l
  272.141 62.341 l
  272.174 73.941 l
  286.974 73.7 l
  f
  323 82.2 m
  315.1 82.328 l
  301.5 50.428 l
  301.592 82.528 l
  294.072 82.65 l
  293.938 35.85 l
  303.738 35.691 l
  315.438 62.291 l
  315.361 35.491 l
  322.881 35.369 l
  f
  356 43.9 m
  346.07 44.061 l
  346.178 81.861 l
  337.978 81.994 l
  337.87 44.194 l
  327.94 44.355 l
  327.914 35.295 l
  356.014 34.839 l
  f
  390 81.1 m
  381.52 81.238 l
  379.29 71.808 l
  367.49 71.999 l
  365.32 81.499 l
  357.06 81.633 l
  368.66 34.633 l
  378.1 34.48 l
  h
  377.3 63.3 m
  373.34 46.6 l
  369.48 63.5 l
  f
  418 80.6 m
  395.1 80.972 l
  394.966 34.172 l
  403.166 34.039 l
  403.274 71.839 l
  417.974 71.6 l
  f
  `,
    CONFIDENTIAL: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  48 86.5 m
  45.613 86.541 43.403 86.084 41.37 85.13 c
  39.35 84.177 37.61 82.737 36.15 80.81 c
  34.69 78.883 33.55 76.467 32.73 73.56 c
  31.923 70.653 31.513 67.287 31.5 63.46 c
  31.483 59.9 31.849 56.663 32.6 53.75 c
  33.347 50.837 34.44 48.333 35.88 46.24 c
  37.267 44.227 38.983 42.657 41.03 41.53 c
  43.097 40.41 45.35 39.827 47.79 39.78 c
  49.143 39.757 50.36 39.847 51.44 40.05 c
  52.533 40.233 53.54 40.487 54.46 40.814 c
  55.427 41.18 56.297 41.597 57.07 42.064 c
  57.863 42.513 58.557 42.933 59.15 43.324 c
  59.203 54.224 l
  58.254 54.24 l
  57.849 53.764 57.336 53.201 56.714 52.55 c
  56.107 51.896 55.414 51.253 54.634 50.62 c
  53.84 49.99 52.984 49.46 52.064 49.03 c
  51.144 48.603 50.157 48.398 49.104 48.416 c
  47.937 48.436 46.83 48.717 45.784 49.258 c
  44.737 49.78 43.77 50.643 42.884 51.848 c
  42.044 53.008 41.36 54.538 40.834 56.438 c
  40.326 58.338 40.078 60.638 40.091 63.338 c
  40.104 66.158 40.396 68.508 40.966 70.388 c
  41.55 72.268 42.276 73.745 43.146 74.818 c
  44.026 75.912 45.006 76.692 46.086 77.158 c
  47.166 77.603 48.229 77.816 49.276 77.798 c
  50.282 77.781 51.272 77.553 52.246 77.113 c
  53.232 76.674 54.142 76.084 54.976 75.343 c
  55.676 74.747 56.326 74.111 56.926 73.433 c
  57.526 72.76 58.02 72.177 58.406 71.683 c
  59.268 71.668 l
  59.32 82.368 l
  58.52 82.885 57.753 83.372 57.02 83.828 c
  56.286 84.284 55.52 84.68 54.72 85.018 c
  53.673 85.459 52.69 85.799 51.77 86.038 c
  f
  96.6 62.3 m
  96.635 69.433 95.195 75.167 92.28 79.5 c
  89.367 83.76 85.333 85.933 80.18 86.02 c
  75.02 86.108 70.953 84.075 67.98 79.92 c
  65.027 75.74 63.533 70.073 63.5 62.92 c
  63.465 55.72 64.905 49.987 67.82 45.72 c
  70.733 41.46 74.767 39.287 79.92 39.2 c
  85.067 39.112 89.133 41.145 92.12 45.3 c
  95.087 49.433 96.587 55.1 96.62 62.3 c
  h
  85.7 73.9 m
  86.5 72.52 87.09 70.9 87.47 69.04 c
  87.849 67.16 88.033 64.963 88.02 62.45 c
  88.007 59.75 87.773 57.46 87.318 55.58 c
  86.863 53.693 86.273 52.173 85.548 51.02 c
  84.808 49.827 83.955 48.967 82.988 48.44 c
  82.035 47.913 81.041 47.658 80.008 47.676 c
  78.961 47.694 77.971 47.973 77.038 48.512 c
  76.118 49.051 75.275 49.931 74.508 51.152 c
  73.795 52.292 73.211 53.862 72.758 55.862 c
  72.322 57.842 72.11 60.142 72.123 62.762 c
  72.136 65.442 72.363 67.722 72.803 69.602 c
  73.258 71.469 73.848 72.989 74.573 74.162 c
  75.3 75.335 76.146 76.195 77.113 76.742 c
  78.08 77.289 79.093 77.554 80.153 77.535 c
  81.22 77.517 82.233 77.218 83.193 76.638 c
  84.153 76.038 84.99 75.128 85.703 73.908 c
  f
  132 84.2 m
  124.02 84.336 l
  110.22 53.736 l
  110.369 84.636 l
  102.779 84.766 l
  102.562 39.766 l
  112.462 39.597 l
  124.262 65.197 l
  124.138 39.397 l
  131.728 39.267 l
  f
  163 47.4 m
  148.2 47.653 l
  148.24 56.013 l
  161.94 55.779 l
  161.982 64.479 l
  148.282 64.713 l
  148.375 83.913 l
  140.135 84.054 l
  139.918 39.054 l
  162.918 38.66 l
  f
  186 83.3 m
  167.2 83.622 l
  167.161 75.652 l
  172.421 75.562 l
  172.281 46.562 l
  167.022 46.652 l
  166.983 38.682 l
  185.783 38.36 l
  185.822 46.33 l
  180.562 46.42 l
  180.702 75.42 l
  185.962 75.33 l
  f
  223 60.2 m
  223.02 64.387 222.357 68.153 221.01 71.5 c
  219.663 74.827 217.95 77.393 215.87 79.2 c
  214.31 80.553 212.597 81.51 210.73 82.07 c
  208.863 82.625 206.65 82.925 204.09 82.969 c
  192.79 83.163 l
  192.573 38.163 l
  204.173 37.964 l
  206.786 37.919 209.043 38.193 210.943 38.784 c
  212.843 39.355 214.443 40.192 215.743 41.294 c
  217.963 43.147 219.713 45.674 220.993 48.874 c
  222.286 52.054 222.943 55.821 222.963 60.174 c
  h
  214.44 60.256 m
  214.426 57.296 214.026 54.776 213.24 52.696 c
  212.467 50.596 211.243 48.966 209.57 47.806 c
  208.717 47.237 207.847 46.86 206.96 46.676 c
  206.08 46.469 204.75 46.381 202.97 46.412 c
  200.88 46.448 l
  201.016 74.548 l
  203.106 74.512 l
  205.073 74.478 206.516 74.333 207.436 74.076 c
  208.356 73.799 209.253 73.322 210.126 72.646 c
  211.626 71.413 212.726 69.783 213.426 67.756 c
  214.119 65.709 214.459 63.196 214.446 60.216 c
  f
  253 82.1 m
  229.8 82.497 l
  229.583 37.497 l
  252.783 37.1 l
  252.825 45.8 l
  237.825 46.056 l
  237.862 53.816 l
  251.762 53.578 l
  251.804 62.278 l
  237.904 62.516 l
  237.958 73.616 l
  252.958 73.36 l
  f
  289 81.5 m
  281.02 81.636 l
  267.22 51.036 l
  267.369 81.936 l
  259.779 82.066 l
  259.562 37.066 l
  269.462 36.897 l
  281.262 62.497 l
  281.138 36.697 l
  288.728 36.567 l
  f
  322 44.7 m
  312 44.872 l
  312.175 81.172 l
  303.895 81.314 l
  303.72 45.014 l
  293.72 45.186 l
  293.678 36.486 l
  321.978 36.001 l
  f
  345 80.6 m
  326.2 80.922 l
  326.161 72.952 l
  331.421 72.862 l
  331.281 43.862 l
  326.022 43.952 l
  325.983 35.982 l
  344.783 35.66 l
  344.822 43.63 l
  339.562 43.72 l
  339.702 72.72 l
  344.962 72.63 l
  f
  381 79.9 m
  372.44 80.046 l
  370.18 70.996 l
  358.28 71.2 l
  356.1 80.33 l
  347.76 80.473 l
  359.36 35.273 l
  368.89 35.11 l
  h
  368.1 62.8 m
  364.08 46.7 l
  360.21 62.9 l
  f
  409 79.5 m
  385.8 79.896 l
  385.583 34.896 l
  393.863 34.754 l
  394.038 71.054 l
  408.938 70.799 l
  f
  `,
    FINAL: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  148 44.7 m
  126.9 45.053 l
  126.995 54.943 l
  146.495 54.616 l
  146.593 64.916 l
  127.093 65.243 l
  127.31 87.943 l
  115.51 88.14 l
  115.001 35.04 l
  147.801 34.491 l
  f
  181 87 m
  154.2 87.449 l
  154.11 78.029 l
  161.62 77.903 l
  161.292 43.603 l
  153.782 43.729 l
  153.692 34.309 l
  180.492 33.86 l
  180.582 43.28 l
  173.072 43.406 l
  173.4 77.706 l
  180.91 77.58 l
  f
  233 86.1 m
  221.6 86.291 l
  201.8 50.191 l
  202.149 86.691 l
  191.349 86.872 l
  190.84 33.772 l
  204.94 33.536 l
  221.94 63.736 l
  221.649 33.336 l
  232.449 33.155 l
  f
  287 85.2 m
  274.8 85.404 l
  271.53 74.704 l
  254.53 74.988 l
  251.46 85.788 l
  239.56 85.987 l
  255.96 32.587 l
  269.56 32.359 l
  h
  268.6 65 m
  262.78 46 l
  257.33 65.2 l
  f
  326 84.5 m
  292.9 85.053 l
  292.391 31.953 l
  304.191 31.755 l
  304.601 74.655 l
  325.801 74.3 l
  f
  `,
    EXPIRED: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  99.4 88.3 m
  66.3 88.855 l
  65.791 35.755 l
  98.891 35.2 l
  98.989 45.5 l
  77.589 45.858 l
  77.677 55.028 l
  97.577 54.696 l
  97.676 64.996 l
  77.776 65.328 l
  77.902 78.428 l
  99.302 78.07 l
  f
  151 87.5 m
  137.3 87.729 l
  127.3 70.429 l
  117.4 88.129 l
  104.3 88.347 l
  120.3 61.347 l
  104.1 35.247 l
  117.7 35.019 l
  127.4 51.419 l
  137.06 34.719 l
  150.16 34.5 l
  134.36 60.6 l
  f
  195 50.4 m
  195.023 52.78 194.686 55.117 193.99 57.41 c
  193.297 59.683 192.29 61.603 190.97 63.17 c
  189.163 65.297 187.137 66.913 184.89 68.02 c
  182.663 69.127 179.877 69.71 176.53 69.77 c
  169.17 69.893 l
  169.336 87.193 l
  157.536 87.391 l
  157.027 34.291 l
  176.527 33.966 l
  179.44 33.917 181.894 34.174 183.887 34.735 c
  185.9 35.272 187.684 36.112 189.237 37.255 c
  191.097 38.628 192.52 40.402 193.507 42.575 c
  194.514 44.748 195.03 47.368 195.057 50.435 c
  h
  182.8 50.926 m
  182.786 49.426 182.426 48.146 181.72 47.086 c
  181.013 46.006 180.197 45.259 179.27 44.846 c
  178.037 44.295 176.833 44.006 175.66 43.978 c
  174.487 43.926 172.927 43.917 170.98 43.949 c
  168.95 43.983 l
  169.102 59.883 l
  172.492 59.827 l
  174.505 59.793 176.155 59.623 177.442 59.316 c
  178.755 59.008 179.849 58.418 180.722 57.546 c
  181.475 56.772 182.012 55.859 182.332 54.806 c
  182.671 53.732 182.833 52.432 182.818 50.906 c
  f
  228 86.2 m
  201.2 86.649 l
  201.11 77.229 l
  208.62 77.103 l
  208.292 42.803 l
  200.782 42.929 l
  200.692 33.509 l
  227.492 33.06 l
  227.582 42.48 l
  220.072 42.606 l
  220.4 76.906 l
  227.91 76.78 l
  f
  263 48.7 m
  262.987 47.367 262.74 46.23 262.259 45.29 c
  261.778 44.343 260.961 43.607 259.809 43.08 c
  259.002 42.713 258.066 42.502 256.999 42.449 c
  255.932 42.372 254.689 42.345 253.269 42.369 c
  248.989 42.44 l
  249.126 56.74 l
  252.756 56.679 l
  254.643 56.648 256.223 56.514 257.496 56.279 c
  258.769 56.044 259.833 55.537 260.686 54.759 c
  261.499 54.006 262.086 53.186 262.446 52.299 c
  262.827 51.386 263.011 50.183 262.996 48.689 c
  h
  281.8 85.3 m
  267.4 85.541 l
  254.7 66.241 l
  249.25 66.332 l
  249.437 85.832 l
  237.637 86.029 l
  237.128 32.929 l
  256.928 32.597 l
  259.635 32.552 261.965 32.691 263.918 33.015 c
  265.871 33.339 267.705 34.082 269.418 35.245 c
  271.151 36.405 272.531 37.928 273.558 39.815 c
  274.605 41.675 275.141 44.035 275.168 46.895 c
  275.206 50.822 274.446 54.035 272.888 56.535 c
  271.355 59.035 269.138 61.132 266.238 62.825 c
  f
  321 84.6 m
  287.9 85.155 l
  287.391 32.055 l
  320.491 31.5 l
  320.589 41.8 l
  299.189 42.158 l
  299.277 51.328 l
  319.177 50.996 l
  319.276 61.296 l
  299.376 61.628 l
  299.502 74.728 l
  320.902 74.37 l
  f
  373 57.2 m
  373.047 62.147 372.114 66.613 370.2 70.6 c
  368.287 74.533 365.853 77.573 362.9 79.72 c
  360.68 81.327 358.24 82.463 355.58 83.13 c
  352.92 83.793 349.763 84.157 346.11 84.22 c
  329.91 84.49 l
  329.401 31.39 l
  346.001 31.112 l
  349.734 31.05 352.961 31.365 355.681 32.057 c
  358.394 32.724 360.681 33.707 362.541 35.007 c
  365.721 37.194 368.234 40.174 370.081 43.947 c
  371.941 47.7 372.898 52.134 372.951 57.247 c
  h
  360.8 57.297 m
  360.767 53.797 360.183 50.821 359.05 48.367 c
  357.937 45.887 356.183 43.964 353.79 42.597 c
  352.57 41.931 351.323 41.487 350.05 41.267 c
  348.797 41.027 346.897 40.928 344.35 40.97 c
  341.36 41.02 l
  341.678 74.32 l
  344.668 74.27 l
  347.481 74.223 349.541 74.046 350.848 73.738 c
  352.161 73.407 353.438 72.837 354.678 72.028 c
  356.818 70.562 358.381 68.632 359.368 66.238 c
  360.348 63.818 360.821 60.848 360.788 57.328 c
  f
  `,
    AS_IS: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  170 87.2 m
  157.8 87.404 l
  154.53 76.704 l
  137.53 76.988 l
  134.46 87.788 l
  122.56 87.987 l
  138.96 34.587 l
  152.56 34.359 l
  h
  151.6 67 m
  145.78 48 l
  140.33 67.2 l
  f
  213 69.7 m
  213.05 74.933 211.173 79.233 207.37 82.6 c
  203.583 85.927 198.417 87.643 191.87 87.75 c
  188.077 87.813 184.76 87.488 181.92 86.774 c
  179.1 86.034 176.453 85.091 173.98 83.944 c
  173.858 71.244 l
  175.148 71.222 l
  177.615 73.442 180.361 75.132 183.388 76.292 c
  186.435 77.452 189.355 78.009 192.148 77.962 c
  192.868 77.95 193.811 77.863 194.978 77.7 c
  196.145 77.538 197.098 77.284 197.838 76.938 c
  198.738 76.495 199.471 75.948 200.038 75.298 c
  200.627 74.646 200.915 73.689 200.903 72.428 c
  200.892 71.262 200.452 70.268 199.583 69.448 c
  198.736 68.608 197.49 67.975 195.843 67.548 c
  194.116 67.101 192.286 66.691 190.353 66.318 c
  188.44 65.922 186.64 65.415 184.953 64.798 c
  181.08 63.412 178.28 61.495 176.553 59.048 c
  174.846 56.575 173.976 53.495 173.943 49.808 c
  173.896 44.862 175.766 40.795 179.553 37.608 c
  183.36 34.402 188.26 32.748 194.253 32.648 c
  197.266 32.598 200.246 32.893 203.193 33.534 c
  206.153 34.151 208.716 34.954 210.883 35.944 c
  211 48.144 l
  209.74 48.166 l
  207.88 46.486 205.6 45.095 202.9 43.995 c
  200.22 42.875 197.487 42.339 194.7 42.386 c
  193.713 42.402 192.73 42.502 191.75 42.684 c
  190.79 42.843 189.86 43.144 188.96 43.587 c
  188.16 43.958 187.477 44.518 186.91 45.267 c
  186.342 45.994 186.063 46.821 186.072 47.747 c
  186.085 49.154 186.559 50.227 187.492 50.967 c
  188.425 51.687 190.175 52.337 192.742 52.917 c
  194.429 53.293 196.042 53.66 197.582 54.017 c
  199.142 54.372 200.819 54.869 202.612 55.508 c
  206.132 56.781 208.735 58.557 210.422 60.837 c
  212.129 63.091 212.999 66.051 213.032 69.718 c
  f
  267 85.5 m
  240.2 85.949 l
  240.11 76.529 l
  247.62 76.403 l
  247.292 42.103 l
  239.782 42.229 l
  239.692 32.809 l
  266.492 32.36 l
  266.582 41.78 l
  259.072 41.906 l
  259.4 76.206 l
  266.91 76.08 l
  f
  313 68.1 m
  313.05 73.333 311.173 77.633 307.37 81 c
  303.583 84.327 298.417 86.043 291.87 86.15 c
  288.077 86.213 284.76 85.888 281.92 85.174 c
  279.1 84.434 276.453 83.491 273.98 82.344 c
  273.858 69.644 l
  275.148 69.622 l
  277.615 71.842 280.361 73.532 283.388 74.692 c
  286.435 75.852 289.355 76.409 292.148 76.362 c
  292.868 76.35 293.811 76.263 294.978 76.1 c
  298.738 74.895 299.471 74.348 300.038 73.698 c
  300.627 73.046 300.915 72.089 300.903 70.828 c
  300.892 69.662 300.452 68.668 299.583 67.848 c
  298.736 67.008 297.49 66.375 295.843 65.948 c
  294.116 65.501 292.286 65.091 290.353 64.718 c
  288.44 64.322 286.64 63.815 284.953 63.198 c
  281.08 61.812 278.28 59.895 276.553 57.448 c
  274.846 54.975 273.976 51.895 273.943 48.208 c
  273.896 43.262 275.766 39.195 279.553 36.008 c
  283.36 32.802 288.26 31.148 294.253 31.048 c
  297.266 30.998 300.246 31.293 303.193 31.934 c
  306.153 32.551 308.716 33.354 310.883 34.344 c
  311 46.544 l
  309.74 46.565 l
  307.88 44.885 305.6 43.495 302.9 42.395 c
  300.22 41.275 297.487 40.739 294.7 40.785 c
  293.713 40.802 292.73 40.902 291.75 41.084 c
  290.79 41.243 289.86 41.544 288.96 41.987 c
  288.16 42.357 287.477 42.917 286.91 43.667 c
  286.342 44.394 286.063 45.221 286.072 46.147 c
  286.085 47.554 286.559 48.627 287.492 49.367 c
  288.425 50.087 290.175 50.737 292.742 51.317 c
  294.429 51.693 296.042 52.06 297.582 52.417 c
  299.142 52.772 300.819 53.269 302.612 53.907 c
  306.132 55.181 308.735 56.957 310.422 59.237 c
  312.129 61.491 312.999 64.451 313.032 68.117 c
  f  
  `,
    SOLD: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  166 70.5 m
  166.05 75.733 164.173 80.033 160.37 83.4 c
  156.583 86.727 151.417 88.443 144.87 88.55 c
  141.077 88.613 137.76 88.288 134.92 87.574 c
  132.1 86.834 129.453 85.891 126.98 84.744 c
  126.858 72.044 l
  128.148 72.022 l
  130.615 74.242 133.361 75.932 136.388 77.092 c
  139.435 78.252 142.355 78.809 145.148 78.762 c
  145.868 78.75 146.811 78.663 147.978 78.5 c
  149.145 78.338 150.098 78.084 150.838 77.738 c
  151.738 77.295 152.471 76.748 153.038 76.098 c
  153.627 75.446 153.915 74.489 153.903 73.228 c
  153.892 72.062 153.452 71.068 152.583 70.248 c
  151.736 69.408 150.49 68.775 148.843 68.348 c
  147.116 67.901 145.286 67.491 143.353 67.118 c
  141.44 66.722 139.64 66.215 137.953 65.598 c
  134.08 64.212 131.28 62.295 129.553 59.848 c
  127.846 57.375 126.976 54.295 126.943 50.608 c
  126.896 45.662 128.766 41.595 132.553 38.408 c
  136.36 35.202 141.26 33.548 147.253 33.448 c
  150.266 33.398 153.246 33.693 156.193 34.334 c
  159.153 34.951 161.716 35.754 163.883 36.744 c
  164 48.944 l
  162.74 48.965 l
  160.88 47.285 158.6 45.895 155.9 44.795 c
  153.22 43.675 150.487 43.139 147.7 43.185 c
  146.713 43.202 145.73 43.302 144.75 43.484 c
  143.79 43.643 142.86 43.944 141.96 44.387 c
  141.16 44.757 140.477 45.317 139.91 46.067 c
  139.342 46.794 139.063 47.621 139.072 48.547 c
  139.085 49.954 139.559 51.027 140.492 51.767 c
  141.425 52.487 143.175 53.137 145.742 53.717 c
  147.429 54.093 149.042 54.46 150.582 54.817 c
  152.142 55.172 153.819 55.669 155.612 56.307 c
  159.132 57.581 161.735 59.357 163.422 61.637 c
  165.129 63.891 165.999 66.851 166.032 70.517 c
  f
  218 59.8 m
  218.081 68.267 216.051 75.033 211.91 80.1 c
  207.77 85.14 202.003 87.723 194.61 87.85 c
  187.277 87.973 181.477 85.583 177.21 80.68 c
  172.977 75.753 170.82 69.053 170.74 60.58 c
  170.658 52.047 172.688 45.28 176.83 40.28 c
  180.97 35.24 186.737 32.657 194.13 32.53 c
  201.463 32.407 207.263 34.797 211.53 39.7 c
  215.783 44.58 217.95 51.28 218.03 59.8 c
  h
  202.5 73.5 m
  203.633 71.86 204.467 69.943 205 67.75 c
  205.533 65.53 205.785 62.933 205.757 59.96 c
  205.726 56.773 205.383 54.067 204.727 51.84 c
  204.07 49.613 203.22 47.82 202.177 46.46 c
  201.117 45.047 199.897 44.033 198.517 43.42 c
  197.157 42.8 195.737 42.502 194.257 42.527 c
  192.757 42.552 191.344 42.885 190.017 43.526 c
  188.71 44.167 187.51 45.21 186.417 46.656 c
  185.404 48.003 184.58 49.859 183.947 52.226 c
  183.333 54.566 183.041 57.283 183.071 60.376 c
  183.101 63.543 183.435 66.239 184.071 68.466 c
  184.728 70.666 185.578 72.459 186.621 73.846 c
  187.661 75.233 188.871 76.246 190.251 76.886 c
  191.631 77.529 193.081 77.838 194.601 77.813 c
  196.121 77.788 197.564 77.431 198.931 76.743 c
  200.298 76.03 201.488 74.95 202.501 73.503 c
  f
  261 85.6 m
  227.9 86.153 l
  227.391 33.053 l
  239.191 32.855 l
  239.601 75.755 l
  260.801 75.4 l
  f
  311 58.3 m
  311.047 63.247 310.114 67.713 308.2 71.7 c
  306.287 75.633 303.853 78.673 300.9 80.82 c
  298.68 82.427 296.24 83.563 293.58 84.23 c
  267.91 85.59 l
  267.401 32.49 l
  284.001 32.212 l
  287.734 32.15 290.961 32.465 293.681 33.157 c
  296.394 33.824 298.681 34.807 300.541 36.107 c
  303.721 38.294 306.234 41.274 308.081 45.047 c
  309.941 48.8 310.898 53.234 310.951 58.347 c
  h
  298.8 58.397 m
  298.767 54.897 298.183 51.921 297.05 49.467 c
  295.937 46.987 294.183 45.064 291.79 43.697 c
  290.57 43.031 289.323 42.587 288.05 42.367 c
  286.797 42.127 284.897 42.028 282.35 42.07 c
  279.36 42.12 l
  279.678 75.42 l
  282.668 75.37 l
  285.481 75.323 287.541 75.146 288.848 74.838 c
  290.161 74.507 291.438 73.937 292.678 73.128 c
  294.818 71.662 296.381 69.732 297.368 67.338 c
  298.348 64.918 298.821 61.948 298.788 58.428 c
  f
  `,
    EXPERIMENTAL: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  55.9 86.5 m
  32.9 86.873 l
  32.766 40.073 l
  55.766 39.7 l
  55.792 48.76 l
  40.992 49.001 l
  41.015 57.081 l
  54.815 56.857 l
  54.841 65.917 l
  41.041 66.141 l
  41.074 77.741 l
  55.874 77.5 l
  f
  91.6 85.9 m
  82.12 86.054 l
  75.22 70.754 l
  68.28 86.254 l
  59.23 86.401 l
  70.43 62.601 l
  59.33 39.501 l
  68.79 39.347 l
  75.45 53.847 l
  82.22 39.147 l
  91.3 39 l
  80.3 61.9 l
  f
  122 53.4 m
  122 55.493 121.757 57.553 121.27 59.58 c
  120.777 61.58 120.071 63.27 119.15 64.65 c
  117.89 66.517 116.477 67.933 114.91 68.9 c
  113.363 69.867 111.43 70.37 109.11 70.41 c
  104.01 70.493 l
  104.054 85.793 l
  95.854 85.926 l
  95.72 39.126 l
  109.22 38.907 l
  111.24 38.874 112.943 39.108 114.33 39.61 c
  115.723 40.091 116.956 40.837 118.03 41.85 c
  119.316 43.063 120.296 44.63 120.97 46.55 c
  121.656 48.47 122.003 50.78 122.01 53.48 c
  h
  113.52 53.821 m
  113.52 52.501 113.275 51.374 112.784 50.441 c
  112.297 49.488 111.734 48.824 111.094 48.451 c
  110.241 47.962 109.407 47.703 108.594 47.674 c
  107.781 47.624 106.697 47.61 105.344 47.632 c
  103.934 47.655 l
  103.974 61.655 l
  106.324 61.617 l
  107.717 61.595 108.864 61.45 109.764 61.184 c
  110.677 60.918 111.437 60.401 112.044 59.634 c
  112.569 58.954 112.945 58.151 113.174 57.224 c
  113.413 56.278 113.531 55.134 113.527 53.794 c
  f
  151 84.9 m
  128 85.273 l
  127.866 38.473 l
  150.866 38.1 l
  150.892 47.16 l
  136.092 47.401 l
  136.115 55.481 l
  149.915 55.257 l
  149.941 64.317 l
  136.141 64.541 l
  136.174 76.141 l
  150.974 75.9 l
  f
  176 52.1 m
  176 50.927 175.833 49.923 175.5 49.09 c
  175.17 48.257 174.607 47.607 173.81 47.14 c
  173.254 46.813 172.604 46.625 171.86 46.574 c
  171.12 46.502 170.26 46.474 169.28 46.49 c
  166.31 46.538 l
  166.346 59.138 l
  168.866 59.098 l
  170.173 59.076 171.269 58.964 172.156 58.762 c
  173.036 58.558 173.776 58.115 174.376 57.432 c
  174.943 56.772 175.353 56.052 175.606 55.272 c
  175.874 54.471 176.006 53.411 176.003 52.092 c
  h
  188.9 84.4 m
  178.9 84.563 l
  170.18 67.563 l
  166.4 67.624 l
  166.449 84.824 l
  158.289 84.956 l
  158.155 38.156 l
  171.955 37.933 l
  173.835 37.903 175.452 38.034 176.805 38.326 c
  178.158 38.619 179.428 39.279 180.615 40.306 c
  181.815 41.333 182.765 42.68 183.465 44.346 c
  184.178 45.993 184.542 48.073 184.555 50.586 c
  184.565 54.046 184.025 56.876 182.935 59.076 c
  181.862 61.276 180.315 63.116 178.295 64.596 c
  f
  210 84 m
  191.4 84.302 l
  191.376 76.002 l
  196.586 75.917 l
  196.5 45.717 l
  191.29 45.802 l
  191.266 37.502 l
  209.866 37.2 l
  209.89 45.5 l
  204.68 45.585 l
  204.766 75.785 l
  209.976 75.7 l
  f
  250 83.3 m
  241.84 83.432 l
  241.75 52.032 l
  235.91 72.432 l
  230.25 72.524 l
  224.3 52.224 l
  224.39 83.624 l
  216.66 83.75 l
  216.526 36.95 l
  226.046 36.795 l
  233.266 60.195 l
  240.336 36.595 l
  249.856 36.44 l
  f
  281 82.8 m
  258 83.173 l
  257.866 36.373 l
  280.866 36 l
  280.892 45.06 l
  266.092 45.301 l
  266.115 53.381 l
  279.915 53.157 l
  279.941 62.217 l
  266.141 62.441 l
  266.174 74.041 l
  280.974 73.8 l
  f
  316 82.3 m
  308.1 82.428 l
  294.5 50.528 l
  294.592 82.628 l
  287.072 82.75 l
  286.938 35.95 l
  296.738 35.791 l
  308.438 62.391 l
  308.361 35.591 l
  315.881 35.469 l
  f
  349 44 m
  339.07 44.161 l
  339.178 81.961 l
  330.978 82.094 l
  330.87 44.294 l
  320.94 44.455 l
  320.914 35.395 l
  349.014 34.939 l
  f
  384 81.2 m
  375.52 81.338 l
  373.29 71.908 l
  361.49 72.099 l
  359.32 81.599 l
  351.06 81.733 l
  362.66 34.733 l
  372.1 34.58 l
  h
  371.3 63.4 m
  367.34 46.7 l
  363.48 63.6 l
  f
  411 80.7 m
  388.1 81.072 l
  387.966 34.272 l
  396.166 34.139 l
  396.274 71.939 l
  410.974 71.7 l
  f
  `,
    FOR_COMMENT: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  61.6 49.9 m
  46.8 50.184 l
  46.866 58.134 l
  60.566 57.871 l
  60.635 66.141 l
  46.935 66.404 l
  47.087 84.704 l
  38.837 84.862 l
  38.48 42.162 l
  61.48 41.72 l
  f
  98.7 62.3 m
  98.757 69.1 97.334 74.533 94.43 78.6 c
  91.523 82.653 87.49 84.73 82.33 84.83 c
  77.163 84.929 73.097 83.006 70.13 79.06 c
  67.157 75.1 65.643 69.7 65.59 62.86 c
  65.533 55.993 66.956 50.527 69.86 46.46 c
  72.767 42.407 76.8 40.33 81.96 40.23 c
  87.113 40.131 91.18 42.055 94.16 46 c
  97.147 49.927 98.667 55.327 98.72 62.2 c
  h
  87.8 73.3 m
  88.593 71.98 89.177 70.437 89.55 68.67 c
  89.924 66.883 90.101 64.793 90.081 62.4 c
  90.06 59.833 89.818 57.657 89.357 55.87 c
  88.896 54.077 88.299 52.633 87.567 51.54 c
  86.82 50.407 85.964 49.59 84.997 49.09 c
  84.044 48.591 83.047 48.352 82.007 48.372 c
  80.954 48.392 79.964 48.66 79.037 49.176 c
  78.117 49.691 77.274 50.531 76.507 51.696 c
  75.794 52.783 75.217 54.276 74.777 56.176 c
  74.346 58.063 74.141 60.249 74.162 62.736 c
  74.183 65.283 74.417 67.449 74.864 69.236 c
  75.325 71.009 75.922 72.453 76.654 73.566 c
  80.171 76.533 81.187 76.782 82.254 76.761 c
  83.321 76.741 84.334 76.453 85.294 75.899 c
  86.254 75.326 87.091 74.459 87.804 73.299 c
  f
  123 53.6 m
  122.991 52.527 122.818 51.61 122.48 50.85 c
  122.143 50.09 121.569 49.497 120.76 49.07 c
  120.196 48.775 119.539 48.605 118.79 48.562 c
  118.043 48.5 117.173 48.478 116.18 48.497 c
  113.18 48.555 l
  113.276 60.055 l
  115.826 60.006 l
  117.153 59.981 118.259 59.873 119.146 59.684 c
  120.039 59.495 120.786 59.088 121.386 58.464 c
  121.957 57.86 122.37 57.2 122.626 56.484 c
  122.893 55.751 123.022 54.781 123.012 53.574 c
  h
  136.2 83 m
  126.1 83.194 l
  117.2 67.694 l
  113.38 67.767 l
  113.511 83.467 l
  105.261 83.625 l
  104.904 40.925 l
  118.804 40.658 l
  120.704 40.622 122.341 40.734 123.714 40.995 c
  125.087 41.256 126.374 41.853 127.574 42.785 c
  128.794 43.719 129.761 44.945 130.474 46.465 c
  131.207 47.965 131.584 49.862 131.604 52.155 c
  131.63 55.315 131.097 57.899 130.004 59.905 c
  128.924 61.919 127.367 63.605 125.334 64.965 c
  f
  169 83.2 m
  166.607 83.246 164.393 82.819 162.36 81.92 c
  160.333 81.02 158.587 79.657 157.12 77.83 c
  155.653 76.003 154.503 73.71 153.67 70.95 c
  152.857 68.19 152.433 64.993 152.4 61.36 c
  152.372 57.973 152.728 54.893 153.47 52.12 c
  154.21 49.347 155.3 46.963 156.74 44.97 c
  158.12 43.05 159.837 41.553 161.89 40.48 c
  163.957 39.407 166.213 38.847 168.66 38.8 c
  170.013 38.774 171.23 38.856 172.31 39.046 c
  173.403 39.217 174.413 39.456 175.34 39.763 c
  176.307 40.108 177.18 40.502 177.96 40.943 c
  178.753 41.368 179.447 41.764 180.04 42.133 c
  180.127 52.533 l
  179.177 52.551 l
  178.77 52.1 178.253 51.563 177.627 50.941 c
  177.017 50.321 176.32 49.711 175.537 49.111 c
  174.737 48.514 173.877 48.014 172.957 47.611 c
  168.83 47.059 167.723 47.329 166.677 47.846 c
  165.63 48.345 164.663 49.168 163.777 50.316 c
  162.937 51.423 162.257 52.88 161.737 54.686 c
  161.233 56.493 160.992 58.68 161.014 61.246 c
  161.036 63.926 161.335 66.16 161.912 67.946 c
  162.502 69.733 163.236 71.136 164.112 72.156 c
  164.998 73.19 165.985 73.926 167.072 74.366 c
  168.158 74.786 169.225 74.985 170.272 74.965 c
  171.278 74.946 172.271 74.726 173.251 74.305 c
  174.245 73.885 175.155 73.321 175.981 72.615 c
  176.681 72.047 177.332 71.44 177.931 70.795 c
  178.531 70.152 179.024 69.599 179.411 69.135 c
  180.275 69.119 l
  180.361 79.319 l
  179.561 79.813 178.794 80.276 178.061 80.709 c
  177.327 81.144 176.561 81.524 175.761 81.849 c
  174.714 82.271 173.731 82.596 172.811 82.824 c
  171.891 83.052 170.624 83.181 169.011 83.213 c
  f
  218 60 m
  218.057 66.8 216.634 72.233 213.73 76.3 c
  210.823 80.353 206.79 82.43 201.63 82.53 c
  196.463 82.629 192.397 80.706 189.43 76.76 c
  186.457 72.8 184.943 67.4 184.89 60.56 c
  184.833 53.693 186.256 48.227 189.16 44.16 c
  192.067 40.107 196.1 38.03 201.26 37.93 c
  206.413 37.831 210.48 39.755 213.46 43.7 c
  216.447 47.627 217.967 53.027 218.02 59.9 c
  h
  207.1 71 m
  207.893 69.68 208.477 68.137 208.85 66.37 c
  209.224 64.583 209.401 62.493 209.381 60.1 c
  209.36 57.533 209.118 55.357 208.657 53.57 c
  208.196 51.777 207.599 50.333 206.867 49.24 c
  206.12 48.107 205.264 47.29 204.297 46.79 c
  203.344 46.291 202.347 46.052 201.307 46.072 c
  200.254 46.092 199.264 46.36 198.337 46.876 c
  197.417 47.391 196.574 48.231 195.807 49.396 c
  195.094 50.483 194.517 51.976 194.077 53.876 c
  193.646 55.763 193.441 57.949 193.462 60.436 c
  193.483 62.983 193.717 65.149 194.164 66.936 c
  194.625 68.709 195.222 70.153 195.954 71.266 c
  199.471 74.233 200.487 74.482 201.554 74.461 c
  202.621 74.441 203.634 74.153 204.594 73.599 c
  205.554 73.026 206.391 72.159 207.104 70.999 c
  f
  258 80.6 m
  249.75 80.758 l
  249.511 52.158 l
  243.701 70.858 l
  237.981 70.968 l
  231.861 52.468 l
  232.1 81.068 l
  224.28 81.218 l
  223.923 38.518 l
  233.553 38.333 l
  240.963 59.633 l
  247.993 38.033 l
  257.623 37.848 l
  f
  300 79.8 m
  291.75 79.958 l
  291.511 51.358 l
  285.701 70.058 l
  279.981 70.168 l
  273.861 51.668 l
  274.1 80.268 l
  266.28 80.418 l
  265.923 37.718 l
  275.553 37.533 l
  282.963 58.833 l
  289.993 37.233 l
  299.623 37.048 l
  f
  332 79.2 m
  308.7 79.646 l
  308.343 36.946 l
  331.643 36.5 l
  331.712 44.77 l
  316.712 45.058 l
  316.774 52.438 l
  330.674 52.171 l
  330.743 60.441 l
  316.843 60.708 l
  316.931 71.308 l
  331.931 71.02 l
  f
  368 78.5 m
  360.01 78.653 l
  346.11 49.553 l
  346.355 78.853 l
  338.755 78.999 l
  338.398 36.299 l
  348.308 36.109 l
  360.208 60.409 l
  360.004 35.909 l
  367.604 35.763 l
  f
  401 43.4 m
  391 43.593 l
  391.288 78.093 l
  382.998 78.252 l
  382.71 43.752 l
  372.71 43.945 l
  372.641 35.675 l
  401.041 35.131 l
  f  
  `,
    TOP_SECRET: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  67.5 47.4 m
  55 47.623 l
  55.357 87.423 l
  45.057 87.607 l
  44.7 47.807 l
  32.2 48.03 l
  32.114 38.48 l
  67.314 37.851 l
  f
  113 61.7 m
  113.071 69.567 111.304 75.867 107.7 80.6 c
  104.093 85.287 99.06 87.687 92.6 87.8 c
  86.187 87.915 81.12 85.695 77.4 81.14 c
  73.713 76.56 71.833 70.327 71.76 62.44 c
  71.689 54.507 73.455 48.207 77.06 43.54 c
  80.667 38.853 85.667 36.453 92.06 36.34 c
  98.453 36.226 103.52 38.446 107.26 43 c
  110.967 47.533 112.853 53.767 112.92 61.7 c
  h
  99.5 74.4 m
  100.487 72.88 101.213 71.097 101.68 69.05 c
  102.144 66.983 102.364 64.57 102.339 61.81 c
  102.312 58.85 102.013 56.333 101.44 54.26 c
  100.867 52.193 100.127 50.527 99.22 49.26 c
  98.3 47.947 97.237 47.003 96.03 46.43 c
  94.843 45.854 93.607 45.577 92.32 45.6 c
  91.013 45.623 89.783 45.933 88.63 46.528 c
  87.49 47.123 86.443 48.093 85.49 49.438 c
  84.61 50.691 83.893 52.418 83.34 54.618 c
  82.805 56.798 82.551 59.325 82.577 62.198 c
  82.603 65.138 82.894 67.645 83.449 69.718 c
  84.022 71.765 84.762 73.431 85.669 74.718 c
  86.576 76.005 87.629 76.948 88.829 77.548 c
  90.029 78.146 91.292 78.433 92.619 78.409 c
  93.939 78.385 95.196 78.053 96.389 77.413 c
  97.582 76.75 98.619 75.747 99.499 74.403 c
  f
  153 51.9 m
  153.02 54.113 152.726 56.287 152.12 58.42 c
  151.513 60.533 150.637 62.317 149.49 63.77 c
  147.917 65.743 146.153 67.247 144.2 68.28 c
  142.26 69.307 139.833 69.847 136.92 69.9 c
  130.51 70.014 l
  130.654 86.114 l
  120.354 86.298 l
  119.911 36.898 l
  136.811 36.596 l
  139.351 36.551 141.488 36.789 143.221 37.311 c
  144.974 37.81 146.528 38.59 147.881 39.651 c
  149.501 40.924 150.741 42.571 151.601 44.591 c
  152.474 46.611 152.924 49.048 152.951 51.901 c
  h
  142.4 52.388 m
  142.388 50.995 142.073 49.805 141.457 48.818 c
  140.84 47.811 140.127 47.115 139.317 46.728 c
  138.237 46.217 137.19 45.948 136.177 45.922 c
  135.157 45.874 133.8 45.865 132.107 45.895 c
  130.337 45.927 l
  130.47 60.727 l
  133.42 60.674 l
  135.173 60.643 136.61 60.485 137.73 60.199 c
  138.87 59.913 139.82 59.367 140.58 58.559 c
  141.235 57.839 141.701 56.989 141.98 56.009 c
  142.275 55.009 142.416 53.803 142.403 52.389 c
  f
  211 69.1 m
  211.044 73.967 209.407 77.967 206.09 81.1 c
  202.797 84.187 198.297 85.783 192.59 85.89 c
  189.283 85.949 186.393 85.647 183.92 84.983 c
  181.467 84.296 179.163 83.42 177.01 82.353 c
  176.904 70.553 l
  178.034 70.533 l
  180.181 72.593 182.571 74.166 185.204 75.253 c
  187.857 76.333 190.401 76.853 192.834 76.813 c
  193.459 76.802 194.279 76.721 195.294 76.57 c
  196.314 76.419 197.144 76.183 197.784 75.862 c
  198.564 75.45 199.204 74.94 199.704 74.332 c
  200.217 73.726 200.468 72.836 200.457 71.662 c
  200.447 70.575 200.064 69.652 199.307 68.892 c
  198.567 68.112 197.48 67.522 196.047 67.122 c
  194.54 66.707 192.947 66.327 191.267 65.982 c
  189.6 65.613 188.034 65.143 186.567 64.572 c
  183.194 63.285 180.757 61.505 179.257 59.232 c
  177.77 56.939 177.01 54.079 176.977 50.652 c
  176.936 46.052 178.562 42.285 181.857 39.352 c
  185.17 36.372 189.437 34.835 194.657 34.742 c
  197.284 34.695 199.877 34.969 202.437 35.565 c
  205.017 36.138 207.247 36.885 209.127 37.805 c
  209.229 49.205 l
  208.129 49.225 l
  206.509 47.658 204.522 46.368 202.169 45.355 c
  199.836 44.315 197.456 43.815 195.029 43.855 c
  194.169 43.87 193.312 43.963 192.459 44.133 c
  191.619 44.281 190.809 44.561 190.029 44.973 c
  189.336 45.317 188.742 45.837 188.249 46.533 c
  187.754 47.206 187.511 47.973 187.519 48.833 c
  187.531 50.139 187.941 51.139 188.749 51.833 c
  189.562 52.506 191.086 53.109 193.319 53.643 c
  194.786 53.993 196.192 54.333 197.539 54.663 c
  198.899 54.992 200.359 55.452 201.919 56.043 c
  204.986 57.229 207.252 58.879 208.719 60.993 c
  210.206 63.086 210.962 65.836 210.989 69.243 c
  f
  248 84 m
  219.1 84.515 l
  218.657 35.115 l
  247.557 34.6 l
  247.643 44.15 l
  229.043 44.483 l
  229.119 53.003 l
  246.419 52.694 l
  246.505 62.244 l
  229.205 62.553 l
  229.314 74.753 l
  247.914 74.42 l
  f
  274 84.5 m
  271.033 84.553 268.287 84.06 265.76 83.02 c
  263.247 81.98 261.08 80.403 259.26 78.29 c
  257.433 76.177 256.007 73.527 254.98 70.34 c
  253.967 67.153 253.443 63.453 253.41 59.24 c
  253.375 55.327 253.815 51.76 254.73 48.54 c
  255.65 45.34 257 42.583 258.78 40.27 c
  260.493 38.05 262.623 36.32 265.17 35.08 c
  267.73 33.84 270.53 33.193 273.57 33.14 c
  275.25 33.11 276.76 33.205 278.1 33.424 c
  279.46 33.621 280.713 33.897 281.86 34.253 c
  283.06 34.652 284.147 35.108 285.12 35.623 c
  286.107 36.114 286.97 36.574 287.71 37.003 c
  287.817 49.003 l
  286.637 49.024 l
  286.132 48.502 285.492 47.882 284.717 47.164 c
  283.957 46.451 283.094 45.747 282.127 45.054 c
  281.14 44.361 280.07 43.784 278.917 43.324 c
  277.77 42.858 276.544 42.637 275.237 42.66 c
  273.79 42.686 272.417 42.998 271.117 43.596 c
  269.817 44.172 268.62 45.122 267.527 46.446 c
  266.487 47.726 265.644 49.409 264.997 51.496 c
  264.372 53.589 264.073 56.116 264.1 59.076 c
  264.128 62.169 264.498 64.749 265.21 66.816 c
  265.943 68.883 266.85 70.503 267.93 71.676 c
  269.03 72.876 270.253 73.729 271.6 74.236 c
  272.947 74.721 274.27 74.951 275.57 74.928 c
  276.823 74.906 278.053 74.651 279.26 74.165 c
  280.487 73.678 281.617 73.028 282.65 72.215 c
  283.517 71.558 284.323 70.858 285.07 70.115 c
  285.817 69.375 286.427 68.735 286.9 68.195 c
  287.97 68.176 l
  288.076 79.976 l
  287.083 80.547 286.133 81.083 285.226 81.586 c
  284.319 82.089 283.366 82.525 282.366 82.896 c
  281.066 83.383 279.846 83.76 278.706 84.026 c
  277.566 84.289 275.996 84.439 273.996 84.475 c
  f
  318 48.5 m
  317.989 47.26 317.774 46.203 317.355 45.33 c
  316.936 44.45 316.223 43.767 315.215 43.28 c
  314.515 42.939 313.702 42.743 312.775 42.693 c
  311.848 42.621 310.768 42.596 309.535 42.618 c
  305.805 42.685 l
  305.924 55.985 l
  309.084 55.928 l
  310.731 55.899 312.104 55.775 313.204 55.556 c
  314.311 55.338 315.237 54.868 315.984 54.146 c
  316.691 53.446 317.201 52.686 317.514 51.866 c
  317.846 51.02 318.006 49.9 317.993 48.506 c
  h
  334.4 82.5 m
  321.8 82.724 l
  310.8 64.824 l
  306.06 64.909 l
  306.222 83.009 l
  296.022 83.192 l
  295.579 33.792 l
  312.879 33.484 l
  315.239 33.442 317.269 33.571 318.969 33.873 c
  320.669 34.174 322.266 34.864 323.759 35.943 c
  325.272 37.023 326.472 38.439 327.359 40.193 c
  328.266 41.926 328.732 44.119 328.759 46.773 c
  328.792 50.419 328.132 53.406 326.779 55.733 c
  325.439 58.059 323.509 60.006 320.989 61.573 c
  f
  368 81.9 m
  339.1 82.415 l
  338.657 33.015 l
  367.557 32.5 l
  367.643 42.05 l
  349.043 42.383 l
  349.119 50.903 l
  366.419 50.594 l
  366.505 60.144 l
  349.205 60.453 l
  349.314 72.653 l
  367.914 72.32 l
  f
  407 41.3 m
  394.5 41.523 l
  394.857 81.323 l
  384.557 81.507 l
  384.2 41.707 l
  371.7 41.93 l
  371.614 32.38 l
  406.814 31.751 l
  f  
  `,
    FOR_PUBLIC_RELEASE: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  93.2 32.1 m
  78.5 32.323 l
  78.566 38.583 l
  92.166 38.376 l
  92.234 44.886 l
  78.634 45.093 l
  78.785 59.493 l
  70.605 59.618 l
  70.251 25.918 l
  93.151 25.57 l
  f
  130 41.8 m
  130.056 47.167 128.646 51.467 125.77 54.7 c
  122.89 57.893 118.89 59.53 113.77 59.61 c
  108.643 59.688 104.61 58.175 101.67 55.07 c
  98.723 51.95 97.223 47.717 97.17 42.37 c
  97.113 36.957 98.523 32.657 101.4 29.47 c
  104.28 26.277 108.28 24.64 113.4 24.56 c
  118.513 24.482 122.547 25.995 125.5 29.1 c
  128.46 32.187 129.97 36.453 130.03 41.9 c
  h
  119.2 50.49 m
  119.987 49.45 120.567 48.237 120.94 46.85 c
  121.311 45.443 121.486 43.797 121.466 41.91 c
  121.445 39.89 121.205 38.177 120.748 36.77 c
  120.291 35.363 119.701 34.227 118.978 33.36 c
  118.238 32.467 117.388 31.823 116.428 31.43 c
  115.481 31.037 114.495 30.849 113.468 30.865 c
  112.428 30.881 111.445 31.092 110.518 31.498 c
  109.611 31.904 108.775 32.564 108.008 33.478 c
  107.301 34.331 106.728 35.508 106.288 37.008 c
  105.861 38.495 105.657 40.215 105.678 42.168 c
  105.699 44.175 105.931 45.881 106.375 47.288 c
  106.832 48.681 107.422 49.818 108.145 50.698 c
  108.865 51.578 109.708 52.221 110.675 52.628 c
  111.635 53.035 112.645 53.231 113.705 53.215 c
  114.758 53.199 115.762 52.973 116.715 52.536 c
  117.668 52.085 118.495 51.401 119.195 50.486 c
  f
  154 34.9 m
  153.991 34.053 153.819 33.333 153.485 32.74 c
  153.15 32.142 152.58 31.675 151.775 31.34 c
  151.216 31.107 150.566 30.974 149.825 30.94 c
  149.085 30.891 148.222 30.874 147.235 30.889 c
  144.255 30.934 l
  144.35 39.994 l
  146.88 39.956 l
  148.194 39.936 149.294 39.851 150.18 39.702 c
  151.067 39.552 151.807 39.232 152.4 38.741 c
  152.966 38.265 153.376 37.745 153.63 37.181 c
  153.896 36.604 154.023 35.841 154.013 34.891 c
  h
  167.1 58.1 m
  157.1 58.253 l
  148.27 46.053 l
  144.48 46.111 l
  144.61 58.411 l
  136.43 58.536 l
  136.076 24.836 l
  149.876 24.626 l
  151.763 24.597 153.386 24.685 154.746 24.891 c
  156.106 25.096 157.383 25.566 158.576 26.301 c
  159.783 27.034 160.743 28.001 161.456 29.201 c
  162.183 30.381 162.556 31.874 162.576 33.681 c
  162.602 36.167 162.072 38.204 160.986 39.791 c
  159.919 41.377 158.376 42.704 156.356 43.771 c
  f
  212 34.4 m
  212.016 35.907 211.782 37.387 211.297 38.84 c
  210.812 40.28 210.112 41.497 209.197 42.49 c
  207.937 43.837 206.527 44.86 204.967 45.56 c
  203.42 46.26 201.48 46.63 199.147 46.67 c
  194.027 46.748 l
  194.142 57.748 l
  185.922 57.873 l
  185.568 24.173 l
  199.068 23.967 l
  201.095 23.936 202.801 24.098 204.188 24.454 c
  205.588 24.795 206.828 25.325 207.908 26.044 c
  209.201 26.911 210.191 28.034 210.878 29.414 c
  211.578 30.787 211.938 32.447 211.958 34.394 c
  h
  203.5 34.733 m
  203.49 33.786 203.239 32.976 202.746 32.303 c
  202.253 31.616 201.683 31.143 201.036 30.883 c
  200.176 30.534 199.339 30.351 198.526 30.333 c
  197.713 30.3 196.626 30.294 195.266 30.315 c
  193.856 30.336 l
  193.962 40.436 l
  196.322 40.4 l
  197.722 40.379 198.872 40.271 199.772 40.076 c
  200.685 39.882 201.445 39.508 202.052 38.956 c
  202.575 38.466 202.949 37.886 203.172 37.216 c
  203.407 36.536 203.52 35.713 203.51 34.746 c
  f
  246 44.7 m
  246.044 48.86 244.877 52.067 242.5 54.32 c
  240.127 56.573 236.593 57.733 231.9 57.8 c
  227.233 57.871 223.7 56.818 221.3 54.64 c
  218.893 52.46 217.667 49.3 217.62 45.16 c
  217.394 23.66 l
  225.664 23.534 l
  225.885 44.534 l
  225.91 46.867 226.393 48.601 227.335 49.734 c
  228.275 50.867 229.788 51.417 231.875 51.384 c
  233.928 51.353 235.422 50.779 236.355 49.664 c
  237.302 48.551 237.762 46.781 237.735 44.354 c
  237.514 23.354 l
  245.784 23.228 l
  f
  281 46.1 m
  281.017 47.727 280.718 49.187 280.103 50.48 c
  279.502 51.773 278.662 52.85 277.583 53.71 c
  276.336 54.723 274.96 55.453 273.453 55.9 c
  271.96 56.345 270.056 56.585 267.743 56.62 c
  253.843 56.832 l
  253.489 23.132 l
  265.889 22.944 l
  268.462 22.905 270.342 22.967 271.529 23.129 c
  272.729 23.292 273.919 23.672 275.099 24.269 c
  276.319 24.898 277.229 25.758 277.829 26.849 c
  278.44 27.922 278.753 29.162 278.768 30.569 c
  278.785 32.196 278.392 33.642 277.588 34.909 c
  276.788 36.156 275.648 36.156 274.168 34.909 c
  276.255 35.314 277.915 36.194 279.148 37.549 c
  280.388 38.902 281.021 40.702 281.048 42.949 c
  h
  270.3 32.4 m
  270.3 31.843 270.158 31.286 269.875 30.73 c
  269.612 30.176 269.142 29.769 268.465 29.51 c
  267.863 29.278 267.113 29.161 266.215 29.16 c
  265.328 29.143 264.078 29.147 262.465 29.172 c
  261.694 29.184 l
  261.769 36.304 l
  263.059 36.284 l
  264.359 36.264 265.466 36.225 266.379 36.166 c
  267.292 36.107 268.012 35.945 268.539 35.681 c
  269.279 35.323 269.759 34.87 269.979 34.321 c
  270.202 33.76 270.309 33.116 270.301 32.391 c
  h
  272.46 46.1 m
  272.449 45.033 272.24 44.217 271.834 43.65 c
  271.442 43.068 270.772 42.641 269.824 42.37 c
  269.179 42.184 268.293 42.092 267.164 42.094 c
  266.037 42.096 264.861 42.107 263.634 42.125 c
  261.834 42.153 l
  261.922 50.543 l
  262.522 50.534 l
  264.836 50.498 266.492 50.466 267.492 50.435 c
  268.492 50.405 269.412 50.195 270.252 49.805 c
  271.106 49.415 271.686 48.909 271.992 48.285 c
  272.314 47.647 272.471 46.921 272.462 46.105 c
  f
  310 55.9 m
  287 56.25 l
  286.646 22.55 l
  294.866 22.425 l
  295.152 49.525 l
  309.952 49.3 l
  f
  332 55.6 m
  313.3 55.884 l
  313.237 49.914 l
  318.467 49.834 l
  318.239 28.134 l
  313.009 28.214 l
  312.946 22.244 l
  331.646 21.96 l
  331.709 27.93 l
  326.479 28.01 l
  326.707 49.71 l
  331.937 49.63 l
  f
  353 55.9 m
  350.627 55.936 348.43 55.599 346.41 54.89 c
  344.403 54.183 342.67 53.11 341.21 51.67 c
  339.75 50.23 338.61 48.423 337.79 46.25 c
  336.983 44.077 336.563 41.56 336.53 38.7 c
  336.502 36.033 336.855 33.61 337.59 31.43 c
  338.323 29.25 339.403 27.373 340.83 25.8 c
  342.197 24.287 343.897 23.107 345.93 22.26 c
  347.977 21.413 350.213 20.973 352.64 20.94 c
  353.98 20.92 355.187 20.984 356.26 21.134 c
  357.347 21.268 358.347 21.456 359.26 21.699 c
  360.22 21.971 361.087 22.282 361.86 22.632 c
  362.647 22.967 363.337 23.28 363.93 23.573 c
  364.016 31.733 l
  363.074 31.747 l
  362.67 31.392 362.16 30.969 361.544 30.477 c
  360.939 29.989 360.249 29.509 359.474 29.037 c
  358.68 28.567 357.827 28.174 356.914 27.857 c
  355.994 27.54 355.014 27.389 353.974 27.404 c
  352.82 27.422 351.724 27.635 350.684 28.042 c
  349.644 28.435 348.687 29.082 347.814 29.982 c
  346.98 30.856 346.307 32.002 345.794 33.422 c
  345.294 34.849 345.055 36.572 345.077 38.592 c
  345.099 40.699 345.396 42.459 345.968 43.872 c
  346.554 45.279 347.28 46.382 348.148 47.182 c
  349.028 47.996 350.004 48.576 351.078 48.922 c
  352.151 49.252 353.211 49.41 354.258 49.394 c
  355.258 49.379 356.241 49.206 357.208 48.874 c
  358.188 48.543 359.091 48.1 359.918 47.544 c
  360.611 47.096 361.254 46.62 361.848 46.114 c
  362.442 45.608 362.929 45.171 363.308 44.804 c
  364.165 44.791 l
  364.249 52.841 l
  363.456 53.23 362.696 53.597 361.969 53.941 c
  361.243 54.284 360.483 54.582 359.689 54.835 c
  358.649 55.168 357.673 55.424 356.759 55.603 c
  355.846 55.783 354.589 55.885 352.989 55.909 c
  f
  130 74.7 m
  129.991 73.853 129.819 73.133 129.485 72.54 c
  129.15 71.942 128.58 71.475 127.775 71.14 c
  127.216 70.907 126.566 70.774 125.825 70.74 c
  125.085 70.691 124.222 70.674 123.235 70.689 c
  120.255 70.734 l
  120.35 79.794 l
  122.88 79.756 l
  124.194 79.736 125.294 79.651 126.18 79.502 c
  127.067 79.352 127.807 79.032 128.4 78.541 c
  128.966 78.065 129.376 77.545 129.63 76.981 c
  129.896 76.404 130.023 75.641 130.013 74.691 c
  h
  143.1 97.9 m
  133.1 98.053 l
  124.27 85.853 l
  120.48 85.911 l
  120.61 98.211 l
  112.43 98.336 l
  112.076 64.636 l
  125.876 64.426 l
  127.763 64.397 129.386 64.485 130.746 64.691 c
  132.106 64.896 133.383 65.366 134.576 66.101 c
  135.783 66.834 136.743 67.801 137.456 69.001 c
  138.183 70.181 138.556 71.674 138.576 73.481 c
  138.602 75.967 138.072 78.004 136.986 79.591 c
  135.919 81.177 134.376 82.504 132.356 83.571 c
  f
  170 97.4 m
  146.9 97.751 l
  146.546 64.051 l
  169.646 63.7 l
  169.714 70.21 l
  154.814 70.437 l
  154.876 76.247 l
  168.676 76.037 l
  168.744 82.547 l
  154.944 82.757 l
  155.032 91.077 l
  169.932 90.85 l
  f
  200 97 m
  177 97.35 l
  176.646 63.65 l
  184.866 63.525 l
  185.152 90.625 l
  199.952 90.4 l
  f
  228 96.5 m
  204.9 96.851 l
  204.546 63.151 l
  227.646 62.8 l
  227.714 69.31 l
  212.814 69.537 l
  212.876 75.347 l
  226.676 75.137 l
  226.744 81.647 l
  212.944 81.857 l
  213.032 90.177 l
  227.932 89.95 l
  f
  264 96 m
  255.5 96.129 l
  253.22 89.359 l
  241.42 89.539 l
  239.29 96.379 l
  231 96.505 l
  242.4 62.705 l
  251.87 62.561 l
  h
  251.2 83.2 m
  247.15 71.2 l
  243.36 83.3 l
  f
  294 84.9 m
  294.035 88.213 292.728 90.93 290.08 93.05 c
  287.447 95.157 283.847 96.243 279.28 96.31 c
  276.64 96.35 274.33 96.144 272.35 95.692 c
  270.39 95.225 268.55 94.628 266.83 93.902 c
  266.745 85.832 l
  267.645 85.818 l
  269.358 87.225 271.268 88.295 273.375 89.028 c
  275.495 89.762 277.525 90.115 279.465 90.088 c
  279.965 90.081 280.622 90.025 281.435 89.922 c
  282.248 89.82 282.912 89.659 283.425 89.44 c
  284.05 89.16 284.56 88.813 284.955 88.4 c
  285.365 87.987 285.566 87.38 285.557 86.58 c
  285.549 85.84 285.243 85.21 284.637 84.69 c
  284.046 84.157 283.179 83.757 282.037 83.49 c
  280.837 83.207 279.564 82.948 278.217 82.712 c
  276.884 82.461 275.63 82.141 274.457 81.752 c
  271.764 80.872 269.817 79.659 268.617 78.112 c
  267.43 76.546 266.824 74.596 266.797 72.262 c
  266.764 69.129 268.064 66.556 270.697 64.542 c
  273.344 62.516 276.744 61.469 280.897 61.402 c
  282.997 61.37 285.07 61.557 287.117 61.963 c
  289.177 62.354 290.96 62.861 292.467 63.483 c
  292.549 71.233 l
  291.671 71.247 l
  290.377 70.18 288.791 69.3 286.911 68.607 c
  285.044 67.893 283.141 67.553 281.201 67.587 c
  280.514 67.597 279.831 67.66 279.151 67.777 c
  278.477 67.877 277.831 68.068 277.211 68.349 c
  276.656 68.583 276.183 68.937 275.791 69.409 c
  275.395 69.867 275.201 70.39 275.208 70.979 c
  275.217 71.865 275.545 72.545 276.193 73.019 c
  276.84 73.476 278.057 73.886 279.843 74.249 c
  281.016 74.487 282.139 74.719 283.213 74.944 c
  284.299 75.168 285.466 75.482 286.713 75.885 c
  289.166 76.691 290.976 77.818 292.143 79.265 c
  293.329 80.691 293.936 82.565 293.963 84.885 c
  f
  323 95.1 m
  299.9 95.451 l
  299.546 61.751 l
  322.646 61.4 l
  322.714 67.91 l
  307.815 68.137 l
  307.876 73.947 l
  321.676 73.737 l
  321.744 80.247 l
  307.944 80.457 l
  308.032 88.777 l
  322.932 88.55 l
  f  
  `,
    NOT_FOR_PUBLIC_RELEASE: `33.5 13.4 m
  404.5 6.92 l
  419.6 6.657 431.9 18.52 432.1 33.62 c
  432.89 78.92 l
  433.153 94.02 421.29 106.32 406.19 106.52 c
  35.19 113 l
  20.09 113.263 7.79 101.4 7.59 86.3 c
  6.8 41 l
  6.537 25.9 18.4 13.6 33.5 13.4 c
  s
  140 57.9 m
  132.53 58.021 l
  119.53 35.121 l
  119.759 58.221 l
  112.649 58.336 l
  112.315 24.636 l
  121.585 24.486 l
  132.785 43.586 l
  132.594 24.286 l
  139.704 24.171 l
  f
  177 40.5 m
  177.053 45.867 175.723 50.167 173.01 53.4 c
  170.297 56.593 166.53 58.23 161.71 58.31 c
  156.877 58.388 153.077 56.875 150.31 53.77 c
  147.53 50.65 146.113 46.417 146.06 41.07 c
  146.006 35.657 147.336 31.357 150.05 28.17 c
  152.763 24.977 156.53 23.34 161.35 23.26 c
  166.17 23.182 169.97 24.695 172.75 27.8 c
  175.543 30.887 176.967 35.153 177.02 40.6 c
  h
  166.8 49.19 m
  167.547 48.15 168.093 46.937 168.44 45.55 c
  168.789 44.143 168.955 42.497 168.936 40.61 c
  168.916 38.59 168.69 36.877 168.259 35.47 c
  167.828 34.063 167.271 32.927 166.589 32.06 c
  165.896 31.167 165.096 30.523 164.189 30.13 c
  163.296 29.737 162.366 29.549 161.399 29.565 c
  160.419 29.581 159.492 29.792 158.619 30.198 c
  157.759 30.604 156.972 31.264 156.259 32.178 c
  155.594 33.031 155.054 34.208 154.639 35.708 c
  154.236 37.195 154.045 38.915 154.064 40.868 c
  154.084 42.875 154.303 44.581 154.721 45.988 c
  155.152 47.381 155.709 48.518 156.391 49.398 c
  157.071 50.278 157.864 50.921 158.771 51.328 c
  159.678 51.735 160.628 51.931 161.621 51.915 c
  162.614 51.899 163.561 51.673 164.461 51.236 c
  165.361 50.785 166.141 50.101 166.801 49.186 c
  f
  207 29.7 m
  197.61 29.852 l
  197.879 56.952 l
  190.129 57.077 l
  189.86 29.977 l
  180.47 30.129 l
  180.406 23.619 l
  206.906 23.19 l
  f
  247 29 m
  233.2 29.223 l
  233.262 35.483 l
  246.062 35.276 l
  246.127 41.786 l
  233.327 41.993 l
  233.47 56.393 l
  225.76 56.518 l
  225.426 22.818 l
  246.926 22.47 l
  f
  282 38.8 m
  282.053 44.167 280.723 48.467 278.01 51.7 c
  275.297 54.893 271.53 56.53 266.71 56.61 c
  261.877 56.688 258.077 55.175 255.31 52.07 c
  252.53 48.95 251.113 44.717 251.06 39.37 c
  251.006 33.957 252.336 29.657 255.05 26.47 c
  257.763 23.277 261.53 21.64 266.35 21.56 c
  271.17 21.482 274.97 22.995 277.75 26.1 c
  280.543 29.187 281.967 33.453 282.02 38.9 c
  h
  271.8 47.49 m
  272.547 46.45 273.093 45.237 273.44 43.85 c
  273.789 42.443 273.955 40.797 273.936 38.91 c
  273.916 36.89 273.69 35.177 273.259 33.77 c
  272.828 32.363 272.271 31.227 271.589 30.36 c
  270.896 29.467 270.096 28.823 269.189 28.43 c
  268.296 28.037 267.366 27.849 266.399 27.865 c
  265.419 27.881 264.492 28.092 263.619 28.498 c
  262.759 28.904 261.972 29.564 261.259 30.478 c
  260.594 31.331 260.054 32.508 259.639 34.008 c
  259.236 35.495 259.045 37.215 259.064 39.168 c
  259.084 41.175 259.303 42.881 259.721 44.288 c
  260.152 45.681 260.709 46.818 261.391 47.698 c
  262.071 48.578 262.864 49.221 263.771 49.628 c
  264.678 50.035 265.628 50.231 266.621 50.215 c
  267.614 50.199 268.561 49.973 269.461 49.536 c
  270.361 49.085 271.141 48.401 271.801 47.486 c
  f
  304 31.9 m
  303.992 31.053 303.83 30.333 303.514 29.74 c
  303.199 29.142 302.662 28.675 301.904 28.34 c
  301.377 28.107 300.763 27.974 300.064 27.94 c
  299.364 27.891 298.551 27.874 297.624 27.889 c
  294.814 27.934 l
  294.904 36.994 l
  297.284 36.956 l
  298.524 36.936 299.561 36.851 300.394 36.702 c
  301.227 36.552 301.924 36.232 302.484 35.741 c
  303.018 35.265 303.405 34.745 303.644 34.181 c
  303.894 33.604 304.014 32.841 304.005 31.891 c
  h
  316.3 55.1 m
  306.83 55.253 l
  298.51 43.053 l
  294.94 43.111 l
  295.062 55.411 l
  287.352 55.536 l
  287.018 21.836 l
  300.018 21.626 l
  301.791 21.597 303.321 21.685 304.608 21.891 c
  305.888 22.096 307.091 22.566 308.218 23.301 c
  309.358 24.034 310.261 25.001 310.928 26.201 c
  311.615 27.381 311.965 28.874 311.978 30.681 c
  312.003 33.167 311.506 35.204 310.488 36.791 c
  309.481 38.377 308.028 39.704 306.128 40.771 c
  f
  52 75.7 m
  52.015 77.207 51.794 78.687 51.337 80.14 c
  50.88 81.58 50.22 82.797 49.357 83.79 c
  48.17 85.137 46.84 86.16 45.367 86.86 c
  43.907 87.56 42.08 87.93 39.887 87.97 c
  35.057 88.048 l
  35.166 99.048 l
  27.416 99.173 l
  27.082 65.473 l
  39.882 65.267 l
  41.795 65.236 43.405 65.398 44.712 65.754 c
  46.032 66.095 47.202 66.625 48.222 67.344 c
  49.442 68.211 50.375 69.334 51.022 70.714 c
  51.682 72.087 52.022 73.747 52.042 75.694 c
  h
  43.99 76.033 m
  43.981 75.086 43.744 74.276 43.279 73.603 c
  42.814 72.916 42.278 72.443 41.669 72.183 c
  40.856 71.834 40.066 71.651 39.299 71.633 c
  38.532 71.6 37.509 71.594 36.229 71.615 c
  34.899 71.636 l
  34.999 81.736 l
  37.219 81.7 l
  38.539 81.679 39.622 81.571 40.469 81.376 c
  41.329 81.182 42.046 80.808 42.619 80.256 c
  43.112 79.766 43.462 79.186 43.669 78.516 c
  43.891 77.836 43.997 77.013 43.988 76.046 c
  f
  83.9 86 m
  83.941 90.16 82.841 93.367 80.6 95.62 c
  78.36 97.873 75.04 99.033 70.64 99.1 c
  66.24 99.171 62.907 98.118 60.64 95.94 c
  58.373 93.76 57.217 90.6 57.17 86.46 c
  56.957 64.96 l
  64.747 64.834 l
  64.955 85.834 l
  64.978 88.167 65.431 89.901 66.315 91.034 c
  67.202 92.167 68.628 92.717 70.595 92.684 c
  72.535 92.653 73.942 92.079 74.815 90.964 c
  75.708 89.851 76.142 88.081 76.115 85.654 c
  75.907 64.654 l
  83.697 64.528 l
  f
  117 87.3 m
  117.016 88.927 116.734 90.387 116.155 91.68 c
  115.589 92.973 114.799 94.05 113.785 94.91 c
  112.612 95.923 111.312 96.653 109.885 97.1 c
  108.478 97.545 106.685 97.785 104.505 97.82 c
  91.405 98.032 l
  91.071 64.332 l
  102.771 64.144 l
  105.191 64.105 106.961 64.167 108.081 64.329 c
  109.214 64.492 110.334 64.872 111.441 65.469 c
  112.594 66.098 113.451 66.958 114.011 68.049 c
  114.587 69.122 114.882 70.362 114.896 71.769 c
  114.912 73.396 114.542 74.842 113.786 76.109 c
  113.033 77.356 111.959 77.356 110.566 76.109 c
  112.533 76.514 114.096 77.394 115.256 78.749 c
  116.429 80.102 117.026 81.902 117.046 84.149 c
  h
  106.9 73.6 m
  106.9 73.043 106.767 72.486 106.5 71.93 c
  106.252 71.376 105.812 70.969 105.18 70.71 c
  104.612 70.478 103.905 70.361 103.06 70.36 c
  102.227 70.343 101.05 70.347 99.53 70.372 c
  98.803 70.384 l
  98.874 77.504 l
  100.084 77.484 l
  101.31 77.464 102.354 77.425 103.214 77.366 c
  104.074 77.307 104.75 77.145 105.244 76.881 c
  105.937 76.523 106.39 76.07 106.604 75.521 c
  106.814 74.96 106.915 74.316 106.908 73.591 c
  h
  108.93 87.3 m
  108.919 86.233 108.723 85.417 108.34 84.85 c
  107.971 84.268 107.341 83.841 106.45 83.57 c
  105.843 83.384 105.006 83.292 103.94 83.294 c
  102.873 83.296 101.763 83.307 100.61 83.325 c
  98.91 83.353 l
  98.993 91.743 l
  99.558 91.733 l
  101.738 91.698 103.298 91.666 104.238 91.635 c
  105.178 91.605 106.045 91.395 106.838 91.005 c
  107.645 90.615 108.191 90.109 108.478 89.485 c
  108.781 88.847 108.929 88.121 108.921 87.305 c
  f
  144 97.2 m
  122.3 97.55 l
  121.966 63.85 l
  129.716 63.725 l
  129.985 90.825 l
  143.885 90.6 l
  f
  165 96.9 m
  147.4 97.184 l
  147.341 91.214 l
  152.271 91.134 l
  152.056 69.434 l
  147.126 69.514 l
  147.067 63.544 l
  164.667 63.26 l
  164.726 69.23 l
  159.796 69.31 l
  160.011 91.01 l
  164.941 90.93 l
  f
  185 97.2 m
  182.767 97.236 180.697 96.899 178.79 96.19 c
  176.897 95.483 175.263 94.41 173.89 92.97 c
  172.517 91.53 171.443 89.723 170.67 87.55 c
  169.91 85.377 169.513 82.86 169.48 80 c
  169.454 77.333 169.786 74.91 170.478 72.73 c
  171.171 70.55 172.188 68.673 173.528 67.1 c
  174.821 65.587 176.425 64.407 178.338 63.56 c
  180.271 62.713 182.381 62.273 184.668 62.24 c
  185.935 62.22 187.071 62.284 188.078 62.434 c
  189.105 62.568 190.048 62.756 190.908 62.999 c
  191.815 63.271 192.631 63.582 193.358 63.932 c
  194.105 64.267 194.755 64.58 195.308 64.873 c
  195.389 73.033 l
  194.501 73.047 l
  194.12 72.692 193.637 72.269 193.051 71.777 c
  192.481 71.289 191.831 70.809 191.101 70.337 c
  190.354 69.867 189.551 69.474 188.691 69.157 c
  187.824 68.84 186.901 68.689 185.921 68.704 c
  184.828 68.722 183.794 68.935 182.821 69.342 c
  181.841 69.735 180.938 70.382 180.111 71.282 c
  179.324 72.156 178.691 73.302 178.211 74.722 c
  177.74 76.149 177.515 77.872 177.535 79.892 c
  177.556 81.999 177.836 83.759 178.375 85.172 c
  178.928 86.579 179.611 87.682 180.425 88.482 c
  181.252 89.296 182.172 89.876 183.185 90.222 c
  184.198 90.552 185.195 90.71 186.175 90.694 c
  187.115 90.679 188.042 90.506 188.955 90.174 c
  189.882 89.843 190.732 89.4 191.505 88.844 c
  192.16 88.396 192.767 87.92 193.325 87.414 c
  193.886 86.908 194.346 86.471 194.705 86.104 c
  195.513 86.091 l
  195.593 94.141 l
  194.846 94.53 194.129 94.897 193.443 95.241 c
  192.763 95.584 192.046 95.882 191.293 96.135 c
  190.313 96.468 189.393 96.724 188.533 96.903 c
  f
  232 72.4 m
  231.992 71.553 231.83 70.833 231.514 70.24 c
  231.199 69.642 230.662 69.175 229.904 68.84 c
  229.377 68.607 228.763 68.474 228.064 68.44 c
  227.364 68.391 226.551 68.374 225.624 68.389 c
  222.814 68.434 l
  222.904 77.494 l
  225.284 77.456 l
  226.524 77.436 227.56 77.351 228.394 77.202 c
  229.227 77.052 229.924 76.732 230.484 76.241 c
  231.018 75.765 231.404 75.245 231.644 74.681 c
  231.894 74.104 232.014 73.341 232.005 72.391 c
  h
  244.3 95.6 m
  234.83 95.753 l
  226.51 83.553 l
  222.94 83.611 l
  223.062 95.911 l
  215.352 96.036 l
  215.018 62.336 l
  228.018 62.126 l
  229.791 62.097 231.321 62.185 232.608 62.391 c
  233.888 62.596 235.091 63.066 236.218 63.801 c
  237.358 64.534 238.261 65.501 238.928 66.701 c
  239.615 67.881 239.965 69.374 239.978 71.181 c
  240.003 73.667 239.506 75.704 238.488 77.291 c
  237.481 78.877 236.028 80.204 234.128 81.271 c
  f
  270 95.2 m
  248.3 95.551 l
  247.966 61.851 l
  269.666 61.5 l
  269.731 68.01 l
  255.731 68.237 l
  255.788 74.047 l
  268.788 73.837 l
  268.853 80.347 l
  255.853 80.557 l
  255.935 88.877 l
  269.935 88.65 l
  f
  298 94.7 m
  276.3 95.05 l
  275.966 61.35 l
  283.716 61.225 l
  283.985 88.325 l
  297.885 88.1 l
  f
  324 94.3 m
  302.3 94.651 l
  301.966 60.951 l
  323.666 60.6 l
  323.731 67.11 l
  309.731 67.337 l
  309.788 73.147 l
  322.788 72.937 l
  322.853 79.447 l
  309.853 79.657 l
  309.935 87.977 l
  323.935 87.75 l
  f
  359 93.7 m
  350.99 93.829 l
  348.84 87.059 l
  337.74 87.239 l
  335.73 94.079 l
  327.92 94.205 l
  338.72 60.405 l
  347.64 60.261 l
  h
  346.9 80.9 m
  343.09 68.9 l
  339.52 81 l
  f
  387 82.7 m
  387.033 86.013 385.8 88.73 383.3 90.85 c
  380.82 92.957 377.42 94.043 373.1 94.11 c
  370.613 94.15 368.437 93.944 366.57 93.492 c
  364.723 93.025 362.987 92.428 361.36 91.702 c
  361.28 83.632 l
  362.128 83.618 l
  363.741 85.025 365.541 86.095 367.528 86.828 c
  369.528 87.562 371.445 87.915 373.278 87.888 c
  373.749 87.881 374.369 87.825 375.138 87.722 c
  375.905 87.62 376.528 87.459 377.008 87.24 c
  377.597 86.96 378.077 86.613 378.448 86.2 c
  378.834 85.787 379.023 85.18 379.016 84.38 c
  379.009 83.64 378.72 83.01 378.149 82.49 c
  377.592 81.957 376.772 81.557 375.689 81.29 c
  374.556 81.007 373.356 80.748 372.089 80.512 c
  370.836 80.261 369.656 79.941 368.549 79.552 c
  366.009 78.672 364.172 77.459 363.039 75.912 c
  361.919 74.346 361.349 72.396 361.329 70.062 c
  361.298 66.929 362.525 64.356 365.009 62.342 c
  367.509 60.316 370.729 59.269 374.669 59.202 c
  376.649 59.17 378.602 59.357 380.529 59.763 c
  382.469 60.154 384.149 60.661 385.569 61.283 c
  385.646 69.033 l
  384.818 69.047 l
  383.598 67.98 382.101 67.1 380.328 66.407 c
  378.568 65.693 376.775 65.353 374.948 65.387 c
  374.302 65.397 373.655 65.46 373.008 65.577 c
  372.376 65.677 371.766 65.868 371.178 66.149 c
  370.655 66.383 370.209 66.737 369.838 67.209 c
  369.465 67.667 369.282 68.19 369.288 68.779 c
  369.297 69.665 369.606 70.345 370.217 70.819 c
  370.827 71.276 371.974 71.686 373.657 72.049 c
  374.764 72.287 375.824 72.519 376.837 72.744 c
  377.864 72.968 378.964 73.282 380.137 73.685 c
  382.444 74.491 384.15 75.618 385.257 77.065 c
  386.377 78.491 386.947 80.365 386.967 82.685 c
  f
  414 92.9 m
  392.3 93.251 l
  391.966 59.551 l
  413.666 59.2 l
  413.731 65.71 l
  399.731 65.937 l
  399.788 71.747 l
  412.788 71.537 l
  412.853 78.047 l
  399.853 78.257 l
  399.935 86.577 l
  413.935 86.35 l
  f
  `,
};
const stampCreationInfos = {
    "/Draft": {
        textStreamData: stampForms.DRAFT,
        color: stampColors.redColor,
        subject: "Draft",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/Approved": {
        textStreamData: stampForms.APPROVED,
        color: stampColors.greenColor,
        subject: "Approved",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/NotApproved": {
        textStreamData: stampForms.NOT_APPROVED,
        color: stampColors.redColor,
        subject: "Not Approved",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/Departmental": {
        textStreamData: stampForms.DEPARTMENTAL,
        color: stampColors.blueColor,
        subject: "Departmental",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/Confidential": {
        textStreamData: stampForms.CONFIDENTIAL,
        color: stampColors.redColor,
        subject: "Confidential",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/Final": {
        textStreamData: stampForms.FINAL,
        color: stampColors.redColor,
        subject: "Final",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/Expired": {
        textStreamData: stampForms.EXPIRED,
        color: stampColors.redColor,
        subject: "Expired",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/AsIs": {
        textStreamData: stampForms.AS_IS,
        color: stampColors.redColor,
        subject: "As Is",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/Sold": {
        textStreamData: stampForms.SOLD,
        color: stampColors.blueColor,
        subject: "Sold",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/Experimental": {
        textStreamData: stampForms.EXPERIMENTAL,
        color: stampColors.blueColor,
        subject: "Experimental",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/ForComment": {
        textStreamData: stampForms.FOR_COMMENT,
        color: stampColors.greenColor,
        subject: "For Comment",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/TopSecret": {
        textStreamData: stampForms.TOP_SECRET,
        color: stampColors.redColor,
        subject: "Top Secret",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/ForPublicRelease": {
        textStreamData: stampForms.FOR_PUBLIC_RELEASE,
        color: stampColors.greenColor,
        subject: "For Public Release",
        bBox: stampBBox,
        rect: stampRect,
    },
    "/NotForPublicRelease": {
        textStreamData: stampForms.NOT_FOR_PUBLIC_RELEASE,
        color: stampColors.redColor,
        subject: "Not For Public Release",
        bBox: stampBBox,
        rect: stampRect,
    },
};
class StampAnnotation extends MarkupAnnotation {
    constructor() {
        super(annotationTypes.STAMP);
        this.Name = stampTypes.DRAFT;
        this.IT = "/Stamp";
    }
    static createStandard(type, userName) {
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Stamp",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: userName || "unknown",
            textContent: null,
            rect: null,
            matrix: null,
            stampType: type,
            stampImageData: null,
        };
        return this.createFromDto(dto);
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Stamp") {
            throw new Error("Invalid annotation type");
        }
        const created = DateString.fromDate(new Date(dto.dateCreated));
        const modified = DateString.fromDate(new Date(dto.dateModified));
        const stampForm = new XFormStream();
        stampForm.LastModified = modified;
        stampForm.Filter = "/FlateDecode";
        const stampCreationInfo = stampCreationInfos[dto.stampType];
        if (!stampCreationInfo) {
            throw new Error(`Stamp type '${dto.stampType}' is not supported`);
        }
        stampForm.setTextStreamData(stampCreationInfo.textStreamData);
        const color = stampCreationInfo.color;
        const subject = stampCreationInfo.subject;
        const bBox = stampCreationInfo.bBox;
        stampForm.BBox = bBox;
        const r = color[0].toFixed(3);
        const g = color[1].toFixed(3);
        const b = color[2].toFixed(3);
        const colorString = `${r} ${g} ${b} rg ${r} ${g} ${b} RG`;
        const apStream = new XFormStream();
        apStream.LastModified = modified;
        apStream.BBox = bBox;
        apStream.Matrix = dto.matrix || [1, 0, 0, 1, 0, 0];
        apStream.Resources = new ResourceDict();
        apStream.Resources.setXObject("/Fm", stampForm);
        apStream.Filter = "/FlateDecode";
        apStream.setTextStreamData(`q 1 0 0 -1 0 ${bBox[3]} cm ${colorString} 1 j 8.58 w /Fm Do Q`);
        const annotation = new StampAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author || "unknown");
        annotation.M = modified;
        annotation.CreationDate = created;
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : LiteralString.fromString(subject);
        annotation.Subj = LiteralString.fromString(subject);
        annotation.Name = dto.stampType;
        annotation.Rect = dto.rect || stampCreationInfo.rect;
        annotation.C = color;
        annotation.CA = 1;
        annotation.apStream = apStream;
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new StampAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Name) {
            bytes.push(...encoder.encode("/Name "), ...encoder.encode(this.Name));
        }
        if (this.IT) {
            bytes.push(...encoder.encode("/IT "), ...encoder.encode(this.IT));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toDto() {
        var _a, _b, _c, _d, _e;
        return {
            annotationType: "/Stamp",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            stampType: this.Name,
            stampImageData: null,
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Name":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Name) {
            throw new Error("Not all required properties parsed");
        }
    }
}

const textNoteForms = {
    NOTE: `25 10 m
  175 10 l
  175 10 190 10 190 25 c
  190 135 l
  190 135 190 150 175 150 c
  95 150 l
  10 190 l
  35 150 l
  25 150 l
  25 150 10 150 10 135 c
  10 25 l
  10 25 10 10 25 10 c
  b  
  35 35 m
  165 35 l
  S  
  35 55 m
  165 55 l
  S
  35 75 m
  125 75 l
  S
  35 95 m
  165 95 l
  S
  35 115 m
  115 115 l
  S
  `,
};
const textNoteCreationInfos = {
    "/Note": {
        textStreamData: textNoteForms.NOTE,
        fillColor: [1, 1, 0.4],
        subject: "Note",
        bBox: [0, 0, 200, 200],
        rect: [0, 0, 25, 25],
    },
};
class TextAnnotation extends MarkupAnnotation {
    constructor() {
        super(annotationTypes.TEXT);
        this.Open = false;
        this.Name = annotationIconTypes.NOTE;
    }
    static createStandard(userName, color, type = annotationIconTypes.NOTE) {
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Text",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: userName || "unknown",
            textContent: null,
            rect: null,
            matrix: null,
            color,
            textNoteType: type,
        };
        return this.createFromDto(dto);
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Text") {
            throw new Error("Invalid annotation type");
        }
        const created = DateString.fromDate(new Date(dto.dateCreated));
        const modified = DateString.fromDate(new Date(dto.dateModified));
        const stampForm = new XFormStream();
        stampForm.LastModified = modified;
        stampForm.Filter = "/FlateDecode";
        const stampCreationInfo = textNoteCreationInfos[dto.textNoteType];
        if (!stampCreationInfo) {
            throw new Error(`Stamp type '${dto.textNoteType}' is not supported`);
        }
        stampForm.setTextStreamData(stampCreationInfo.textStreamData);
        const strokeColor = dto.color;
        const fillColor = stampCreationInfo.fillColor;
        const subject = stampCreationInfo.subject;
        const bBox = stampCreationInfo.bBox;
        stampForm.BBox = bBox;
        const strokeR = strokeColor[0].toFixed(3);
        const strokeG = strokeColor[1].toFixed(3);
        const strokeB = strokeColor[2].toFixed(3);
        const fillR = fillColor[0].toFixed(3);
        const fillG = fillColor[1].toFixed(3);
        const fillB = fillColor[2].toFixed(3);
        const strokeString = `${fillR} ${fillG} ${fillB} rg ${strokeR} ${strokeG} ${strokeB} RG`;
        const apStream = new XFormStream();
        apStream.LastModified = modified;
        apStream.BBox = bBox;
        apStream.Matrix = dto.matrix || [1, 0, 0, 1, 0, 0];
        apStream.Resources = new ResourceDict();
        apStream.Resources.setXObject("/Fm", stampForm);
        apStream.Filter = "/FlateDecode";
        apStream.setTextStreamData(`q 1 0 0 -1 0 ${bBox[3]} cm ${strokeString} 1 j 8.58 w /Fm Do Q`);
        const annotation = new TextAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author || "unknown");
        annotation.M = modified;
        annotation.CreationDate = created;
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : LiteralString.fromString(subject);
        annotation.Subj = LiteralString.fromString(subject);
        annotation.Name = dto.textNoteType;
        annotation.State = dto.textNoteState;
        annotation.StateModel = dto.textNoteStateModel;
        annotation.Rect = dto.rect || stampCreationInfo.rect;
        annotation.C = strokeColor;
        annotation.CA = 1;
        annotation.apStream = apStream;
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TextAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Open) {
            bytes.push(...encoder.encode("/Open "), ...encoder.encode(" " + this.Open));
        }
        if (this.Name) {
            bytes.push(...encoder.encode("/Name "), ...encoder.encode(this.Name));
        }
        if (this.State) {
            bytes.push(...encoder.encode("/State "), ...encoder.encode(this.State));
        }
        if (this.StateModel) {
            bytes.push(...encoder.encode("/StateModel "), ...encoder.encode(this.StateModel));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toDto() {
        var _a, _b, _c, _d, _e;
        const color = this.getColorRect();
        return {
            annotationType: "/Text",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            color,
            textNoteType: this.Name,
            textNoteState: this.State,
            textNoteStateModel: this.StateModel,
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Open":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/Name":
                        const iconType = parser.parseNameAt(i, true);
                        if (iconType && Object.values(annotationIconTypes)
                            .includes(iconType.value)) {
                            this.Name = iconType.value;
                            i = iconType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Name property value");
                        }
                        break;
                    case "/State":
                        const state = parser.parseNameAt(i, true);
                        if (state && Object.values(annotationMarkedStates)
                            .concat(Object.values(annotationReviewStates))
                            .includes(state.value)) {
                            this.State = state.value;
                            i = state.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /State property value");
                        }
                        break;
                    case "/StateModel":
                        const stateModelType = parser.parseNameAt(i, true);
                        if (stateModelType && Object.values(annotationStateModelTypes)
                            .includes(stateModelType.value)) {
                            this.StateModel = stateModelType.value;
                            i = stateModelType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /StateModel property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
    renderHandles() {
        return [];
    }
}

class InkAnnotation extends MarkupAnnotation {
    constructor() {
        super(annotationTypes.INK);
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Ink") {
            throw new Error("Invalid annotation type");
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new InkAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        annotation.InkList = dto.inkList;
        annotation.Rect = dto.rect;
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new InkAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.InkList) {
            bytes.push(...encoder.encode("/InkList "), codes.L_BRACKET);
            this.InkList.forEach(x => {
                bytes.push(codes.L_BRACKET);
                x.forEach(y => bytes.push(...encoder.encode(" " + y)));
                bytes.push(codes.R_BRACKET);
            });
            bytes.push(codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Ink",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            inkList: this.InkList,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        var _a;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/InkList":
                        i = parser.skipEmpty(i);
                        const inkType = parser.getValueTypeAt(i);
                        if (inkType === valueTypes.ARRAY) {
                            const inkList = [];
                            let inkArrayPos = ++i;
                            while (true) {
                                const sublist = parser.parseNumberArrayAt(inkArrayPos);
                                if (!sublist) {
                                    break;
                                }
                                inkList.push(sublist.value);
                                inkArrayPos = sublist.end + 1;
                            }
                            this.InkList = inkList;
                            break;
                        }
                        throw new Error("Can't parse /InkList property value");
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!((_a = this.InkList) === null || _a === void 0 ? void 0 : _a.length)) {
            throw new Error("Not all required properties parsed");
        }
        this.bakeRotation();
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        let colorString;
        if (!((_a = this.C) === null || _a === void 0 ? void 0 : _a.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_e = (_c = (_b = this.BS) === null || _b === void 0 ? void 0 : _b.W) !== null && _c !== void 0 ? _c : (_d = this.Border) === null || _d === void 0 ? void 0 : _d.width) !== null && _e !== void 0 ? _e : 1;
        const strokeDash = (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.D[0]) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.dash) !== null && _j !== void 0 ? _j : 3;
        const strokeGap = (_o = (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D[1]) !== null && _l !== void 0 ? _l : (_m = this.Border) === null || _m === void 0 ? void 0 : _m.gap) !== null && _o !== void 0 ? _o : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.LJ = lineJoinStyles.ROUND;
        gs.LC = lineCapStyles.ROUND;
        gs.D = [[strokeDash, strokeGap], 0];
        let streamTextData = `q ${colorString} /GS0 gs`;
        let px;
        let py;
        this.InkList.forEach(list => {
            px = list[0];
            py = list[1];
            streamTextData += `\n${px} ${py} m`;
            for (let i = 2; i < list.length; i = i + 2) {
                px = list[i];
                py = list[i + 1];
                streamTextData += `\n${px} ${py} l`;
            }
            streamTextData += "\nS";
        });
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
    applyCommonTransform(matrix) {
        var _a, _b, _c, _d;
        const dict = this._proxy || this;
        let x;
        let y;
        let xMin;
        let yMin;
        let xMax;
        let yMax;
        const vec = new Vec2();
        dict.InkList.forEach(list => {
            for (let i = 0; i < list.length; i = i + 2) {
                x = list[i];
                y = list[i + 1];
                vec.set(x, y).applyMat3(matrix);
                list[i] = vec.x;
                list[i + 1] = vec.y;
                if (!xMin || vec.x < xMin) {
                    xMin = vec.x;
                }
                if (!yMin || vec.y < yMin) {
                    yMin = vec.y;
                }
                if (!xMax || vec.x > xMax) {
                    xMax = vec.x;
                }
                if (!yMax || vec.y > yMax) {
                    yMax = vec.y;
                }
            }
        });
        const margin = ((_d = (_b = (_a = dict.BS) === null || _a === void 0 ? void 0 : _a.W) !== null && _b !== void 0 ? _b : (_c = dict.Border) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 1) / 2;
        xMin -= margin;
        yMin -= margin;
        xMax += margin;
        yMax += margin;
        this.Rect = [xMin, yMin, xMax, yMax];
        if (this._bBox) {
            const bBox = dict.getLocalBB();
            bBox.ll.set(xMin, yMin);
            bBox.lr.set(xMax, yMin);
            bBox.ur.set(xMax, yMax);
            bBox.ul.set(xMin, yMax);
        }
        this.generateApStream();
        dict.M = DateString.fromDate(new Date());
    }
    bakeRotation() {
        const angle = this.getCurrentRotation();
        const centerX = (this.Rect[0] + this.Rect[2]) / 2;
        const centerY = (this.Rect[1] + this.Rect[3]) / 2;
        const matrix = new Mat3()
            .applyTranslation(-centerX, -centerY)
            .applyRotation(angle)
            .applyTranslation(centerX, centerY);
        this.applyCommonTransform(matrix);
    }
}

class GeometricAnnotation extends MarkupAnnotation {
    constructor(type) {
        super(type);
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.IC) {
            bytes.push(...encoder.encode("/IC "), codes.L_BRACKET);
            this.IC.forEach(x => bytes.push(...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/IC":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class SquareAnnotation extends GeometricAnnotation {
    constructor() {
        super(annotationTypes.SQUARE);
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Square") {
            throw new Error("Invalid annotation type");
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new SquareAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        annotation.Rect = dto.rect;
        annotation.RD = dto.rectMargins;
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation._cloud = dto.cloud;
        annotation.generateApStream(dto.bbox, dto.matrix);
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new SquareAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.RD) {
            bytes.push(...encoder.encode("/RD "), codes.L_BRACKET, ...encoder.encode(this.RD[0] + ""), codes.WHITESPACE, ...encoder.encode(this.RD[1] + ""), codes.WHITESPACE, ...encoder.encode(this.RD[2] + ""), codes.WHITESPACE, ...encoder.encode(this.RD[3] + ""), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Square",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            rectMargins: this.RD,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            cloud: this._cloud,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/RD":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
    generateApStream(bbox, matrix) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        const streamBbox = bbox
            ? [bbox[0], bbox[1], bbox[2], bbox[3]]
            : [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        apStream.BBox = streamBbox;
        const streamMatrix = matrix
            ? [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]]
            : [1, 0, 0, 1, 0, 0];
        apStream.Matrix = streamMatrix;
        let colorString;
        if (!((_a = this.C) === null || _a === void 0 ? void 0 : _a.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_e = (_c = (_b = this.BS) === null || _b === void 0 ? void 0 : _b.W) !== null && _c !== void 0 ? _c : (_d = this.Border) === null || _d === void 0 ? void 0 : _d.width) !== null && _e !== void 0 ? _e : 1;
        const strokeDash = (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.D[0]) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.dash) !== null && _j !== void 0 ? _j : 3;
        const strokeGap = (_o = (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D[1]) !== null && _l !== void 0 ? _l : (_m = this.Border) === null || _m === void 0 ? void 0 : _m.gap) !== null && _o !== void 0 ? _o : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.D = [[strokeDash, strokeGap], 0];
        if (!this.RD) {
            const defaultMargin = this._cloud
                ? SquareAnnotation.cloudArcSize / 2
                : strokeWidth / 2;
            this.RD || (this.RD = [defaultMargin, defaultMargin, defaultMargin, defaultMargin]);
        }
        const bBoxToRectMat = AppearanceStreamRenderer
            .calcBBoxToRectMatrices(streamBbox, this.Rect, streamMatrix)
            .matAA;
        const invMatArray = Mat3.invert(bBoxToRectMat).toFloatShortArray();
        const { r: rotation } = apStream.matrix.getTRS();
        const marginsRotationMat = new Mat3().applyRotation(rotation);
        const boxLL = new Vec2(streamBbox[0], streamBbox[1]);
        const boxLR = new Vec2(streamBbox[2], streamBbox[1]);
        const boxUR = new Vec2(streamBbox[2], streamBbox[3]);
        const boxUL = new Vec2(streamBbox[0], streamBbox[3]);
        const [marginLeft, marginTop, marginRight, marginBottom] = this.RD;
        const marginLL = new Vec2(marginLeft, marginBottom).applyMat3(marginsRotationMat);
        const marginLR = new Vec2(-marginRight, marginBottom).applyMat3(marginsRotationMat);
        const marginUR = new Vec2(-marginRight, -marginTop).applyMat3(marginsRotationMat);
        const marginUL = new Vec2(marginLeft, -marginTop).applyMat3(marginsRotationMat);
        const trBoxLL = Vec2.applyMat3(boxLL, bBoxToRectMat).add(marginLL);
        const trBoxLR = Vec2.applyMat3(boxLR, bBoxToRectMat).add(marginLR);
        const trBoxUR = Vec2.applyMat3(boxUR, bBoxToRectMat).add(marginUR);
        const trBoxUL = Vec2.applyMat3(boxUL, bBoxToRectMat).add(marginUL);
        let streamTextData = `q ${colorString} /GS0 gs`;
        streamTextData += `\n${invMatArray[0]} ${invMatArray[1]} ${invMatArray[2]} ${invMatArray[3]} ${invMatArray[4]} ${invMatArray[5]} cm`;
        if (this._cloud) {
            gs.LC = lineCapStyles.ROUND;
            gs.LJ = lineJoinStyles.ROUND;
            const curveData = buildCloudCurveFromPolyline([
                trBoxLL.clone(),
                trBoxLR.clone(),
                trBoxUR.clone(),
                trBoxUL.clone(),
                trBoxLL.clone(),
            ], SquareAnnotation.cloudArcSize);
            streamTextData += `\n${curveData.start.x} ${curveData.start.y} m`;
            curveData.curves.forEach(x => {
                streamTextData += `\n${x[0].x} ${x[0].y} ${x[1].x} ${x[1].y} ${x[2].x} ${x[2].y} c`;
            });
            streamTextData += "\nS";
        }
        else {
            gs.LC = lineCapStyles.SQUARE;
            gs.LJ = lineJoinStyles.MITER;
            streamTextData += `\n${trBoxLL.x} ${trBoxLL.y} m`;
            streamTextData += `\n${trBoxLR.x} ${trBoxLR.y} l`;
            streamTextData += `\n${trBoxUR.x} ${trBoxUR.y} l`;
            streamTextData += `\n${trBoxUL.x} ${trBoxUL.y} l`;
            streamTextData += "\ns";
        }
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
    applyCommonTransform(matrix) {
        this.applyRectTransform(matrix);
        const dict = this._proxy || this;
        const stream = dict.apStream;
        if (stream) {
            const newApMatrix = Mat3.multiply(stream.matrix, matrix);
            dict.generateApStream(stream.BBox, newApMatrix.toFloatShortArray());
        }
        dict.M = DateString.fromDate(new Date());
    }
}
SquareAnnotation.cloudArcSize = 20;

class CircleAnnotation extends GeometricAnnotation {
    constructor() {
        super(annotationTypes.CIRCLE);
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Circle") {
            throw new Error("Invalid annotation type");
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new CircleAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        annotation.Rect = dto.rect;
        annotation.RD = dto.rectMargins;
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation._cloud = dto.cloud;
        annotation.generateApStream(dto.bbox, dto.matrix);
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new CircleAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.RD) {
            bytes.push(...encoder.encode("/RD "), codes.L_BRACKET, ...encoder.encode(this.RD[0] + ""), codes.WHITESPACE, ...encoder.encode(this.RD[1] + ""), codes.WHITESPACE, ...encoder.encode(this.RD[2] + ""), codes.WHITESPACE, ...encoder.encode(this.RD[3] + ""), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Circle",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            rectMargins: this.RD,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            cloud: this._cloud,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/RD":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
    generateApStream(bbox, matrix) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        const streamBbox = bbox
            ? [bbox[0], bbox[1], bbox[2], bbox[3]]
            : [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        apStream.BBox = streamBbox;
        const streamMatrix = matrix
            ? [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]]
            : [1, 0, 0, 1, 0, 0];
        apStream.Matrix = streamMatrix;
        let colorString;
        if (!((_a = this.C) === null || _a === void 0 ? void 0 : _a.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_e = (_c = (_b = this.BS) === null || _b === void 0 ? void 0 : _b.W) !== null && _c !== void 0 ? _c : (_d = this.Border) === null || _d === void 0 ? void 0 : _d.width) !== null && _e !== void 0 ? _e : 1;
        const strokeDash = (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.D[0]) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.dash) !== null && _j !== void 0 ? _j : 3;
        const strokeGap = (_o = (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D[1]) !== null && _l !== void 0 ? _l : (_m = this.Border) === null || _m === void 0 ? void 0 : _m.gap) !== null && _o !== void 0 ? _o : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.D = [[strokeDash, strokeGap], 0];
        gs.LC = lineCapStyles.ROUND;
        gs.LJ = lineJoinStyles.ROUND;
        if (!this.RD) {
            const defaultMargin = this._cloud
                ? CircleAnnotation.cloudArcSize / 2
                : strokeWidth / 2;
            this.RD || (this.RD = [defaultMargin, defaultMargin, defaultMargin, defaultMargin]);
        }
        const bBoxToRectMat = AppearanceStreamRenderer
            .calcBBoxToRectMatrices(streamBbox, this.Rect, streamMatrix)
            .matAA;
        const invMatArray = Mat3.invert(bBoxToRectMat).toFloatShortArray();
        const { r: rotation } = apStream.matrix.getTRS();
        const marginsRotationMat = new Mat3().applyRotation(rotation);
        const boxLL = new Vec2(streamBbox[0], streamBbox[1]);
        const boxLR = new Vec2(streamBbox[2], streamBbox[1]);
        const boxUR = new Vec2(streamBbox[2], streamBbox[3]);
        const boxUL = new Vec2(streamBbox[0], streamBbox[3]);
        const [marginLeft, marginTop, marginRight, marginBottom] = this.RD;
        const marginLL = new Vec2(marginLeft, marginBottom).applyMat3(marginsRotationMat);
        const marginLR = new Vec2(-marginRight, marginBottom).applyMat3(marginsRotationMat);
        const marginUR = new Vec2(-marginRight, -marginTop).applyMat3(marginsRotationMat);
        const marginUL = new Vec2(marginLeft, -marginTop).applyMat3(marginsRotationMat);
        const trBoxLL = Vec2.applyMat3(boxLL, bBoxToRectMat).add(marginLL);
        const trBoxLR = Vec2.applyMat3(boxLR, bBoxToRectMat).add(marginLR);
        const trBoxUR = Vec2.applyMat3(boxUR, bBoxToRectMat).add(marginUR);
        const trBoxUL = Vec2.applyMat3(boxUL, bBoxToRectMat).add(marginUL);
        const trBoxCenter = Vec2.add(trBoxLL, trBoxUR).multiplyByScalar(0.5);
        const trBoxLeft = Vec2.add(trBoxLL, trBoxUL).multiplyByScalar(0.5);
        const trBoxTop = Vec2.add(trBoxUL, trBoxUR).multiplyByScalar(0.5);
        const trBoxRight = Vec2.add(trBoxLR, trBoxUR).multiplyByScalar(0.5);
        const trBoxBottom = Vec2.add(trBoxLL, trBoxLR).multiplyByScalar(0.5);
        const rx = Vec2.substract(trBoxRight, trBoxLeft).multiplyByScalar(0.5);
        const ry = Vec2.substract(trBoxTop, trBoxBottom).multiplyByScalar(0.5);
        let streamTextData = `q ${colorString} /GS0 gs`;
        streamTextData += `\n${invMatArray[0]} ${invMatArray[1]} ${invMatArray[2]} ${invMatArray[3]} ${invMatArray[4]} ${invMatArray[5]} cm`;
        if (this._cloud) {
            const curveData = buildCloudCurveFromEllipse(rx.getMagnitude(), ry.getMagnitude(), CircleAnnotation.cloudArcSize, new Mat3().applyRotation(rotation).applyTranslation(trBoxCenter.x, trBoxCenter.y));
            streamTextData += `\n${curveData.start.x} ${curveData.start.y} m`;
            curveData.curves.forEach(x => {
                streamTextData += `\n${x[0].x} ${x[0].y} ${x[1].x} ${x[1].y} ${x[2].x} ${x[2].y} c`;
            });
            streamTextData += "\nS";
        }
        else {
            const c = bezierConstant;
            const cx = Vec2.multiplyByScalar(rx, c);
            const cy = Vec2.multiplyByScalar(ry, c);
            const controlTR1 = Vec2.add(Vec2.add(trBoxCenter, ry), cx);
            const controlTR2 = Vec2.add(Vec2.add(trBoxCenter, cy), rx);
            const controlRB1 = Vec2.add(Vec2.substract(trBoxCenter, cy), rx);
            const controlRB2 = Vec2.add(Vec2.substract(trBoxCenter, ry), cx);
            const controlBL1 = Vec2.substract(Vec2.substract(trBoxCenter, ry), cx);
            const controlBL2 = Vec2.substract(Vec2.substract(trBoxCenter, cy), rx);
            const controlLT1 = Vec2.substract(Vec2.add(trBoxCenter, cy), rx);
            const controlLT2 = Vec2.substract(Vec2.add(trBoxCenter, ry), cx);
            streamTextData += `\n${trBoxTop.x} ${trBoxTop.y} m`;
            streamTextData += `\n${controlTR1.x} ${controlTR1.y} ${controlTR2.x} ${controlTR2.y} ${trBoxRight.x} ${trBoxRight.y} c`;
            streamTextData += `\n${controlRB1.x} ${controlRB1.y} ${controlRB2.x} ${controlRB2.y} ${trBoxBottom.x} ${trBoxBottom.y} c`;
            streamTextData += `\n${controlBL1.x} ${controlBL1.y} ${controlBL2.x} ${controlBL2.y} ${trBoxLeft.x} ${trBoxLeft.y} c`;
            streamTextData += `\n${controlLT1.x} ${controlLT1.y} ${controlLT2.x} ${controlLT2.y} ${trBoxTop.x} ${trBoxTop.y} c`;
            streamTextData += "\ns";
        }
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
    applyCommonTransform(matrix) {
        this.applyRectTransform(matrix);
        const dict = this._proxy || this;
        const stream = dict.apStream;
        if (stream) {
            const newApMatrix = Mat3.multiply(stream.matrix, matrix);
            dict.generateApStream(stream.BBox, newApMatrix.toFloatShortArray());
        }
        dict.M = DateString.fromDate(new Date());
    }
}
CircleAnnotation.cloudArcSize = 20;

const polyIntents = {
    CLOUD: "/PolygonCloud",
    POLYGON_DIMENSION: "/PolygonDimension",
    POLYLINE_DIMENSION: "/PolyLineDimension",
};
class PolyAnnotation extends GeometricAnnotation {
    constructor(type) {
        super(type);
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Vertices) {
            bytes.push(...encoder.encode("/Vertices "), codes.L_BRACKET);
            this.Vertices.forEach(x => bytes.push(...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.IT) {
            bytes.push(...encoder.encode("/IT "), ...encoder.encode(this.IT));
        }
        if (this.Measure) {
            bytes.push(...encoder.encode("/Measure "), ...this.Measure.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Vertices":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/IT":
                        const intent = parser.parseNameAt(i, true);
                        if (intent) {
                            if (Object.values(polyIntents).includes(intent.value)) {
                                this.IT = intent.value;
                                i = intent.end + 1;
                                break;
                            }
                        }
                        throw new Error("Can't parse /IT property value");
                    case "/Measure":
                        const measureEntryType = parser.getValueTypeAt(i);
                        if (measureEntryType === valueTypes.REF) {
                            const measureDictId = ObjectId.parseRef(parser, i);
                            if (measureDictId && parseInfo.parseInfoGetter) {
                                const measureParseInfo = parseInfo.parseInfoGetter(measureDictId.value.id);
                                if (measureParseInfo) {
                                    const measureDict = MeasureDict.parse(measureParseInfo);
                                    if (measureDict) {
                                        this.Measure = measureDict.value;
                                        i = measureDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Measure value reference");
                        }
                        else if (measureEntryType === valueTypes.DICTIONARY) {
                            const measureDictBounds = parser.getDictBoundsAt(i);
                            if (measureDictBounds) {
                                const measureDict = MeasureDict.parse({ parser, bounds: measureDictBounds });
                                if (measureDict) {
                                    this.Measure = measureDict.value;
                                    i = measureDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /Measure value dictionary");
                        }
                        throw new Error(`Unsupported /Measure property value type: ${measureEntryType}`);
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Vertices) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class PolygonAnnotation extends PolyAnnotation {
    constructor() {
        super(annotationTypes.POLYGON);
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Polygon") {
            throw new Error("Invalid annotation type");
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new PolygonAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        annotation.Rect = dto.rect;
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.IT = dto.cloud
            ? polyIntents.CLOUD
            : polyIntents.POLYGON_DIMENSION;
        annotation.Vertices = dto.vertices;
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new PolygonAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        return superBytes;
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Square",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            vertices: this.Vertices,
            cloud: this.IT === polyIntents.CLOUD,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        this.bakeRotation();
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (!((_a = this.Vertices) === null || _a === void 0 ? void 0 : _a.length) || this.Vertices.length < 6) {
            return;
        }
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        let colorString;
        if (!((_b = this.C) === null || _b === void 0 ? void 0 : _b.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_f = (_d = (_c = this.BS) === null || _c === void 0 ? void 0 : _c.W) !== null && _d !== void 0 ? _d : (_e = this.Border) === null || _e === void 0 ? void 0 : _e.width) !== null && _f !== void 0 ? _f : 1;
        const strokeDash = (_k = (_h = (_g = this.BS) === null || _g === void 0 ? void 0 : _g.D[0]) !== null && _h !== void 0 ? _h : (_j = this.Border) === null || _j === void 0 ? void 0 : _j.dash) !== null && _k !== void 0 ? _k : 3;
        const strokeGap = (_p = (_m = (_l = this.BS) === null || _l === void 0 ? void 0 : _l.D[1]) !== null && _m !== void 0 ? _m : (_o = this.Border) === null || _o === void 0 ? void 0 : _o.gap) !== null && _p !== void 0 ? _p : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.D = [[strokeDash, strokeGap], 0];
        const list = this.Vertices;
        let streamTextData = `q ${colorString} /GS0 gs`;
        if (this.IT === polyIntents.CLOUD) {
            gs.LC = lineCapStyles.ROUND;
            gs.LJ = lineJoinStyles.ROUND;
            const vertices = [];
            for (let i = 0; i < list.length; i = i + 2) {
                vertices.push(new Vec2(list[i], list[i + 1]));
            }
            vertices.push(new Vec2(list[0], list[1]));
            const curveData = buildCloudCurveFromPolyline(vertices, PolygonAnnotation.cloudArcSize);
            streamTextData += `\n${curveData.start.x} ${curveData.start.y} m`;
            curveData.curves.forEach(x => {
                streamTextData += `\n${x[0].x} ${x[0].y} ${x[1].x} ${x[1].y} ${x[2].x} ${x[2].y} c`;
            });
            streamTextData += "\nS";
        }
        else {
            gs.LC = lineCapStyles.SQUARE;
            gs.LJ = lineJoinStyles.MITER;
            let px;
            let py;
            streamTextData += `\n${list[0]} ${list[1]} m`;
            for (let i = 2; i < list.length; i = i + 2) {
                px = list[i];
                py = list[i + 1];
                streamTextData += `\n${px} ${py} l`;
            }
            streamTextData += "\ns";
        }
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
    applyCommonTransform(matrix) {
        var _a, _b, _c, _d;
        const dict = this._proxy || this;
        let x;
        let y;
        let xMin;
        let yMin;
        let xMax;
        let yMax;
        const vec = new Vec2();
        const list = dict.Vertices;
        for (let i = 0; i < list.length; i = i + 2) {
            x = list[i];
            y = list[i + 1];
            vec.set(x, y).applyMat3(matrix);
            list[i] = vec.x;
            list[i + 1] = vec.y;
            if (!xMin || vec.x < xMin) {
                xMin = vec.x;
            }
            if (!yMin || vec.y < yMin) {
                yMin = vec.y;
            }
            if (!xMax || vec.x > xMax) {
                xMax = vec.x;
            }
            if (!yMax || vec.y > yMax) {
                yMax = vec.y;
            }
        }
        const halfStrokeWidth = ((_d = (_b = (_a = dict.BS) === null || _a === void 0 ? void 0 : _a.W) !== null && _b !== void 0 ? _b : (_c = dict.Border) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 1) / 2;
        const margin = dict.IT === polyIntents.CLOUD
            ? PolygonAnnotation.cloudArcSize / 2 + halfStrokeWidth
            : halfStrokeWidth;
        xMin -= margin;
        yMin -= margin;
        xMax += margin;
        yMax += margin;
        dict.Rect = [xMin, yMin, xMax, yMax];
        if (dict._bBox) {
            const bBox = dict.getLocalBB();
            bBox.ll.set(xMin, yMin);
            bBox.lr.set(xMax, yMin);
            bBox.ur.set(xMax, yMax);
            bBox.ul.set(xMin, yMax);
        }
        dict.generateApStream();
        dict.M = DateString.fromDate(new Date());
    }
    bakeRotation() {
        const angle = this.getCurrentRotation();
        const centerX = (this.Rect[0] + this.Rect[2]) / 2;
        const centerY = (this.Rect[1] + this.Rect[3]) / 2;
        const matrix = new Mat3()
            .applyTranslation(-centerX, -centerY)
            .applyRotation(angle)
            .applyTranslation(centerX, centerY);
        this.applyCommonTransform(matrix);
    }
}
PolygonAnnotation.cloudArcSize = 20;

class PolylineAnnotation extends PolyAnnotation {
    constructor() {
        super(annotationTypes.POLYLINE);
        this.LE = [lineEndingTypes.NONE, lineEndingTypes.NONE];
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Polyline") {
            throw new Error("Invalid annotation type");
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new PolylineAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        annotation.Rect = dto.rect;
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.IT = polyIntents.POLYLINE_DIMENSION;
        annotation.LE = dto.endingType || [lineEndingTypes.NONE, lineEndingTypes.NONE];
        annotation.Vertices = dto.vertices;
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new PolylineAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.LE) {
            bytes.push(...encoder.encode("/LE "), codes.L_BRACKET);
            this.LE.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(x)));
            bytes.push(codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Square",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            vertices: this.Vertices,
            endingType: this.LE,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/LE":
                        const lineEndings = parser.parseNameArrayAt(i, true);
                        if (lineEndings
                            && Object.values(lineEndingTypes).includes(lineEndings.value[0])
                            && Object.values(lineEndingTypes).includes(lineEndings.value[1])) {
                            this.LE = [
                                lineEndings.value[0],
                                lineEndings.value[1],
                            ];
                            i = lineEndings.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /LE property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        this.bakeRotation();
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (!((_a = this.Vertices) === null || _a === void 0 ? void 0 : _a.length) || this.Vertices.length < 4) {
            return;
        }
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        let colorString;
        if (!((_b = this.C) === null || _b === void 0 ? void 0 : _b.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_f = (_d = (_c = this.BS) === null || _c === void 0 ? void 0 : _c.W) !== null && _d !== void 0 ? _d : (_e = this.Border) === null || _e === void 0 ? void 0 : _e.width) !== null && _f !== void 0 ? _f : 1;
        const strokeDash = (_k = (_h = (_g = this.BS) === null || _g === void 0 ? void 0 : _g.D[0]) !== null && _h !== void 0 ? _h : (_j = this.Border) === null || _j === void 0 ? void 0 : _j.dash) !== null && _k !== void 0 ? _k : 3;
        const strokeGap = (_p = (_m = (_l = this.BS) === null || _l === void 0 ? void 0 : _l.D[1]) !== null && _m !== void 0 ? _m : (_o = this.Border) === null || _o === void 0 ? void 0 : _o.gap) !== null && _p !== void 0 ? _p : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.D = [[strokeDash, strokeGap], 0];
        gs.LC = lineCapStyles.SQUARE;
        gs.LJ = lineJoinStyles.MITER;
        const list = this.Vertices;
        let streamTextData = `q ${colorString} /GS0 gs`;
        let px;
        let py;
        streamTextData += `\n${list[0]} ${list[1]} m`;
        for (let i = 2; i < list.length; i = i + 2) {
            px = list[i];
            py = list[i + 1];
            streamTextData += `\n${px} ${py} l`;
        }
        streamTextData += "\nS";
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
    applyCommonTransform(matrix) {
        var _a, _b, _c, _d;
        const dict = this._proxy || this;
        let x;
        let y;
        let xMin;
        let yMin;
        let xMax;
        let yMax;
        const vec = new Vec2();
        const list = dict.Vertices;
        for (let i = 0; i < list.length; i = i + 2) {
            x = list[i];
            y = list[i + 1];
            vec.set(x, y).applyMat3(matrix);
            list[i] = vec.x;
            list[i + 1] = vec.y;
            if (!xMin || vec.x < xMin) {
                xMin = vec.x;
            }
            if (!yMin || vec.y < yMin) {
                yMin = vec.y;
            }
            if (!xMax || vec.x > xMax) {
                xMax = vec.x;
            }
            if (!yMax || vec.y > yMax) {
                yMax = vec.y;
            }
        }
        const margin = ((_d = (_b = (_a = dict.BS) === null || _a === void 0 ? void 0 : _a.W) !== null && _b !== void 0 ? _b : (_c = dict.Border) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 1) / 2;
        xMin -= margin;
        yMin -= margin;
        xMax += margin;
        yMax += margin;
        dict.Rect = [xMin, yMin, xMax, yMax];
        if (dict._bBox) {
            const bBox = dict.getLocalBB();
            bBox.ll.set(xMin, yMin);
            bBox.lr.set(xMax, yMin);
            bBox.ur.set(xMax, yMax);
            bBox.ul.set(xMin, yMax);
        }
        dict.generateApStream();
        dict.M = DateString.fromDate(new Date());
    }
    bakeRotation() {
        const angle = this.getCurrentRotation();
        const centerX = (this.Rect[0] + this.Rect[2]) / 2;
        const centerY = (this.Rect[1] + this.Rect[3]) / 2;
        const matrix = new Mat3()
            .applyTranslation(-centerX, -centerY)
            .applyRotation(angle)
            .applyTranslation(centerX, centerY);
        this.applyCommonTransform(matrix);
    }
}

const lineIntents = {
    ARROW: "/LineArrow",
    DIMENSION: "/LineDimension",
};
const captionPositions = {
    INLINE: "/Inline",
    TOP: "/Top",
};
class LineAnnotation extends GeometricAnnotation {
    constructor() {
        super(annotationTypes.LINE);
        this.IT = lineIntents.DIMENSION;
        this.LE = [lineEndingTypes.NONE, lineEndingTypes.NONE];
        this.LLE = 0;
        this.LL = 0;
        this.LLO = 0;
        this.Cap = false;
        this.CP = captionPositions.INLINE;
        this.CO = [0, 0];
        this.onLineEndHandlePointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.addEventListener("pointerup", this.onLineEndHandlePointerUp);
            document.addEventListener("pointerout", this.onLineEndHandlePointerUp);
            const target = e.target;
            const handleName = target.dataset["handleName"];
            switch (handleName) {
                case "start":
                    this._scaleHandleActive = "start";
                    break;
                case "end":
                    this._scaleHandleActive = "end";
                    break;
                default:
                    throw new Error(`Invalid handle name: ${handleName}`);
            }
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                document.addEventListener("pointermove", this.onLineEndHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onLineEndHandlePointerMove = (e) => {
            if (!e.isPrimary || !this._scaleHandleActive) {
                return;
            }
            const start = new Vec2(this.L[0], this.L[1]);
            const end = new Vec2(this.L[2], this.L[3]);
            let startTemp;
            let endTemp;
            if (this._scaleHandleActive === "start") {
                startTemp = this.convertClientCoordsToPage(e.clientX, e.clientY);
                endTemp = end.clone();
            }
            else {
                startTemp = start.clone();
                endTemp = this.convertClientCoordsToPage(e.clientX, e.clientY);
            }
            this._tempTransformationMatrix = mat3From4Vec2(start, end, startTemp, endTemp);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._tempTransformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onLineEndHandlePointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            document.removeEventListener("pointermove", this.onLineEndHandlePointerMove);
            document.removeEventListener("pointerup", this.onLineEndHandlePointerUp);
            document.removeEventListener("pointerout", this.onLineEndHandlePointerUp);
            this.applyTempTransform();
            this.updateRenderAsync();
        };
    }
    static createFromDto(dto) {
        if (dto.annotationType !== "/Line") {
            throw new Error("Invalid annotation type");
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new LineAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        annotation.Rect = dto.rect;
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.IT = dto.intent || lineIntents.DIMENSION;
        annotation.LE = dto.endingType || [lineEndingTypes.NONE, lineEndingTypes.NONE];
        annotation.L = dto.vertices;
        annotation.LL = dto.leaderLineLength || 0;
        annotation.LLE = dto.leaderLineExtension || 0;
        annotation.LLO = dto.leaderLineOffset || 0;
        annotation.Cap = dto.caption;
        annotation.CP = dto.captionPosition || captionPositions.INLINE;
        annotation.CO = dto.captionOffset || [0, 0];
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new LineAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.L) {
            bytes.push(...encoder.encode("/L "), codes.L_BRACKET, ...encoder.encode(this.L[0] + ""), codes.WHITESPACE, ...encoder.encode(this.L[1] + ""), codes.WHITESPACE, ...encoder.encode(this.L[2] + ""), codes.WHITESPACE, ...encoder.encode(this.L[3] + ""), codes.R_BRACKET);
        }
        if (this.LE) {
            bytes.push(...encoder.encode("/LE "), codes.L_BRACKET);
            this.LE.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.LL) {
            bytes.push(...encoder.encode("/LL "), ...encoder.encode(" " + this.LL));
        }
        if (this.LLE) {
            bytes.push(...encoder.encode("/LLE "), ...encoder.encode(" " + this.LLE));
        }
        if (this.Cap) {
            bytes.push(...encoder.encode("/Cap "), ...encoder.encode(" " + this.Cap));
        }
        if (this.IT) {
            bytes.push(...encoder.encode("/IT "), ...encoder.encode(this.IT));
        }
        if (this.LLO) {
            bytes.push(...encoder.encode("/LLO "), ...encoder.encode(" " + this.LLO));
        }
        if (this.CP) {
            bytes.push(...encoder.encode("/CP "), ...encoder.encode(this.CP));
        }
        if (this.Measure) {
            bytes.push(...encoder.encode("/Measure "), ...this.Measure.toArray(cryptInfo));
        }
        if (this.CO) {
            bytes.push(...encoder.encode("/CO "), codes.L_BRACKET, ...encoder.encode(this.CO[0] + ""), codes.WHITESPACE, ...encoder.encode(this.CO[1] + ""), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Square",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            vertices: this.L,
            intent: this.IT,
            endingType: this.LE,
            leaderLineLength: this.LL,
            leaderLineExtension: this.LLE,
            leaderLineOffset: this.LLO,
            caption: this.Cap,
            captionPosition: this.CP,
            captionOffset: this.CO,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/L":
                    case "/CO":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/LE":
                        const lineEndings = parser.parseNameArrayAt(i, true);
                        if (lineEndings
                            && Object.values(lineEndingTypes).includes(lineEndings.value[0])
                            && Object.values(lineEndingTypes).includes(lineEndings.value[1])) {
                            this.LE = [
                                lineEndings.value[0],
                                lineEndings.value[1],
                            ];
                            i = lineEndings.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /LE property value");
                        }
                        break;
                    case "/IT":
                        const intent = parser.parseNameAt(i, true);
                        if (intent) {
                            if (Object.values(lineIntents).includes(intent.value)) {
                                this.IT = intent.value;
                                i = intent.end + 1;
                                break;
                            }
                        }
                        throw new Error("Can't parse /IT property value");
                    case "/CP":
                        const captionPosition = parser.parseNameAt(i, true);
                        if (captionPosition && Object.values(captionPositions)
                            .includes(captionPosition.value)) {
                            this.CP = captionPosition.value;
                            i = captionPosition.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /CP property value");
                        }
                        break;
                    case "/LL":
                    case "/LLE":
                    case "/LLO":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Cap":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/Measure":
                        const measureEntryType = parser.getValueTypeAt(i);
                        if (measureEntryType === valueTypes.REF) {
                            const measureDictId = ObjectId.parseRef(parser, i);
                            if (measureDictId && parseInfo.parseInfoGetter) {
                                const measureParseInfo = parseInfo.parseInfoGetter(measureDictId.value.id);
                                if (measureParseInfo) {
                                    const measureDict = MeasureDict.parse(measureParseInfo);
                                    if (measureDict) {
                                        this.Measure = measureDict.value;
                                        i = measureDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /BS value reference");
                        }
                        else if (measureEntryType === valueTypes.DICTIONARY) {
                            const measureDictBounds = parser.getDictBoundsAt(i);
                            if (measureDictBounds) {
                                const measureDict = MeasureDict.parse({ parser, bounds: measureDictBounds });
                                if (measureDict) {
                                    this.Measure = measureDict.value;
                                    i = measureDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /Measure value dictionary");
                        }
                        throw new Error(`Unsupported /Measure property value type: ${measureEntryType}`);
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
    updateRect() {
        var _a, _b, _c, _d;
        const [x1, y1, x2, y2] = this.L;
        const start = new Vec2(x1, y1);
        const end = new Vec2(x2, y2);
        const length = Vec2.substract(end, start).getMagnitude();
        const strokeWidth = (_d = (_b = (_a = this.BS) === null || _a === void 0 ? void 0 : _a.W) !== null && _b !== void 0 ? _b : (_c = this.Border) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 1;
        const halfStrokeWidth = strokeWidth / 2;
        let marginLeader = 0;
        if (this.LL) {
            marginLeader = Math.max(Math.max(Math.abs(this.LL), Math.abs(this.LLE || 0)) + (this.LLO || 0), halfStrokeWidth);
        }
        let marginEnding = 0;
        if (this.LE[0] !== lineEndingTypes.NONE || this.LE[1] !== lineEndingTypes.NONE) {
            const endingSizeInner = Math.max(strokeWidth * LineAnnotation.lineEndingMultiplier, LineAnnotation.lineEndingMinimalSize);
            const endingSize = endingSizeInner + strokeWidth;
            marginEnding = endingSize / 2;
        }
        const marginSide = Math.max(marginEnding, halfStrokeWidth);
        const marginNonLateral = Math.max(marginEnding, marginLeader, halfStrokeWidth);
        const xMin = 0 - marginSide;
        const yMin = 0 - marginNonLateral;
        const xMax = length + marginSide;
        const yMax = 0 + marginNonLateral;
        const bbox = [new Vec2(xMin, yMin), new Vec2(xMax, yMax)];
        const xAlignedStart = new Vec2();
        const xAlignedEnd = new Vec2(length, 0);
        const matrix = mat3From4Vec2(xAlignedStart, xAlignedEnd, start, end);
        const localBox = this.getLocalBB();
        localBox.ll.set(bbox[0].x, bbox[0].y).applyMat3(matrix);
        localBox.lr.set(bbox[1].x, bbox[0].y).applyMat3(matrix);
        localBox.ur.set(bbox[1].x, bbox[1].y).applyMat3(matrix);
        localBox.ul.set(bbox[0].x, bbox[1].y).applyMat3(matrix);
        const { min: rectMin, max: rectMax } = vecMinMax(localBox.ll, localBox.lr, localBox.ur, localBox.ul);
        this.Rect = [rectMin.x, rectMin.y, rectMax.x, rectMax.y];
        return { bbox, matrix };
    }
    getLineEndingStreamText(point, type, side) {
        var _a, _b, _c, _d;
        const strokeWidth = (_d = (_b = (_a = this.BS) === null || _a === void 0 ? void 0 : _a.W) !== null && _b !== void 0 ? _b : (_c = this.Border) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : 1;
        const size = Math.max(strokeWidth * LineAnnotation.lineEndingMultiplier, LineAnnotation.lineEndingMinimalSize);
        let text = "";
        switch (type) {
            case lineEndingTypes.ARROW_OPEN:
                if (side === "left") {
                    text += `\n${point.x + size} ${point.y + size / 2} m`;
                    text += `\n${point.x} ${point.y} l`;
                    text += `\n${point.x + size} ${point.y - size / 2} l`;
                }
                else {
                    text += `\n${point.x - size} ${point.y + size / 2} m`;
                    text += `\n${point.x} ${point.y} l`;
                    text += `\n${point.x - size} ${point.y - size / 2} l`;
                }
                text += "\nS";
                return text;
            case lineEndingTypes.ARROW_OPEN_R:
                if (side === "left") {
                    text += `\n${point.x} ${point.y + size / 2} m`;
                    text += `\n${point.x + size} ${point.y} l`;
                    text += `\n${point.x} ${point.y - size / 2} l`;
                }
                else {
                    text += `\n${point.x} ${point.y + size / 2} m`;
                    text += `\n${point.x - size} ${point.y} l`;
                    text += `\n${point.x} ${point.y - size / 2} l`;
                }
                text += "\nS";
                return text;
            case lineEndingTypes.ARROW_CLOSED:
                if (side === "left") {
                    text += `\n${point.x + size} ${point.y + size / 2} m`;
                    text += `\n${point.x} ${point.y} l`;
                    text += `\n${point.x + size} ${point.y - size / 2} l`;
                }
                else {
                    text += `\n${point.x - size} ${point.y + size / 2} m`;
                    text += `\n${point.x} ${point.y} l`;
                    text += `\n${point.x - size} ${point.y - size / 2} l`;
                }
                text += "\ns";
                return text;
            case lineEndingTypes.ARROW_CLOSED_R:
                if (side === "left") {
                    text += `\n${point.x + size} ${point.y} m`;
                    text += `\n${point.x} ${point.y + size / 2} l`;
                    text += `\n${point.x} ${point.y - size / 2} l`;
                }
                else {
                    text += `\n${point.x - size} ${point.y} m`;
                    text += `\n${point.x} ${point.y - size / 2} l`;
                    text += `\n${point.x} ${point.y + size / 2} l`;
                }
                text += "\ns";
                return text;
            case lineEndingTypes.BUTT:
                text += `\n${point.x} ${point.y + size / 2} m`;
                text += `\n${point.x} ${point.y - size / 2} l`;
                text += "\nS";
                return text;
            case lineEndingTypes.SLASH:
                text += `\n${point.x + size / 2} ${point.y + size / 2} m`;
                text += `\n${point.x - size / 2} ${point.y - size / 2} l`;
                text += "\nS";
                return text;
            case lineEndingTypes.DIAMOND:
                text += `\n${point.x} ${point.y + size / 2} m`;
                text += `\n${point.x + size / 2} ${point.y} l`;
                text += `\n${point.x} ${point.y - size / 2} l`;
                text += `\n${point.x - size / 2} ${point.y} l`;
                text += "\ns";
                return text;
            case lineEndingTypes.SQUARE:
                text += `\n${point.x - size / 2} ${point.y + size / 2} m`;
                text += `\n${point.x + size / 2} ${point.y + size / 2} l`;
                text += `\n${point.x + size / 2} ${point.y - size / 2} l`;
                text += `\n${point.x - size / 2} ${point.y - size / 2} l`;
                text += "\ns";
                return text;
            case lineEndingTypes.CIRCLE:
                const c = bezierConstant;
                const r = size / 2;
                const cw = c * r;
                const xmin = point.x - r;
                const ymin = point.y - r;
                const xmax = point.x + r;
                const ymax = point.y + r;
                text += `\n${point.x} ${ymax} m`;
                text += `\n${point.x + cw} ${ymax} ${xmax} ${point.y + cw} ${xmax} ${point.y} c`;
                text += `\n${xmax} ${point.y - cw} ${point.x + cw} ${ymin} ${point.x} ${ymin} c`;
                text += `\n${point.x - cw} ${ymin} ${xmin} ${point.y - cw} ${xmin} ${point.y} c`;
                text += `\n${xmin} ${point.y + cw} ${point.x - cw} ${ymax} ${point.x} ${ymax} c`;
                text += "\nS";
                return text;
            case lineEndingTypes.NONE:
            default:
                return "";
        }
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (!this.L) {
            return;
        }
        const data = this.updateRect();
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [data.bbox[0].x, data.bbox[0].y, data.bbox[1].x, data.bbox[1].y];
        apStream.Matrix = data.matrix.toFloatShortArray();
        let colorString;
        if (!((_a = this.C) === null || _a === void 0 ? void 0 : _a.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_e = (_c = (_b = this.BS) === null || _b === void 0 ? void 0 : _b.W) !== null && _c !== void 0 ? _c : (_d = this.Border) === null || _d === void 0 ? void 0 : _d.width) !== null && _e !== void 0 ? _e : 1;
        const strokeDash = (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.D[0]) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.dash) !== null && _j !== void 0 ? _j : 3;
        const strokeGap = (_o = (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D[1]) !== null && _l !== void 0 ? _l : (_m = this.Border) === null || _m === void 0 ? void 0 : _m.gap) !== null && _o !== void 0 ? _o : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.D = [[strokeDash, strokeGap], 0];
        gs.LC = lineCapStyles.SQUARE;
        gs.LJ = lineJoinStyles.MITER;
        const matrixInv = Mat3.invert(data.matrix);
        const apStart = new Vec2(this.L[0], this.L[1]).applyMat3(matrixInv).truncate();
        const apEnd = new Vec2(this.L[2], this.L[3]).applyMat3(matrixInv).truncate();
        let streamTextData = `q ${colorString} /GS0 gs`;
        streamTextData += `\n${apStart.x} ${apStart.y} m`;
        streamTextData += `\n${apEnd.x} ${apEnd.y} l`;
        streamTextData += "\nS";
        if (this.LL) {
            if (this.LL > 0) {
                streamTextData += `\n${apStart.x} ${apStart.y - Math.abs(this.LL)} m`;
                streamTextData += `\n${apStart.x} ${apStart.y + this.LLE} l`;
                streamTextData += "\nS";
            }
            else {
                streamTextData += `\n${apStart.x} ${apStart.y + Math.abs(this.LL)} m`;
                streamTextData += `\n${apStart.x} ${apStart.y - this.LLE} l`;
                streamTextData += "\nS";
            }
        }
        const leftEnding = this.getLineEndingStreamText(apStart, this.LE[0], "left");
        const rightEnding = this.getLineEndingStreamText(apEnd, this.LE[1], "right");
        streamTextData += leftEnding + rightEnding;
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
    applyCommonTransform(matrix) {
        const dict = this._proxy || this;
        const [x1, y1, x2, y2] = dict.L;
        const start = new Vec2(x1, y1).applyMat3(matrix);
        const end = new Vec2(x2, y2).applyMat3(matrix);
        dict.L = [start.x, start.y, end.x, end.y];
        dict.generateApStream();
        dict.M = DateString.fromDate(new Date());
    }
    renderHandles() {
        return [...this.renderLineEndHandles(), this.renderRotationHandle()];
    }
    renderLineEndHandles() {
        const startHandle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        startHandle.classList.add("svg-annot-handle-scale");
        startHandle.setAttribute("data-handle-name", "start");
        startHandle.setAttribute("cx", this.L[0] + "");
        startHandle.setAttribute("cy", this.L[1] + "");
        startHandle.addEventListener("pointerdown", this.onLineEndHandlePointerDown);
        const endHandle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        endHandle.classList.add("svg-annot-handle-scale");
        endHandle.setAttribute("data-handle-name", "end");
        endHandle.setAttribute("cx", this.L[2] + "");
        endHandle.setAttribute("cy", this.L[3] + "");
        endHandle.addEventListener("pointerdown", this.onLineEndHandlePointerDown);
        return [startHandle, endHandle];
    }
}
LineAnnotation.lineEndingMultiplier = 3;
LineAnnotation.lineEndingMinimalSize = 10;

class TextMarkupAnnotation extends MarkupAnnotation {
    constructor(type) {
        super(type);
        this.onTranslationPointerDown = (e) => { };
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.QuadPoints) {
            bytes.push(...encoder.encode("/QuadPoints "), codes.L_BRACKET);
            this.QuadPoints.forEach(x => bytes.push(...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/QuadPoints":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.QuadPoints) {
            throw new Error("Not all required properties parsed");
        }
    }
    renderHandles() {
        return [];
    }
}

class HighlightAnnotation extends TextMarkupAnnotation {
    constructor() {
        super(annotationTypes.HIGHLIGHT);
    }
    static createFromDto(dto) {
        var _a;
        if (dto.annotationType !== "/Highlight") {
            throw new Error("Invalid annotation type");
        }
        if (!((_a = dto === null || dto === void 0 ? void 0 : dto.quadPoints) === null || _a === void 0 ? void 0 : _a.length) || dto.quadPoints.length % 8) {
            return;
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new HighlightAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        if (dto.rect) {
            annotation.Rect = dto.rect;
        }
        else {
            const vectors = [];
            for (let i = 0; i < dto.quadPoints.length; i += 2) {
                vectors.push(new Vec2(dto.quadPoints[i], dto.quadPoints[i + 1]));
            }
            const { min, max } = vecMinMax(...vectors);
            annotation.Rect = [min.x, min.y, max.x, max.y];
        }
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.QuadPoints = dto.quadPoints;
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new HighlightAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        return superBytes;
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Highlight",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            quadPoints: this.QuadPoints,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (!((_a = this.QuadPoints) === null || _a === void 0 ? void 0 : _a.length) || this.QuadPoints.length % 8) {
            return;
        }
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        let colorString;
        if (!((_b = this.C) === null || _b === void 0 ? void 0 : _b.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_f = (_d = (_c = this.BS) === null || _c === void 0 ? void 0 : _c.W) !== null && _d !== void 0 ? _d : (_e = this.Border) === null || _e === void 0 ? void 0 : _e.width) !== null && _f !== void 0 ? _f : 1;
        const strokeDash = (_k = (_h = (_g = this.BS) === null || _g === void 0 ? void 0 : _g.D[0]) !== null && _h !== void 0 ? _h : (_j = this.Border) === null || _j === void 0 ? void 0 : _j.dash) !== null && _k !== void 0 ? _k : 3;
        const strokeGap = (_p = (_m = (_l = this.BS) === null || _l === void 0 ? void 0 : _l.D[1]) !== null && _m !== void 0 ? _m : (_o = this.Border) === null || _o === void 0 ? void 0 : _o.gap) !== null && _p !== void 0 ? _p : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.LC = lineCapStyles.SQUARE;
        gs.LJ = lineJoinStyles.MITER;
        gs.D = [[strokeDash, strokeGap], 0];
        let streamTextData = `q ${colorString} /GS0 gs`;
        const bottomLeft = new Vec2();
        const bottomRight = new Vec2();
        const topRight = new Vec2();
        const topLeft = new Vec2();
        const q = this.QuadPoints;
        for (let i = 0; i < q.length; i += 8) {
            bottomLeft.set(q[i + 4], q[i + 5]);
            bottomRight.set(q[i + 6], q[i + 7]);
            topRight.set(q[i + 2], q[i + 3]);
            topLeft.set(q[i + 0], q[i + 1]);
            streamTextData += `\n${bottomLeft.x} ${bottomLeft.y} m`;
            streamTextData += `\n${bottomRight.x} ${bottomRight.y} l`;
            streamTextData += `\n${topRight.x} ${topRight.y} l`;
            streamTextData += `\n${topLeft.x} ${topLeft.y} l`;
            streamTextData += "\nf";
        }
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
}

class UnderlineAnnotation extends TextMarkupAnnotation {
    constructor() {
        super(annotationTypes.UNDERLINE);
    }
    static createFromDto(dto) {
        var _a;
        if (dto.annotationType !== "/Underline") {
            throw new Error("Invalid annotation type");
        }
        if (!((_a = dto === null || dto === void 0 ? void 0 : dto.quadPoints) === null || _a === void 0 ? void 0 : _a.length) || dto.quadPoints.length % 8) {
            return;
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new UnderlineAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        if (dto.rect) {
            annotation.Rect = dto.rect;
        }
        else {
            const vectors = [];
            for (let i = 0; i < dto.quadPoints.length; i += 2) {
                vectors.push(new Vec2(dto.quadPoints[i], dto.quadPoints[i + 1]));
            }
            const { min, max } = vecMinMax(...vectors);
            const margin = dto.strokeWidth
                ? dto.strokeWidth / 2
                : 1;
            annotation.Rect = [min.x - margin, min.y - margin, max.x + margin, max.y + margin];
        }
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.QuadPoints = dto.quadPoints;
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new UnderlineAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        return superBytes;
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Underline",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            quadPoints: this.QuadPoints,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (!((_a = this.QuadPoints) === null || _a === void 0 ? void 0 : _a.length) || this.QuadPoints.length % 8) {
            return;
        }
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        let colorString;
        if (!((_b = this.C) === null || _b === void 0 ? void 0 : _b.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_f = (_d = (_c = this.BS) === null || _c === void 0 ? void 0 : _c.W) !== null && _d !== void 0 ? _d : (_e = this.Border) === null || _e === void 0 ? void 0 : _e.width) !== null && _f !== void 0 ? _f : 1;
        const strokeDash = (_k = (_h = (_g = this.BS) === null || _g === void 0 ? void 0 : _g.D[0]) !== null && _h !== void 0 ? _h : (_j = this.Border) === null || _j === void 0 ? void 0 : _j.dash) !== null && _k !== void 0 ? _k : 3;
        const strokeGap = (_p = (_m = (_l = this.BS) === null || _l === void 0 ? void 0 : _l.D[1]) !== null && _m !== void 0 ? _m : (_o = this.Border) === null || _o === void 0 ? void 0 : _o.gap) !== null && _p !== void 0 ? _p : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.LC = lineCapStyles.SQUARE;
        gs.LJ = lineJoinStyles.MITER;
        gs.D = [[strokeDash, strokeGap], 0];
        let streamTextData = `q ${colorString} /GS0 gs`;
        const bottomLeft = new Vec2();
        const bottomRight = new Vec2();
        const q = this.QuadPoints;
        for (let i = 0; i < q.length; i += 8) {
            bottomLeft.set(q[i + 4], q[i + 5]);
            bottomRight.set(q[i + 6], q[i + 7]);
            streamTextData += `\n${bottomLeft.x} ${bottomLeft.y} m`;
            streamTextData += `\n${bottomRight.x} ${bottomRight.y} l`;
            streamTextData += "\nS";
        }
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
}

class StrikeoutAnnotation extends TextMarkupAnnotation {
    constructor() {
        super(annotationTypes.STRIKEOUT);
    }
    static createFromDto(dto) {
        var _a;
        if (dto.annotationType !== "/Strikeout") {
            throw new Error("Invalid annotation type");
        }
        if (!((_a = dto === null || dto === void 0 ? void 0 : dto.quadPoints) === null || _a === void 0 ? void 0 : _a.length) || dto.quadPoints.length % 8) {
            return;
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new StrikeoutAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        if (dto.rect) {
            annotation.Rect = dto.rect;
        }
        else {
            const vectors = [];
            for (let i = 0; i < dto.quadPoints.length; i += 2) {
                vectors.push(new Vec2(dto.quadPoints[i], dto.quadPoints[i + 1]));
            }
            const { min, max } = vecMinMax(...vectors);
            annotation.Rect = [min.x, min.y, max.x, max.y];
        }
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.QuadPoints = dto.quadPoints;
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new StrikeoutAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        return superBytes;
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Strikeout",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            quadPoints: this.QuadPoints,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (!((_a = this.QuadPoints) === null || _a === void 0 ? void 0 : _a.length) || this.QuadPoints.length % 8) {
            return;
        }
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        let colorString;
        if (!((_b = this.C) === null || _b === void 0 ? void 0 : _b.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_f = (_d = (_c = this.BS) === null || _c === void 0 ? void 0 : _c.W) !== null && _d !== void 0 ? _d : (_e = this.Border) === null || _e === void 0 ? void 0 : _e.width) !== null && _f !== void 0 ? _f : 1;
        const strokeDash = (_k = (_h = (_g = this.BS) === null || _g === void 0 ? void 0 : _g.D[0]) !== null && _h !== void 0 ? _h : (_j = this.Border) === null || _j === void 0 ? void 0 : _j.dash) !== null && _k !== void 0 ? _k : 3;
        const strokeGap = (_p = (_m = (_l = this.BS) === null || _l === void 0 ? void 0 : _l.D[1]) !== null && _m !== void 0 ? _m : (_o = this.Border) === null || _o === void 0 ? void 0 : _o.gap) !== null && _p !== void 0 ? _p : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.LC = lineCapStyles.SQUARE;
        gs.LJ = lineJoinStyles.MITER;
        gs.D = [[strokeDash, strokeGap], 0];
        let streamTextData = `q ${colorString} /GS0 gs`;
        const bottomLeft = new Vec2();
        const bottomRight = new Vec2();
        const topRight = new Vec2();
        const topLeft = new Vec2();
        const start = new Vec2();
        const end = new Vec2();
        const q = this.QuadPoints;
        for (let i = 0; i < q.length; i += 8) {
            bottomLeft.set(q[i + 4], q[i + 5]);
            bottomRight.set(q[i + 6], q[i + 7]);
            topRight.set(q[i + 2], q[i + 3]);
            topLeft.set(q[i + 0], q[i + 1]);
            start.setFromVec2(bottomLeft).add(topLeft).multiplyByScalar(0.5);
            end.setFromVec2(bottomRight).add(topRight).multiplyByScalar(0.5);
            streamTextData += `\n${start.x} ${start.y} m`;
            streamTextData += `\n${end.x} ${end.y} l`;
            streamTextData += "\nS";
        }
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
}

class SquigglyAnnotation extends TextMarkupAnnotation {
    constructor() {
        super(annotationTypes.SQUIGGLY);
    }
    static createFromDto(dto) {
        var _a;
        if (dto.annotationType !== "/Squiggly") {
            throw new Error("Invalid annotation type");
        }
        if (!((_a = dto === null || dto === void 0 ? void 0 : dto.quadPoints) === null || _a === void 0 ? void 0 : _a.length) || dto.quadPoints.length % 8) {
            return;
        }
        const bs = new BorderStyleDict();
        bs.W = dto.strokeWidth;
        if (dto.strokeDashGap) {
            bs.D = dto.strokeDashGap;
        }
        const annotation = new SquigglyAnnotation();
        annotation.$name = dto.uuid;
        annotation.NM = LiteralString.fromString(dto.uuid);
        annotation.T = LiteralString.fromString(dto.author);
        annotation.M = DateString.fromDate(new Date(dto.dateModified));
        annotation.CreationDate = DateString.fromDate(new Date(dto.dateCreated));
        annotation.Contents = dto.textContent
            ? LiteralString.fromString(dto.textContent)
            : null;
        if (dto.rect) {
            annotation.Rect = dto.rect;
        }
        else {
            const vectors = [];
            for (let i = 0; i < dto.quadPoints.length; i += 2) {
                vectors.push(new Vec2(dto.quadPoints[i], dto.quadPoints[i + 1]));
            }
            const { min, max } = vecMinMax(...vectors);
            const margin = this.squiggleSize / 2 + (dto.strokeWidth || 2) / 2;
            annotation.Rect = [min.x - margin, min.y - margin, max.x + margin, max.y + margin];
        }
        annotation.C = dto.color.slice(0, 3);
        annotation.CA = dto.color[3];
        annotation.BS = bs;
        annotation.QuadPoints = dto.quadPoints;
        annotation.generateApStream();
        const proxy = new Proxy(annotation, annotation.onChange);
        annotation._proxy = proxy;
        annotation._added = true;
        return proxy;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new SquigglyAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        return superBytes;
    }
    toDto() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const color = this.getColorRect();
        return {
            annotationType: "/Squiggly",
            uuid: this.$name,
            pageId: this.$pageId,
            dateCreated: ((_a = this.CreationDate) === null || _a === void 0 ? void 0 : _a.date.toISOString()) || new Date().toISOString(),
            dateModified: this.M
                ? this.M instanceof LiteralString
                    ? this.M.literal
                    : this.M.date.toISOString()
                : new Date().toISOString(),
            author: (_b = this.T) === null || _b === void 0 ? void 0 : _b.literal,
            textContent: (_c = this.Contents) === null || _c === void 0 ? void 0 : _c.literal,
            rect: this.Rect,
            bbox: (_d = this.apStream) === null || _d === void 0 ? void 0 : _d.BBox,
            matrix: (_e = this.apStream) === null || _e === void 0 ? void 0 : _e.Matrix,
            quadPoints: this.QuadPoints,
            color,
            strokeWidth: (_j = (_g = (_f = this.BS) === null || _f === void 0 ? void 0 : _f.W) !== null && _g !== void 0 ? _g : (_h = this.Border) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 1,
            strokeDashGap: (_l = (_k = this.BS) === null || _k === void 0 ? void 0 : _k.D) !== null && _l !== void 0 ? _l : [3, 0],
        };
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
    }
    generateApStream() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (!((_a = this.QuadPoints) === null || _a === void 0 ? void 0 : _a.length) || this.QuadPoints.length % 8) {
            return;
        }
        const apStream = new XFormStream();
        apStream.Filter = "/FlateDecode";
        apStream.LastModified = DateString.fromDate(new Date());
        apStream.BBox = [this.Rect[0], this.Rect[1], this.Rect[2], this.Rect[3]];
        let colorString;
        if (!((_b = this.C) === null || _b === void 0 ? void 0 : _b.length)) {
            colorString = "0 G 0 g";
        }
        else if (this.C.length < 3) {
            const g = this.C[0];
            colorString = `${g} G ${g} g`;
        }
        else if (this.C.length === 3) {
            const [r, g, b] = this.C;
            colorString = `${r} ${g} ${b} RG ${r} ${g} ${b} rg`;
        }
        else {
            const [c, m, y, k] = this.C;
            colorString = `${c} ${m} ${y} ${k} K ${c} ${m} ${y} ${k} k`;
        }
        const opacity = this.CA || 1;
        const strokeWidth = (_f = (_d = (_c = this.BS) === null || _c === void 0 ? void 0 : _c.W) !== null && _d !== void 0 ? _d : (_e = this.Border) === null || _e === void 0 ? void 0 : _e.width) !== null && _f !== void 0 ? _f : 1;
        const strokeDash = (_k = (_h = (_g = this.BS) === null || _g === void 0 ? void 0 : _g.D[0]) !== null && _h !== void 0 ? _h : (_j = this.Border) === null || _j === void 0 ? void 0 : _j.dash) !== null && _k !== void 0 ? _k : 3;
        const strokeGap = (_p = (_m = (_l = this.BS) === null || _l === void 0 ? void 0 : _l.D[1]) !== null && _m !== void 0 ? _m : (_o = this.Border) === null || _o === void 0 ? void 0 : _o.gap) !== null && _p !== void 0 ? _p : 0;
        const gs = new GraphicsStateDict();
        gs.AIS = true;
        gs.BM = "/Normal";
        gs.CA = opacity;
        gs.ca = opacity;
        gs.LW = strokeWidth;
        gs.LC = lineCapStyles.SQUARE;
        gs.LJ = lineJoinStyles.MITER;
        gs.D = [[strokeDash, strokeGap], 0];
        let streamTextData = `q ${colorString} /GS0 gs`;
        const bottomLeft = new Vec2();
        const bottomRight = new Vec2();
        const q = this.QuadPoints;
        for (let i = 0; i < q.length; i += 8) {
            bottomLeft.set(q[i + 4], q[i + 5]);
            bottomRight.set(q[i + 6], q[i + 7]);
            const squigglyLinePoints = buildSquigglyLine(bottomLeft, bottomRight, SquigglyAnnotation.squiggleSize);
            if (!(squigglyLinePoints === null || squigglyLinePoints === void 0 ? void 0 : squigglyLinePoints.length)) {
                continue;
            }
            streamTextData += `\n${squigglyLinePoints[0].x} ${squigglyLinePoints[0].y} m`;
            for (let j = 1; j < squigglyLinePoints.length; j++) {
                streamTextData += `\n${squigglyLinePoints[j].x} ${squigglyLinePoints[j].y} l`;
            }
            streamTextData += "\nS";
        }
        streamTextData += "\nQ";
        apStream.Resources = new ResourceDict();
        apStream.Resources.setGraphicsState("/GS0", gs);
        apStream.setTextStreamData(streamTextData);
        this.apStream = apStream;
    }
}
SquigglyAnnotation.squiggleSize = 6;

class AnnotationParseFactory {
    static ParseAnnotationFromInfo(info) {
        const annotationType = info.parser.parseDictSubtype(info.bounds);
        let annot;
        switch (annotationType) {
            case annotationTypes.STAMP:
                annot = StampAnnotation.parse(info);
                break;
            case annotationTypes.TEXT:
                annot = TextAnnotation.parse(info);
                break;
            case annotationTypes.INK:
                annot = InkAnnotation.parse(info);
                break;
            case annotationTypes.SQUARE:
                annot = SquareAnnotation.parse(info);
                break;
            case annotationTypes.CIRCLE:
                annot = CircleAnnotation.parse(info);
                break;
            case annotationTypes.POLYGON:
                annot = PolygonAnnotation.parse(info);
                break;
            case annotationTypes.POLYLINE:
                annot = PolylineAnnotation.parse(info);
                break;
            case annotationTypes.LINE:
                annot = LineAnnotation.parse(info);
                break;
            case annotationTypes.HIGHLIGHT:
                annot = HighlightAnnotation.parse(info);
                break;
            case annotationTypes.SQUIGGLY:
                annot = SquigglyAnnotation.parse(info);
                break;
            case annotationTypes.STRIKEOUT:
                annot = StrikeoutAnnotation.parse(info);
                break;
            case annotationTypes.UNDERLINE:
                annot = UnderlineAnnotation.parse(info);
                break;
        }
        return annot === null || annot === void 0 ? void 0 : annot.value;
    }
    static ParseAnnotationFromDto(dto) {
        let annotation;
        switch (dto.annotationType) {
            case "/Stamp":
                annotation = StampAnnotation.createFromDto(dto);
                break;
            case "/Text":
                annotation = TextAnnotation.createFromDto(dto);
                break;
            case "/Ink":
                annotation = InkAnnotation.createFromDto(dto);
                break;
            case "/Square":
                annotation = SquareAnnotation.createFromDto(dto);
                break;
            case "/Circle":
                annotation = CircleAnnotation.createFromDto(dto);
                break;
            case "/Polygon":
                annotation = PolygonAnnotation.createFromDto(dto);
                break;
            case "/Polyline":
                annotation = PolylineAnnotation.createFromDto(dto);
                break;
            case "/Line":
                annotation = LineAnnotation.createFromDto(dto);
                break;
            case "/Highlight":
                annotation = HighlightAnnotation.createFromDto(dto);
                break;
            case "/Squiggly":
                annotation = SquigglyAnnotation.createFromDto(dto);
                break;
            case "/Strikeout":
                annotation = StrikeoutAnnotation.createFromDto(dto);
                break;
            case "/Underline":
                annotation = UnderlineAnnotation.createFromDto(dto);
                break;
            default:
                throw new Error(`Unsupported annotation type: ${dto.annotationType}`);
        }
        return annotation;
    }
}

const annotSelectionRequestEvent = "tspdf-annotselectionrequest";
const annotFocusRequestEvent = "tspdf-annotfocusrequest";
const annotChangeEvent = "tspdf-annotchange";
class AnnotSelectionRequestEvent extends CustomEvent {
    constructor(detail) {
        super(annotSelectionRequestEvent, { detail });
    }
}
class AnnotFocusRequestEvent extends CustomEvent {
    constructor(detail) {
        super(annotFocusRequestEvent, { detail });
    }
}
class AnnotEvent extends CustomEvent {
    constructor(detail) {
        super(annotChangeEvent, { detail });
    }
}
class DocumentService {
    constructor(eventService, data, userName) {
        this._pageById = new Map();
        this._annotIdsByPageId = new Map();
        this.getObjectParseInfo = (id) => {
            var _a, _b, _c;
            if (!id) {
                return null;
            }
            const offset = (_a = this._referenceData) === null || _a === void 0 ? void 0 : _a.getOffset(id);
            if (isNaN(offset)) {
                return null;
            }
            const objectId = ObjectId.parse(this._docParser, offset);
            if (!objectId) {
                return null;
            }
            const bounds = this._docParser.getIndirectObjectBoundsAt(objectId.end + 1, true);
            if (!bounds) {
                return null;
            }
            const parseInfoGetter = this.getObjectParseInfo;
            const info = {
                parser: this._docParser,
                bounds,
                parseInfoGetter,
                cryptInfo: {
                    ref: { id: objectId.value.id, generation: objectId.value.generation },
                    stringCryptor: (_b = this._authResult) === null || _b === void 0 ? void 0 : _b.stringCryptor,
                    streamCryptor: (_c = this._authResult) === null || _c === void 0 ? void 0 : _c.streamCryptor,
                },
            };
            if (objectId.value.id === id) {
                return info;
            }
            const stream = ObjectStream.parse(info);
            if (!stream) {
                return;
            }
            const objectParseInfo = stream.value.getObjectData(id);
            if (objectParseInfo) {
                objectParseInfo.parseInfoGetter = parseInfoGetter;
                return objectParseInfo;
            }
            return null;
        };
        this.onAnnotationSelectionRequest = (e) => {
            var _a;
            if ((_a = e.detail) === null || _a === void 0 ? void 0 : _a.annotation) {
                this.setSelectedAnnotation(e.detail.annotation);
            }
            else {
                this.setSelectedAnnotation(null);
            }
        };
        this.onAnnotationFocusRequest = (e) => {
            var _a;
            if ((_a = e.detail) === null || _a === void 0 ? void 0 : _a.annotation) {
                this.setFocusedAnnotation(e.detail.annotation);
            }
            else {
                this.setFocusedAnnotation(null);
            }
        };
        if (!eventService) {
            throw new Error("Event controller is not defined");
        }
        this._eventService = eventService;
        this._data = data;
        this._docParser = new DataParser(data);
        this._version = this._docParser.getPdfVersion();
        const lastXrefIndex = this._docParser.getLastXrefIndex();
        if (!lastXrefIndex) {
            {
                throw new Error("File doesn't contain update section");
            }
        }
        const xrefs = new XrefParser(this._docParser).parseAllXrefs(lastXrefIndex.value);
        if (!xrefs.length) {
            {
                throw new Error("Failed to parse cross-reference sections");
            }
        }
        this._xrefs = xrefs;
        this._referenceData = new ReferenceData(xrefs);
        this.parseEncryption();
        this._userName = userName;
        this._eventService.addListener(annotSelectionRequestEvent, this.onAnnotationSelectionRequest);
        this._eventService.addListener(annotFocusRequestEvent, this.onAnnotationFocusRequest);
    }
    get eventService() {
        return this._eventService;
    }
    get userName() {
        return this._userName;
    }
    get focusedAnnotation() {
        return this._focusedAnnotation;
    }
    get selectedAnnotation() {
        return this._selectedAnnotation;
    }
    get size() {
        var _a;
        if ((_a = this._xrefs) === null || _a === void 0 ? void 0 : _a.length) {
            return this._xrefs[0].size;
        }
        else {
            return 0;
        }
    }
    get encrypted() {
        return !!this._encryption;
    }
    get authenticated() {
        return !this._encryption || !!this._authResult;
    }
    destroy() {
        this.getAllSupportedAnnotations().forEach(x => x.$onEditedAction = null);
        this._eventService.removeListener(annotSelectionRequestEvent, this.onAnnotationSelectionRequest);
        this._eventService.removeListener(annotFocusRequestEvent, this.onAnnotationFocusRequest);
    }
    tryAuthenticate(password = "") {
        if (!this.authenticated) {
            return this.authenticate(password);
        }
        return true;
    }
    getPlainData() {
        return this._data.slice();
    }
    getDataWithoutSupportedAnnotations() {
        const annotationMap = this.getSupportedAnnotationMap();
        const annotationMarkedToDelete = [];
        if (annotationMap === null || annotationMap === void 0 ? void 0 : annotationMap.size) {
            annotationMap.forEach((v, k) => {
                const annotations = v.slice();
                annotations.forEach(x => {
                    if (!x.deleted) {
                        x.markAsDeleted(true);
                        annotationMarkedToDelete.push(x);
                    }
                });
            });
        }
        const refined = this.getDataWithUpdatedAnnotations();
        annotationMarkedToDelete.forEach(x => x.markAsDeleted(false));
        return refined;
    }
    getDataWithUpdatedAnnotations() {
        const annotationMap = this.getSupportedAnnotationMap();
        const updaterData = [];
        annotationMap.forEach((pageAnnotations, pageId) => {
            const page = this._pageById.get(pageId);
            if (page) {
                const allAnnotationIds = this._annotIdsByPageId.get(pageId).slice() || [];
                updaterData.push({
                    page,
                    allAnnotationIds,
                    supportedAnnotations: pageAnnotations || [],
                });
            }
            else {
                console.log(`Page with id '${pageId}' not found`);
            }
        });
        const updater = new DocumentDataUpdater(this._data, this._xrefs[0], this._referenceData, this._authResult);
        const updatedBytes = updater.getDataWithUpdatedAnnotations(updaterData);
        return updatedBytes;
    }
    getPageAnnotations(pageId) {
        const annotations = this.getSupportedAnnotationMap().get(pageId);
        return annotations || [];
    }
    serializeAnnotations(addedOnly = false) {
        const result = [];
        this.getSupportedAnnotationMap().forEach((v, k) => {
            v.forEach(x => {
                if (!addedOnly || x.added) {
                    result.push(x.toDto());
                }
            });
        });
        return result;
    }
    appendAnnotationToPage(pageId, annotation) {
        if (!annotation) {
            throw new Error("Annotation is not defined");
        }
        const page = this._pageById.get(pageId);
        if (!page) {
            throw new Error(`Page with id ${pageId} is not found`);
        }
        annotation.$pageId = page.id;
        annotation.$pageRect = page.MediaBox;
        annotation.$onEditedAction = this.getOnAnnotationEditAction(annotation);
        const pageAnnotations = this.getSupportedAnnotationMap().get(pageId);
        if (pageAnnotations) {
            pageAnnotations.push(annotation);
        }
        else {
            this.getSupportedAnnotationMap().set(pageId, [annotation]);
        }
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "add",
            annotations: [annotation.toDto()],
        }));
    }
    appendSerializedAnnotations(dtos) {
        let annotation;
        for (const dto of dtos) {
            annotation = AnnotationParseFactory.ParseAnnotationFromDto(dto);
            this.appendAnnotationToPage(dto.pageId, annotation);
        }
    }
    removeAnnotation(annotation) {
        if (!annotation) {
            return;
        }
        annotation.markAsDeleted(true);
        this.setSelectedAnnotation(null);
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "delete",
            annotations: [annotation.toDto()],
        }));
    }
    removeSelectedAnnotation() {
        const annotation = this.selectedAnnotation;
        if (annotation) {
            this.removeAnnotation(annotation);
        }
    }
    setSelectedAnnotation(annotation) {
        var _a;
        if (annotation === this._selectedAnnotation) {
            return;
        }
        if (this._selectedAnnotation) {
            this._selectedAnnotation.$translationEnabled = false;
            const oldSelectedSvg = (_a = this._selectedAnnotation) === null || _a === void 0 ? void 0 : _a.lastRenderResult;
            oldSelectedSvg === null || oldSelectedSvg === void 0 ? void 0 : oldSelectedSvg.classList.remove("selected");
        }
        const newSelectedSvg = annotation === null || annotation === void 0 ? void 0 : annotation.lastRenderResult;
        if (!newSelectedSvg) {
            this._selectedAnnotation = null;
        }
        else {
            annotation.$translationEnabled = true;
            newSelectedSvg.classList.add("selected");
            this._selectedAnnotation = annotation;
        }
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "select",
            annotations: this._selectedAnnotation
                ? [this._selectedAnnotation.toDto()]
                : [],
        }));
        return this._selectedAnnotation;
    }
    setFocusedAnnotation(annotation) {
        var _a;
        if (annotation === this._focusedAnnotation) {
            return;
        }
        if (this._focusedAnnotation) {
            this._focusedAnnotation.$translationEnabled = false;
            const oldFocusedSvg = (_a = this._focusedAnnotation) === null || _a === void 0 ? void 0 : _a.lastRenderResult;
            oldFocusedSvg === null || oldFocusedSvg === void 0 ? void 0 : oldFocusedSvg.classList.remove("focused");
        }
        const newFocusedSvg = annotation === null || annotation === void 0 ? void 0 : annotation.lastRenderResult;
        if (!newFocusedSvg) {
            this._focusedAnnotation = null;
        }
        else {
            annotation.$translationEnabled = true;
            newFocusedSvg.classList.add("focused");
            this._focusedAnnotation = annotation;
        }
        this._eventService.dispatchEvent(new AnnotEvent({
            type: "focus",
            annotations: this._focusedAnnotation
                ? [this._focusedAnnotation.toDto()]
                : [],
        }));
        return this._focusedAnnotation;
    }
    getSelectedAnnotationTextContent() {
        var _a, _b;
        return (_b = (_a = this._selectedAnnotation) === null || _a === void 0 ? void 0 : _a.Contents) === null || _b === void 0 ? void 0 : _b.literal;
    }
    setSelectedAnnotationTextContent(text) {
        var _a;
        (_a = this.selectedAnnotation) === null || _a === void 0 ? void 0 : _a.setTextContent(text);
    }
    getOnAnnotationEditAction(annotation) {
        if (!annotation) {
            return null;
        }
        return () => this._eventService.dispatchEvent(new AnnotEvent({
            type: "edit",
            annotations: [annotation.toDto()],
        }));
    }
    authenticate(password) {
        if (this.authenticated) {
            return true;
        }
        const cryptOptions = this._encryption.toCryptOptions();
        const fileId = this._xrefs[0].id[0].hex;
        const cryptorSource = new DataCryptHandler(cryptOptions, fileId);
        this._authResult = cryptorSource.authenticate(password);
        return this.authenticated;
    }
    checkAuthentication() {
        if (!this.authenticated) {
            throw new Error("Unauthorized access to file data");
        }
    }
    parseEncryption() {
        const encryptionId = this._xrefs[0].encrypt;
        if (!encryptionId) {
            return;
        }
        const encryptionParseInfo = this.getObjectParseInfo(encryptionId.id);
        const encryption = EncryptionDict.parse(encryptionParseInfo);
        if (!encryption) {
            throw new Error("Encryption dict can't be parsed");
        }
        this._encryption = encryption.value;
    }
    parsePages(output, tree) {
        if (!tree.Kids.length) {
            return;
        }
        for (const kid of tree.Kids) {
            const parseInfo = this.getObjectParseInfo(kid.id);
            if (!parseInfo) {
                continue;
            }
            const type = parseInfo.parser.parseDictType(parseInfo.bounds);
            if (type === dictTypes.PAGE_TREE) {
                const kidTree = PageTreeDict.parse(parseInfo);
                if (kidTree) {
                    this.parsePages(output, kidTree.value);
                }
            }
            else if (type === dictTypes.PAGE) {
                const kidPage = PageDict.parse(parseInfo);
                if (kidPage) {
                    output.push(kidPage.value);
                }
            }
        }
    }
    ;
    parsePageTree() {
        const catalogId = this._xrefs[0].root;
        const catalogParseInfo = this.getObjectParseInfo(catalogId.id);
        const catalog = CatalogDict.parse(catalogParseInfo);
        if (!catalog) {
            throw new Error("Document root catalog not found");
        }
        this._catalog = catalog.value;
        const pageRootId = catalog.value.Pages;
        const pageRootParseInfo = this.getObjectParseInfo(pageRootId.id);
        const pageRootTree = PageTreeDict.parse(pageRootParseInfo);
        if (!pageRootTree) {
            throw new Error("Document root page tree not found");
        }
        const pages = [];
        this.parsePages(pages, pageRootTree.value);
        this._pages = pages;
        this._pageById.clear();
        pages.forEach(x => this._pageById.set(x.ref.id, x));
        console.log(this._pageById);
    }
    parseSupportedAnnotations() {
        var _a;
        this.checkAuthentication();
        if (!this._catalog) {
            this.parsePageTree();
        }
        const annotIdsByPageId = new Map();
        const annotationMap = new Map();
        for (const page of this._pages) {
            const annotationIds = [];
            if (Array.isArray(page.Annots)) {
                annotationIds.push(...page.Annots);
            }
            else if (page.Annots instanceof ObjectId) {
                const parseInfo = this.getObjectParseInfo(page.Annots.id);
                if (parseInfo) {
                    const annotationRefs = ObjectId.parseRefArray(parseInfo.parser, parseInfo.bounds.contentStart);
                    if ((_a = annotationRefs === null || annotationRefs === void 0 ? void 0 : annotationRefs.value) === null || _a === void 0 ? void 0 : _a.length) {
                        annotationIds.push(...annotationRefs.value);
                    }
                }
            }
            annotIdsByPageId.set(page.ref.id, annotationIds);
            const annotations = [];
            for (const objectId of annotationIds) {
                const info = this.getObjectParseInfo(objectId.id);
                info.rect = page.MediaBox;
                const annot = AnnotationParseFactory.ParseAnnotationFromInfo(info);
                if (annot) {
                    annotations.push(annot);
                    annot.$pageId = page.id;
                    annot.$onEditedAction = this.getOnAnnotationEditAction(annot);
                    console.log(annot);
                }
            }
            annotationMap.set(page.id, annotations);
        }
        this._annotIdsByPageId = annotIdsByPageId;
        this._supportedAnnotsByPageId = annotationMap;
    }
    getSupportedAnnotationMap() {
        this.checkAuthentication();
        if (this._supportedAnnotsByPageId) {
            return this._supportedAnnotsByPageId;
        }
        this.parseSupportedAnnotations();
        return this._supportedAnnotsByPageId;
    }
    getAllSupportedAnnotations() {
        const result = [];
        this.getSupportedAnnotationMap().forEach((v, k) => {
            result.push(...v);
        });
        return result;
    }
}

const currentPageChangeRequestEvent = "tspdf-currentpagechangerequest";
class CurrentPageChangeRequestEvent extends CustomEvent {
    constructor(detail) {
        super(currentPageChangeRequestEvent, { detail });
    }
}
const currentPageChangeEvent = "tspdf-currentpagechange";
class CurrentPageChangeEvent extends CustomEvent {
    constructor(detail) {
        super(currentPageChangeEvent, { detail });
    }
}
const pagesLoadedEvent = "tspdf-pagesloaded";
class PagesLoadedEvent extends CustomEvent {
    constructor(detail) {
        super(pagesLoadedEvent, { detail });
    }
}
const pagesRenderedEvent = "tspdf-pagesrendered";
class PagesRenderedEvent extends CustomEvent {
    constructor(detail) {
        super(pagesRenderedEvent, { detail });
    }
}
const scaleChangedEvent = "tspdf-scalechanged";
class ScaleChangedEvent extends CustomEvent {
    constructor(detail) {
        super(scaleChangedEvent, { detail });
    }
}
class PageService {
    constructor(eventService, options) {
        this._pages = [];
        this._renderedPages = [];
        if (!eventService) {
            throw new Error("Event controller is not defined");
        }
        this._eventService = eventService;
        this._visibleAdjPages = (options === null || options === void 0 ? void 0 : options.visibleAdjPages) || 0;
    }
    get eventService() {
        return this._eventService;
    }
    get currentPageIndex() {
        return this._currentPageIndex || 0;
    }
    get pages() {
        return this._pages.slice();
    }
    set pages(value) {
        this._pages.forEach(x => x.destroy());
        this._pages = value.slice();
        this._eventService.dispatchEvent(new PagesLoadedEvent({ pages: value.slice() }));
        this.setCurrentPageIndex(0);
    }
    get renderedPages() {
        return this._renderedPages.slice();
    }
    get length() {
        return this._pages.length || 0;
    }
    get scale() {
        var _a;
        return ((_a = this._renderedPages[0]) === null || _a === void 0 ? void 0 : _a.scale) || 1;
    }
    set scale(value) {
        if (!value || isNaN(value)) {
            value = 1;
        }
        this._pages.forEach(x => x.scale = value);
        this._eventService.dispatchEvent(new ScaleChangedEvent({ scale: value }));
    }
    destroy() {
        this._pages.forEach(x => x.destroy);
    }
    getPage(index) {
        return this._pages[index];
    }
    getCurrentPage() {
        return this._pages[this._currentPageIndex];
    }
    requestSetCurrentPageIndex(index) {
        index = clamp(index || 0, 0, this._pages.length - 1);
        if (index !== this._currentPageIndex) {
            this._eventService.dispatchEvent(new CurrentPageChangeRequestEvent({ pageIndex: index }));
        }
    }
    renderVisiblePages(container) {
        const pages = this._pages;
        const { minFinal: minPageNumber, maxFinal: maxPageNumber } = this.getVisiblePageIndices(container);
        const renderedPages = [];
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            if (i >= minPageNumber && i <= maxPageNumber) {
                renderedPages.push(page);
                page.renderViewAsync();
            }
            else {
                page.clearView();
            }
        }
        this._renderedPages = renderedPages;
        this._eventService.dispatchEvent(new PagesRenderedEvent({ pages: renderedPages.slice() }));
        this.updateCurrentPage(container);
    }
    renderVisiblePreviews(container) {
        const pages = this._pages;
        const visible = this.getVisiblePageIndices(container, true);
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            if (i >= visible.minFinal && i <= visible.maxFinal) {
                page.renderPreviewAsync();
            }
        }
    }
    renderSpecifiedPages(pageIdSet) {
        if (!(pageIdSet === null || pageIdSet === void 0 ? void 0 : pageIdSet.size)) {
            return;
        }
        this._renderedPages.forEach(x => {
            if (pageIdSet.has(x.id)) {
                x.renderViewAsync(true);
            }
        });
    }
    getPageCoordsUnderPointer(clientX, clientY) {
        for (const page of this._renderedPages) {
            const { left: pxMin, top: pyMin, width: pw, height: ph } = page.viewContainer.getBoundingClientRect();
            const pxMax = pxMin + pw;
            const pyMax = pyMin + ph;
            if (clientX < pxMin || clientX > pxMax) {
                continue;
            }
            if (clientY < pyMin || clientY > pyMax) {
                continue;
            }
            const x = (clientX - pxMin) / this.scale;
            const y = (pyMax - clientY) / this.scale;
            return {
                pageId: page.id,
                pageX: x,
                pageY: y,
            };
        }
        return null;
    }
    setCurrentPageIndex(index) {
        var _a, _b;
        const newIndex = clamp(index || 0, 0, this._pages.length - 1);
        if (newIndex !== this._currentPageIndex) {
            const oldIndex = this._currentPageIndex;
            this._currentPageIndex = newIndex;
            (_a = this._pages[oldIndex]) === null || _a === void 0 ? void 0 : _a.previewContainer.classList.remove("current");
            (_b = this._pages[newIndex]) === null || _b === void 0 ? void 0 : _b.previewContainer.classList.add("current");
            this._eventService.dispatchEvent(new CurrentPageChangeEvent({ oldIndex, newIndex }));
        }
    }
    getVisiblePageIndices(container, preview = false) {
        const pages = this._pages;
        if (!pages.length) {
            return {
                actual: [],
                minFinal: null,
                maxFinal: null,
            };
        }
        const indices = new Set();
        const cRect = container.getBoundingClientRect();
        const cTop = cRect.top;
        const cBottom = cRect.top + cRect.height;
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            const pRect = preview
                ? page.previewContainer.getBoundingClientRect()
                : page.viewContainer.getBoundingClientRect();
            const pTop = pRect.top;
            const pBottom = pRect.top + pRect.height;
            if (pTop < cBottom && pBottom > cTop) {
                indices.add(i);
            }
            else if (indices.size) {
                break;
            }
        }
        const indicesArray = [...indices];
        return {
            actual: indicesArray,
            minFinal: Math.max(Math.min(...indicesArray) - this._visibleAdjPages, 0),
            maxFinal: Math.min(Math.max(...indicesArray) + this._visibleAdjPages, pages.length - 1),
        };
    }
    updateCurrentPage(container) {
        const pages = this._pages;
        const visible = this.getVisiblePageIndices(container);
        const { actual: indices, minFinal: minIndex, maxFinal: maxIndex } = visible;
        if (!indices.length) {
            this.setCurrentPageIndex(0);
            return;
        }
        else if (indices.length === 1) {
            this.setCurrentPageIndex(indices[0]);
            return;
        }
        const cRect = container.getBoundingClientRect();
        const cTop = cRect.top;
        const cMiddle = cRect.top + cRect.height / 2;
        for (const i of indices) {
            const pRect = pages[i].viewContainer.getBoundingClientRect();
            const pTop = pRect.top;
            if (pTop > cTop) {
                if (pTop > cMiddle) {
                    this.setCurrentPageIndex(i - 1);
                    return;
                }
                else {
                    this.setCurrentPageIndex(i);
                    return;
                }
            }
        }
        throw new Error("Incorrect argument");
    }
}

const annotatorTypes = ["geom", "pen", "stamp", "text"];
const annotatorDataChangeEvent = "tspdf-annotatordatachange";
class AnnotatorDataChangeEvent extends CustomEvent {
    constructor(detail) {
        super(annotatorDataChangeEvent, { detail });
    }
}
const textSelectionChangeEvent = "tspdf-textselectionchange";
class TextSelectionChangeEvent extends CustomEvent {
    constructor(detail) {
        super(textSelectionChangeEvent, { detail });
    }
}
class Annotator {
    constructor(docService, pageService, parent) {
        this.onPagesRendered = (event) => {
            this.refreshViewBox();
        };
        this.onParentScroll = () => {
            this.refreshViewBox();
        };
        this.onOverlayPointerDown = (e) => {
            if (!e.isPrimary) {
                return;
            }
            this._lastPointerDownInfo = {
                timestamp: performance.now(),
                clientX: e.clientX,
                clientY: e.clientY,
            };
        };
        if (!docService) {
            throw new Error("Document service not defined");
        }
        if (!pageService) {
            throw new Error("Page service not defined");
        }
        if (!parent) {
            throw new Error("Parent container not defined");
        }
        this._docService = docService;
        this._parent = parent;
        this._pageService = pageService;
    }
    get overlayContainer() {
        return this._overlayContainer;
    }
    destroy() {
        var _a, _b, _c;
        this._docService.eventService.removeListener(pagesRenderedEvent, this.onPagesRendered);
        (_a = this._parent) === null || _a === void 0 ? void 0 : _a.removeEventListener("scroll", this.onParentScroll);
        (_b = this._parentMutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this._parentResizeObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        this._overlayContainer.remove();
    }
    refreshViewBox() {
        const { width: w, height: h } = this._overlay.getBoundingClientRect();
        if (!w || !h) {
            return;
        }
        this._overlay.style.left = this._parent.scrollLeft + "px";
        this._overlay.style.top = this._parent.scrollTop + "px";
        const viewBoxWidth = w / this._pageService.scale;
        const viewBoxHeight = h / this._pageService.scale;
        this._svgWrapper.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
        this.refreshGroupPosition();
    }
    init() {
        const annotationOverlayContainer = document.createElement("div");
        annotationOverlayContainer.id = "annotation-overlay-container";
        const annotationOverlay = document.createElement("div");
        annotationOverlay.id = "annotation-overlay";
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add("abs-stretch", "no-margin", "no-padding");
        svg.setAttribute("transform", "matrix(1 0 0 -1 0 0)");
        svg.setAttribute("opacity", "0.5");
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.append(g);
        annotationOverlay.append(svg);
        annotationOverlayContainer.append(annotationOverlay);
        this._overlayContainer = annotationOverlayContainer;
        this._overlay = annotationOverlay;
        this._svgWrapper = svg;
        this._svgGroup = g;
        this._parent.append(this._overlayContainer);
        this.refreshViewBox();
        this.initEventHandlers();
    }
    initEventHandlers() {
        this._overlay.addEventListener("pointerdown", this.onOverlayPointerDown);
        this._parent.addEventListener("scroll", this.onParentScroll);
        const parentRObserver = new ResizeObserver((entries) => {
            this.refreshViewBox();
        });
        const parentMObserver = new MutationObserver((mutations) => {
            const record = mutations[0];
            if (!record) {
                return;
            }
            record.addedNodes.forEach(x => {
                const element = x;
                if (element.classList.contains("page")) {
                    parentRObserver.observe(x);
                }
            });
            record.removedNodes.forEach(x => parentRObserver.unobserve(x));
            this.refreshViewBox();
        });
        parentRObserver.observe(this._parent);
        parentMObserver.observe(this._parent, {
            attributes: false,
            childList: true,
            subtree: false,
        });
        this._parentMutationObserver = parentMObserver;
        this._parentResizeObserver = parentRObserver;
        this._docService.eventService.addListener(pagesRenderedEvent, this.onPagesRendered);
    }
    updatePointerCoords(clientX, clientY) {
        const pageCoords = this._pageService.getPageCoordsUnderPointer(clientX, clientY);
        if (!pageCoords) {
            this._svgGroup.classList.add("out");
        }
        else {
            this._svgGroup.classList.remove("out");
        }
        this._pointerCoordsInPageCS = pageCoords;
    }
}

class GeometricAnnotator extends Annotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent);
        this._color = (options === null || options === void 0 ? void 0 : options.color) || [0, 0, 0, 1];
        this._strokeWidth = (options === null || options === void 0 ? void 0 : options.strokeWidth) || 3;
        this._cloudMode = (options === null || options === void 0 ? void 0 : options.cloudMode) || false;
    }
    destroy() {
        this.clearGroup();
        super.destroy();
    }
    init() {
        super.init();
    }
    emitDataChanged(count, saveable, clearable, undoable) {
        this._docService.eventService.dispatchEvent(new AnnotatorDataChangeEvent({
            annotatorType: "geom",
            elementCount: count,
            undoable,
            clearable,
            saveable,
        }));
    }
    clearGroup() {
        this._svgGroup.innerHTML = "";
        this.emitDataChanged(0);
    }
    refreshGroupPosition() {
        if (!this._pageId && this._pageId !== 0) {
            return;
        }
        const page = this._pageService.renderedPages.find(x => x.id === this._pageId);
        if (!page) {
            this._svgGroup.setAttribute("transform", `matrix(${[0, 0, 0, 0, 0, 0].join(" ")})`);
            return;
        }
        const { height: ph, top: ptop, left: px } = page.viewContainer.getBoundingClientRect();
        const py = ptop + ph;
        const { height: vh, top: vtop, left: vx } = this._overlay.getBoundingClientRect();
        const vy = vtop + vh;
        const offsetX = (px - vx) / this._pageService.scale;
        const offsetY = (vy - py) / this._pageService.scale;
        this._svgGroup.setAttribute("transform", `matrix(${[1, 0, 0, 1, offsetX, offsetY].join(" ")})`);
    }
}

class GeometricLineAnnotator extends GeometricAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this.onPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords) {
                return;
            }
            const { pageX: px, pageY: py, pageId } = pageCoords;
            this._pageId = pageId;
            this._down = new Vec2(px, py);
            this.clear();
            this.refreshGroupPosition();
            const target = e.target;
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUp);
            target.addEventListener("pointerout", this.onPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPointerMove = (e) => {
            if (!e.isPrimary
                || !this._down) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords || pageCoords.pageId !== this._pageId) {
                return;
            }
            const { pageX: px, pageY: py } = pageCoords;
            const end = new Vec2(px, py);
            this.redrawLine(this._down, end);
        };
        this.onPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPointerMove);
            target.removeEventListener("pointerup", this.onPointerUp);
            target.removeEventListener("pointerout", this.onPointerUp);
            target.releasePointerCapture(e.pointerId);
            if (this._vertices) {
                this.emitDataChanged(2, true, true);
            }
        };
        this.init();
    }
    destroy() {
        super.destroy();
    }
    undo() {
        this.clear();
    }
    clear() {
        this._vertices = null;
        this.clearGroup();
    }
    saveAnnotation() {
        if (!this._vertices) {
            return;
        }
        const pageId = this._pageId;
        const dto = this.buildAnnotationDto();
        const annotation = LineAnnotation.createFromDto(dto);
        this._docService.appendAnnotationToPage(pageId, annotation);
        this.clear();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPointerDown);
    }
    redrawLine(min, max) {
        this._svgGroup.innerHTML = "";
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._vertices = [min.x, min.y, max.x, max.y];
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
        path.setAttribute("stroke-width", this._strokeWidth + "");
        path.setAttribute("stroke-linecap", "square");
        const pathString = `M ${min.x},${min.y} L ${max.x},${max.y}`;
        path.setAttribute("d", pathString);
        this._svgGroup.append(path);
    }
    buildAnnotationDto() {
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Line",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._docService.userName || "unknown",
            textContent: null,
            rect: null,
            vertices: this._vertices,
            intent: lineIntents.DIMENSION,
            color: this._color,
            strokeWidth: this._strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

class GeometricArrowAnnotator extends GeometricLineAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
    }
    redrawLine(min, max) {
        this._svgGroup.innerHTML = "";
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._vertices = [min.x, min.y, max.x, max.y];
        const start = new Vec2(min.x, min.y);
        const end = new Vec2(max.x, max.y);
        const xAlignedStart = new Vec2();
        const xAlignedEnd = new Vec2(Vec2.substract(end, start).getMagnitude(), 0);
        const mat = mat3From4Vec2(xAlignedStart, xAlignedEnd, start, end);
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
        path.setAttribute("stroke-width", this._strokeWidth + "");
        path.setAttribute("stroke-linecap", "square");
        let pathString = `M ${xAlignedStart.x},${xAlignedStart.y} L ${xAlignedEnd.x},${xAlignedEnd.y}`;
        const arrowSize = Math.max(this._strokeWidth * LineAnnotation.lineEndingMultiplier, LineAnnotation.lineEndingMinimalSize);
        pathString += ` M ${xAlignedEnd.x - arrowSize},${xAlignedEnd.y + arrowSize / 2}`;
        pathString += ` L ${xAlignedEnd.x},${xAlignedEnd.y}`;
        pathString += ` L ${xAlignedEnd.x - arrowSize},${xAlignedEnd.y - arrowSize / 2}`;
        path.setAttribute("d", pathString);
        path.setAttribute("transform", `matrix(${mat.toFloatShortArray().join(" ")})`);
        this._svgGroup.append(path);
    }
    buildAnnotationDto() {
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Line",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._docService.userName || "unknown",
            textContent: null,
            rect: null,
            vertices: this._vertices,
            intent: lineIntents.ARROW,
            endingType: [lineEndingTypes.NONE, lineEndingTypes.ARROW_OPEN],
            color: this._color,
            strokeWidth: this._strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

class GeometricCircleAnnotator extends GeometricAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this.onPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords) {
                return;
            }
            const { pageX: px, pageY: py, pageId } = pageCoords;
            this._pageId = pageId;
            this._down = new Vec2(px, py);
            this.clear();
            this.refreshGroupPosition();
            const target = e.target;
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUp);
            target.addEventListener("pointerout", this.onPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPointerMove = (e) => {
            if (!e.isPrimary
                || !this._down) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords || pageCoords.pageId !== this._pageId) {
                return;
            }
            const { pageX: px, pageY: py } = pageCoords;
            const { min, max } = vecMinMax(this._down, new Vec2(px, py));
            this.redrawCircle(min, max);
        };
        this.onPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPointerMove);
            target.removeEventListener("pointerup", this.onPointerUp);
            target.removeEventListener("pointerout", this.onPointerUp);
            target.releasePointerCapture(e.pointerId);
            if (this._rect) {
                this.emitDataChanged(2, true, true);
            }
        };
        this.init();
    }
    destroy() {
        super.destroy();
    }
    undo() {
        this.clear();
    }
    clear() {
        this._rect = null;
        this.clearGroup();
    }
    saveAnnotation() {
        if (!this._rect) {
            return;
        }
        const pageId = this._pageId;
        const dto = this.buildAnnotationDto();
        const annotation = CircleAnnotation.createFromDto(dto);
        this._docService.appendAnnotationToPage(pageId, annotation);
        this.clear();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPointerDown);
    }
    redrawCircle(min, max) {
        this._svgGroup.innerHTML = "";
        const minSize = this._strokeWidth * 2;
        if (max.x - min.x <= minSize || max.y - min.y <= minSize) {
            this._rect = null;
            return;
        }
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._rect = [min.x, min.y, max.x, max.y];
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
        path.setAttribute("stroke-width", this._strokeWidth + "");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        let pathString;
        const rx = (max.x - min.x) / 2;
        const ry = (max.y - min.y) / 2;
        const center = new Vec2(min.x + rx, min.y + ry);
        if (this._cloudMode) {
            const curveData = buildCloudCurveFromEllipse(rx, ry, CircleAnnotation.cloudArcSize, new Mat3().applyTranslation(center.x, center.y));
            pathString = "M" + curveData.start.x + "," + curveData.start.y;
            curveData.curves.forEach(x => {
                pathString += ` C${x[0].x},${x[0].y} ${x[1].x},${x[1].y} ${x[2].x},${x[2].y}`;
            });
        }
        else {
            const c = bezierConstant;
            const cw = c * rx;
            const ch = c * ry;
            pathString = "M" + center.x + "," + max.y;
            pathString += ` C${center.x + cw},${max.y} ${max.x},${center.y + ch} ${max.x},${center.y}`;
            pathString += ` C${max.x},${center.y - ch} ${center.x + cw},${min.y} ${center.x},${min.y}`;
            pathString += ` C${center.x - cw},${min.y} ${min.x},${center.y - ch} ${min.x},${center.y}`;
            pathString += ` C${min.x},${center.y + ch} ${center.x - cw},${max.y} ${center.x},${max.y}`;
        }
        path.setAttribute("d", pathString);
        this._svgGroup.append(path);
    }
    buildAnnotationDto() {
        const margin = this._strokeWidth / 2 + (this._cloudMode ? CircleAnnotation.cloudArcSize / 2 : 0);
        const lm = margin;
        const tm = margin;
        const rm = margin;
        const bm = margin;
        const rectMargins = [lm, tm, rm, bm];
        const [xmin, ymin, xmax, ymax] = this._rect;
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Circle",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._docService.userName || "unknown",
            textContent: null,
            rect: [xmin - lm, ymin - bm, xmax + rm, ymax + tm],
            rectMargins,
            cloud: this._cloudMode,
            color: this._color,
            strokeWidth: this._strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

class GeometricPolygonAnnotator extends GeometricAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this._points = [];
        this.onPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords) {
                return;
            }
            const { pageX: px, pageY: py, pageId } = pageCoords;
            this._pageId = pageId;
            this.refreshGroupPosition();
            if (!this._points.length) {
                this._points.push(new Vec2(px, py));
            }
            this._points.push(new Vec2(px, py));
            const target = e.target;
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUp);
            target.addEventListener("pointerout", this.onPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords || pageCoords.pageId !== this._pageId) {
                return;
            }
            const { pageX: px, pageY: py } = pageCoords;
            this._points[this._points.length - 1].set(px, py);
            this.redraw();
        };
        this.onPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPointerMove);
            target.removeEventListener("pointerup", this.onPointerUp);
            target.removeEventListener("pointerout", this.onPointerUp);
            target.releasePointerCapture(e.pointerId);
            this.emitPointsDataChanged();
        };
        this.init();
    }
    destroy() {
        super.destroy();
    }
    undo() {
        if (this._points.length) {
            this._points.pop();
            this.redraw();
            this.emitPointsDataChanged();
        }
    }
    clear() {
        var _a;
        if ((_a = this._points) === null || _a === void 0 ? void 0 : _a.length) {
            this._points.length = 0;
            this.clearGroup();
        }
    }
    saveAnnotation() {
        if (this._points.length < 3) {
            return;
        }
        const pageId = this._pageId;
        const dto = this.buildAnnotationDto();
        const annotation = PolygonAnnotation.createFromDto(dto);
        this._docService.appendAnnotationToPage(pageId, annotation);
        this.clear();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPointerDown);
    }
    emitPointsDataChanged() {
        const count = this._points.length;
        this.emitDataChanged(count, count > 1, count > 0, count > 2);
    }
    redraw() {
        this._svgGroup.innerHTML = "";
        if (this._points.length < 2) {
            return;
        }
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
        path.setAttribute("stroke-width", this._strokeWidth + "");
        let pathString;
        if (this._cloudMode) {
            path.setAttribute("stroke-linecap", "round");
            path.setAttribute("stroke-linejoin", "round");
            const curveData = buildCloudCurveFromPolyline([...this._points, this._points[0]], PolygonAnnotation.cloudArcSize);
            pathString = "M" + curveData.start.x + "," + curveData.start.y;
            curveData.curves.forEach(x => {
                pathString += ` C${x[0].x},${x[0].y} ${x[1].x},${x[1].y} ${x[2].x},${x[2].y}`;
            });
            path.setAttribute("d", pathString);
        }
        else {
            path.setAttribute("stroke-linecap", "square");
            path.setAttribute("stroke-linejoin", "miter");
            const start = this._points[0];
            pathString = "M" + start.x + "," + start.y;
            for (let i = 1; i < this._points.length; i++) {
                const point = this._points[i];
                pathString += " L" + point.x + "," + point.y;
            }
            pathString += " Z";
        }
        path.setAttribute("d", pathString);
        this._svgGroup.append(path);
    }
    buildAnnotationDto() {
        const margin = this._strokeWidth / 2 + (this._cloudMode ? PolygonAnnotation.cloudArcSize / 2 : 0);
        let xmin;
        let ymin;
        let xmax;
        let ymax;
        let vec;
        const points = this._points;
        const vertices = [];
        for (let i = 0; i < points.length; i++) {
            vec = points[i];
            if (!xmin || vec.x < xmin) {
                xmin = vec.x;
            }
            if (!ymin || vec.y < ymin) {
                ymin = vec.y;
            }
            if (!xmax || vec.x > xmax) {
                xmax = vec.x;
            }
            if (!ymax || vec.y > ymax) {
                ymax = vec.y;
            }
            vertices.push(vec.x, vec.y);
        }
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Polygon",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._docService.userName || "unknown",
            textContent: null,
            rect: [xmin - margin, ymin - margin, xmax + margin, ymax + margin],
            vertices,
            cloud: this._cloudMode,
            color: this._color,
            strokeWidth: this._strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

class GeometricPolylineAnnotator extends GeometricAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this._points = [];
        this.onPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords) {
                return;
            }
            const { pageX: px, pageY: py, pageId } = pageCoords;
            this._pageId = pageId;
            this.refreshGroupPosition();
            if (!this._points.length) {
                this._points.push(new Vec2(px, py));
            }
            this._points.push(new Vec2(px, py));
            const target = e.target;
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUp);
            target.addEventListener("pointerout", this.onPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords || pageCoords.pageId !== this._pageId) {
                return;
            }
            const { pageX: px, pageY: py } = pageCoords;
            this._points[this._points.length - 1].set(px, py);
            this.redraw();
        };
        this.onPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPointerMove);
            target.removeEventListener("pointerup", this.onPointerUp);
            target.removeEventListener("pointerout", this.onPointerUp);
            target.releasePointerCapture(e.pointerId);
            this.emitPointsDataChanged();
        };
        this.init();
    }
    destroy() {
        super.destroy();
    }
    undo() {
        if (this._points.length) {
            this._points.pop();
            this.redraw();
            this.emitPointsDataChanged();
        }
    }
    clear() {
        var _a;
        if ((_a = this._points) === null || _a === void 0 ? void 0 : _a.length) {
            this._points.length = 0;
            this.clearGroup();
        }
    }
    saveAnnotation() {
        if (this._points.length < 2) {
            return;
        }
        const pageId = this._pageId;
        const dto = this.buildAnnotationDto();
        const annotation = PolylineAnnotation.createFromDto(dto);
        this._docService.appendAnnotationToPage(pageId, annotation);
        this.clear();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPointerDown);
    }
    emitPointsDataChanged() {
        const count = this._points.length;
        this.emitDataChanged(count, count > 1, count > 0, count > 2);
    }
    redraw() {
        this._svgGroup.innerHTML = "";
        if (this._points.length < 2) {
            return;
        }
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
        path.setAttribute("stroke-width", this._strokeWidth + "");
        path.setAttribute("stroke-linecap", "square");
        path.setAttribute("stroke-linejoin", "miter");
        const start = this._points[0];
        let pathString = "M" + start.x + "," + start.y;
        for (let i = 1; i < this._points.length; i++) {
            const point = this._points[i];
            pathString += " L" + point.x + "," + point.y;
        }
        path.setAttribute("d", pathString);
        this._svgGroup.append(path);
    }
    buildAnnotationDto() {
        const margin = this._strokeWidth / 2;
        let xmin;
        let ymin;
        let xmax;
        let ymax;
        let vec;
        const points = this._points;
        const vertices = [];
        for (let i = 0; i < points.length; i++) {
            vec = points[i];
            if (!xmin || vec.x < xmin) {
                xmin = vec.x;
            }
            if (!ymin || vec.y < ymin) {
                ymin = vec.y;
            }
            if (!xmax || vec.x > xmax) {
                xmax = vec.x;
            }
            if (!ymax || vec.y > ymax) {
                ymax = vec.y;
            }
            vertices.push(vec.x, vec.y);
        }
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Polyline",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._docService.userName || "unknown",
            textContent: null,
            rect: [xmin - margin, ymin - margin, xmax + margin, ymax + margin],
            vertices,
            color: this._color,
            strokeWidth: this._strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

class GeometricSquareAnnotator extends GeometricAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this.onPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords) {
                return;
            }
            const { pageX: px, pageY: py, pageId } = pageCoords;
            this._pageId = pageId;
            this._down = new Vec2(px, py);
            this.clear();
            this.refreshGroupPosition();
            const target = e.target;
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUp);
            target.addEventListener("pointerout", this.onPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPointerMove = (e) => {
            if (!e.isPrimary
                || !this._down) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords || pageCoords.pageId !== this._pageId) {
                return;
            }
            const { pageX: px, pageY: py } = pageCoords;
            const { min, max } = vecMinMax(this._down, new Vec2(px, py));
            this.redrawRect(min, max);
        };
        this.onPointerUp = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPointerMove);
            target.removeEventListener("pointerup", this.onPointerUp);
            target.removeEventListener("pointerout", this.onPointerUp);
            target.releasePointerCapture(e.pointerId);
            if (this._rect) {
                this.emitDataChanged(2, true, true);
            }
        };
        this.init();
    }
    destroy() {
        super.destroy();
    }
    undo() {
        this.clear();
    }
    clear() {
        this._rect = null;
        this.clearGroup();
    }
    saveAnnotation() {
        if (!this._rect) {
            return;
        }
        const pageId = this._pageId;
        const dto = this.buildAnnotationDto();
        const annotation = SquareAnnotation.createFromDto(dto);
        this._docService.appendAnnotationToPage(pageId, annotation);
        this.clear();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPointerDown);
    }
    redrawRect(min, max) {
        this._svgGroup.innerHTML = "";
        const minSize = this._strokeWidth * 2;
        if (max.x - min.x <= minSize || max.y - min.y <= minSize) {
            this._rect = null;
            return;
        }
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._rect = [min.x, min.y, max.x, max.y];
        if (this._cloudMode) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
            path.setAttribute("stroke-width", this._strokeWidth + "");
            path.setAttribute("stroke-linecap", "round");
            path.setAttribute("stroke-linejoin", "round");
            const curveData = buildCloudCurveFromPolyline([
                new Vec2(min.x, min.y),
                new Vec2(max.x, min.y),
                new Vec2(max.x, max.y),
                new Vec2(min.x, max.y),
                new Vec2(min.x, min.y),
            ], SquareAnnotation.cloudArcSize);
            let pathString = "M" + curveData.start.x + "," + curveData.start.y;
            curveData.curves.forEach(x => {
                pathString += ` C${x[0].x},${x[0].y} ${x[1].x},${x[1].y} ${x[2].x},${x[2].y}`;
            });
            path.setAttribute("d", pathString);
            this._svgGroup.append(path);
        }
        else {
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("fill", "none");
            rect.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
            rect.setAttribute("stroke-width", this._strokeWidth + "");
            rect.setAttribute("x", min.x + "");
            rect.setAttribute("y", min.y + "");
            rect.setAttribute("width", max.x - min.x + "");
            rect.setAttribute("height", max.y - min.y + "");
            this._svgGroup.append(rect);
        }
    }
    buildAnnotationDto() {
        const margin = this._strokeWidth / 2 + (this._cloudMode ? SquareAnnotation.cloudArcSize / 2 : 0);
        const lm = margin;
        const tm = margin;
        const rm = margin;
        const bm = margin;
        const rectMargins = [lm, tm, rm, bm];
        const [xmin, ymin, xmax, ymax] = this._rect;
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Square",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._docService.userName || "unknown",
            textContent: null,
            rect: [xmin - lm, ymin - bm, xmax + rm, ymax + tm],
            rectMargins,
            cloud: this._cloudMode,
            color: this._color,
            strokeWidth: this._strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

const geometricAnnotatorTypes = ["square", "circle", "line", "arrow", "polyline", "polygon"];
class GeometricAnnotatorFactory {
    createAnnotator(docService, pageService, parent, options, type) {
        var _a, _b;
        type || (type = this._lastType || "square");
        this._lastType = type;
        const color = (options === null || options === void 0 ? void 0 : options.color) || this._lastColor || [0, 0, 0, 0.9];
        this._lastColor = color;
        const strokeWidth = (options === null || options === void 0 ? void 0 : options.strokeWidth) || this._lastStrokeWidth || 3;
        this._lastStrokeWidth = strokeWidth;
        const cloudMode = (_b = (_a = options === null || options === void 0 ? void 0 : options.cloudMode) !== null && _a !== void 0 ? _a : this._lastCloudMode) !== null && _b !== void 0 ? _b : false;
        this._lastCloudMode = cloudMode;
        const combinedOptions = {
            color,
            strokeWidth,
            cloudMode,
        };
        switch (type) {
            case "square":
                return new GeometricSquareAnnotator(docService, pageService, parent, combinedOptions);
            case "circle":
                return new GeometricCircleAnnotator(docService, pageService, parent, combinedOptions);
            case "line":
                return new GeometricLineAnnotator(docService, pageService, parent, combinedOptions);
            case "arrow":
                return new GeometricArrowAnnotator(docService, pageService, parent, combinedOptions);
            case "polyline":
                return new GeometricPolylineAnnotator(docService, pageService, parent, combinedOptions);
            case "polygon":
                return new GeometricPolygonAnnotator(docService, pageService, parent, combinedOptions);
            default:
                throw new Error(`Invalid geometric annotator type: ${type}`);
        }
    }
}

class PenData {
    constructor(options) {
        this._paths = [];
        this._positionBuffer = [];
        this._options = Object.assign({}, PenData.defaultOptions, options);
        this._group = document.createElementNS("http://www.w3.org/2000/svg", "g");
    }
    get id() {
        return this._options.id;
    }
    get bufferSize() {
        return this._options.bufferSize;
    }
    get strokeWidth() {
        return this._options.strokeWidth;
    }
    get color() {
        return this._options.color.slice();
    }
    get group() {
        return this._group;
    }
    get paths() {
        return this._paths.slice();
    }
    get pathCount() {
        return this._paths.length;
    }
    newPath(startPosition) {
        const [r, g, b, a] = this._options.color || [0, 0, 0, 1];
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
        path.setAttribute("stroke-width", this._options.strokeWidth + "");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        const pathString = "M" + startPosition.x + " " + startPosition.y;
        path.setAttribute("d", pathString);
        this._positionBuffer = [startPosition];
        this._currentPath = { path, positions: [new Vec2(startPosition.x, startPosition.y)] };
        this._currentPathString = pathString;
        this._group.append(path);
    }
    endPath() {
        if (this._currentPath && this._currentPath.positions.length > 1) {
            this._paths.push(this._currentPath);
        }
        this._positionBuffer = null;
        this._currentPath = null;
        this._currentPathString = null;
    }
    removePath(path) {
        if (!path) {
            return;
        }
        path.remove();
        this._paths = this._paths.filter(x => x.path !== path);
    }
    removeLastPath() {
        const pathData = this._paths.pop();
        pathData === null || pathData === void 0 ? void 0 : pathData.path.remove();
    }
    addPosition(pos) {
        this.appendPositionToBuffer(pos);
        this.updateCurrentPath();
    }
    setGroupMatrix(matrix) {
        this._group.setAttribute("transform", `matrix(${matrix.join(" ")})`);
    }
    appendPositionToBuffer(pos) {
        const buffer = this._positionBuffer;
        buffer.push(pos);
        this._positionBuffer = buffer
            .slice(Math.max(0, buffer.length - this._options.bufferSize), buffer.length);
    }
    getAverageBufferPosition(offset) {
        const len = this._positionBuffer.length;
        if (len >= this._options.bufferSize) {
            let totalX = 0;
            let totalY = 0;
            let pos;
            let i;
            let count = 0;
            for (i = offset; i < len; i++) {
                count++;
                pos = this._positionBuffer[i];
                totalX += pos.x;
                totalY += pos.y;
            }
            return new Vec2(totalX / count, totalY / count);
        }
        return null;
    }
    updateCurrentPath() {
        let pos = this.getAverageBufferPosition(0);
        if (!pos) {
            return;
        }
        this._currentPathString += " L" + pos.x + " " + pos.y;
        this._currentPath.positions.push(pos);
        let tmpPath = "";
        for (let offset = 2; offset < this._positionBuffer.length; offset += 2) {
            pos = this.getAverageBufferPosition(offset);
            tmpPath += " L" + pos.x + " " + pos.y;
        }
        this._currentPath.path.setAttribute("d", this._currentPathString + tmpPath);
    }
}
PenData.defaultOptions = {
    bufferSize: 8,
    strokeWidth: 2,
    color: [0, 0, 0, 0.5],
};

class PenAnnotator extends Annotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent);
        this.onPointerDown = (e) => {
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords) {
                return;
            }
            const { pageX: px, pageY: py, pageId } = pageCoords;
            if (!this._annotationPenData || pageId !== this._annotationPenData.id) {
                this.resetTempPenData(pageId);
            }
            this._annotationPenData.newPath(new Vec2(px, py));
            const target = e.target;
            target.addEventListener("pointermove", this.onPointerMove);
            target.addEventListener("pointerup", this.onPointerUp);
            target.addEventListener("pointerout", this.onPointerUp);
            target.setPointerCapture(e.pointerId);
        };
        this.onPointerMove = (e) => {
            if (!e.isPrimary || !this._annotationPenData) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            this.updatePointerCoords(cx, cy);
            const pageCoords = this._pointerCoordsInPageCS;
            if (!pageCoords || pageCoords.pageId !== this._annotationPenData.id) {
                return;
            }
            this._annotationPenData.addPosition(new Vec2(pageCoords.pageX, pageCoords.pageY));
        };
        this.onPointerUp = (e) => {
            var _a;
            if (!e.isPrimary) {
                return;
            }
            const target = e.target;
            target.removeEventListener("pointermove", this.onPointerMove);
            target.removeEventListener("pointerup", this.onPointerUp);
            target.removeEventListener("pointerout", this.onPointerUp);
            target.releasePointerCapture(e.pointerId);
            (_a = this._annotationPenData) === null || _a === void 0 ? void 0 : _a.endPath();
            this.emitDataChanged();
        };
        this.init();
        this._color = (options === null || options === void 0 ? void 0 : options.color) || PenAnnotator.lastColor || [0, 0, 0, 0.9];
        PenAnnotator.lastColor = this._color;
        this._strokeWidth = (options === null || options === void 0 ? void 0 : options.strokeWidth) || PenAnnotator.lastStrokeWidth || 3;
        PenAnnotator.lastStrokeWidth = this._strokeWidth;
    }
    destroy() {
        this.removeTempPenData();
        super.destroy();
    }
    undo() {
        var _a;
        (_a = this._annotationPenData) === null || _a === void 0 ? void 0 : _a.removeLastPath();
        this.emitDataChanged();
    }
    clear() {
        this.removeTempPenData();
    }
    saveAnnotation() {
        if (!this._annotationPenData) {
            return;
        }
        const pageId = this._annotationPenData.id;
        const dto = this.buildAnnotationDto(this._annotationPenData);
        const annotation = InkAnnotation.createFromDto(dto);
        this._docService.appendAnnotationToPage(pageId, annotation);
        this.removeTempPenData();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointerdown", this.onPointerDown);
    }
    refreshGroupPosition() {
        if (!this._annotationPenData) {
            return;
        }
        const page = this._pageService.renderedPages.find(x => x.id === this._annotationPenData.id);
        if (!page) {
            this._annotationPenData.setGroupMatrix([0, 0, 0, 0, 0, 0]);
            return;
        }
        const { height: ph, top: ptop, left: px } = page.viewContainer.getBoundingClientRect();
        const py = ptop + ph;
        const { height: vh, top: vtop, left: vx } = this._overlay.getBoundingClientRect();
        const vy = vtop + vh;
        const offsetX = (px - vx) / this._pageService.scale;
        const offsetY = (vy - py) / this._pageService.scale;
        this._annotationPenData.setGroupMatrix([1, 0, 0, 1, offsetX, offsetY]);
    }
    removeTempPenData() {
        if (this._annotationPenData) {
            this._annotationPenData.group.remove();
            this._annotationPenData = null;
            this.emitDataChanged();
        }
    }
    resetTempPenData(pageId) {
        this.removeTempPenData();
        this._annotationPenData = new PenData({
            id: pageId,
            color: this._color,
            strokeWidth: this._strokeWidth,
        });
        this._svgGroup.append(this._annotationPenData.group);
        this.refreshGroupPosition();
    }
    emitDataChanged() {
        var _a;
        const count = ((_a = this._annotationPenData) === null || _a === void 0 ? void 0 : _a.pathCount) || 0;
        this._docService.eventService.dispatchEvent(new AnnotatorDataChangeEvent({
            annotatorType: "pen",
            elementCount: count,
            undoable: count > 1,
            clearable: count > 0,
            saveable: count > 0,
        }));
    }
    buildAnnotationDto(data) {
        const positions = [];
        const inkList = [];
        data.paths.forEach(path => {
            const ink = [];
            path.positions.forEach(pos => {
                positions.push(pos);
                ink.push(pos.x, pos.y);
            });
            inkList.push(ink);
        });
        const { min: newRectMin, max: newRectMax } = vecMinMax(...positions);
        const halfW = data.strokeWidth / 2;
        const rect = [
            newRectMin.x - halfW,
            newRectMin.y - halfW,
            newRectMax.x + halfW,
            newRectMax.y + halfW,
        ];
        const nowString = new Date().toISOString();
        const dto = {
            uuid: getRandomUuid(),
            annotationType: "/Ink",
            pageId: null,
            dateCreated: nowString,
            dateModified: nowString,
            author: this._docService.userName || "unknown",
            textContent: null,
            rect,
            matrix: [1, 0, 0, 1, 0, 0],
            inkList,
            color: data.color,
            strokeWidth: data.strokeWidth,
            strokeDashGap: null,
        };
        return dto;
    }
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const supportedStampTypes = [
    { type: "/Draft", name: "Draft" },
    { type: "/Approved", name: "Approved" },
    { type: "/NotApproved", name: "Not Approved" },
    { type: "/Departmental", name: "Departmental" },
    { type: "/Confidential", name: "Confidential" },
    { type: "/Final", name: "Final" },
    { type: "/Expired", name: "Expired" },
    { type: "/AsIs", name: "As Is" },
    { type: "/Sold", name: "Sold" },
    { type: "/Experimental", name: "Experimental" },
    { type: "/ForComment", name: "For Comment" },
    { type: "/TopSecret", name: "Top Secret" },
    { type: "/ForPublicRelease", name: "For Public" },
    { type: "/NotForPublicRelease", name: "Not For Public" },
];
class StampAnnotator extends Annotator {
    constructor(docService, pageService, parent, type) {
        super(docService, pageService, parent);
        this._addedAnnotations = [];
        this.onPointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            const { height: oh, top, left: ox } = this._parent.getBoundingClientRect();
            const oy = top + oh;
            const offsetX = (cx - ox) / this._pageService.scale;
            const offsetY = (oy - cy) / this._pageService.scale;
            const [x1, y1, x2, y2] = this._tempAnnotation.Rect;
            this._svgGroup.setAttribute("transform", `translate(${offsetX - (x2 - x1) / 2} ${offsetY - (y2 - y1) / 2})`);
            this.updatePointerCoords(cx, cy);
        };
        this.onPointerUp = (e) => {
            var _a, _b, _c;
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            if (e.pointerType === "touch") {
                const longTap = performance.now() - ((_a = this._lastPointerDownInfo) === null || _a === void 0 ? void 0 : _a.timestamp) > 700;
                if (longTap) {
                    const downX = ((_b = this._lastPointerDownInfo) === null || _b === void 0 ? void 0 : _b.clientX) || 0;
                    const downY = ((_c = this._lastPointerDownInfo) === null || _c === void 0 ? void 0 : _c.clientY) || 0;
                    const displacement = Math.abs(getDistance(cx, cy, downX, downY));
                    const displaced = displacement > 7.5;
                    if (!displaced) {
                        return;
                    }
                }
            }
            const pageCoords = this._pageService.getPageCoordsUnderPointer(cx, cy);
            this._pointerCoordsInPageCS = pageCoords;
            if (!pageCoords || !this._tempAnnotation) {
                return;
            }
            const { pageId, pageX, pageY } = this._pointerCoordsInPageCS;
            this._tempAnnotation.moveTo(pageX, pageY);
            this._pageId = pageId;
            this.saveAnnotation();
        };
        if (type) {
            if (!Object.values(stampTypes).includes(type)) {
                throw new Error(`Unsupported stamp type: '${type}'`);
            }
            this._type = type;
            StampAnnotator.lastType = this._type;
        }
        else {
            this._type = StampAnnotator.lastType;
        }
        this.init();
    }
    destroy() {
        this.emitDataChanged(0, false, false);
        this._tempAnnotation = null;
        super.destroy();
    }
    undo() {
        if (!this._addedAnnotations.length) {
            return;
        }
        const lastAnnotation = this._addedAnnotations.pop();
        this._docService.removeAnnotation(lastAnnotation);
        const empty = !this._addedAnnotations.length;
        this.emitDataChanged(this._addedAnnotations.length, !empty, !empty);
    }
    clear() {
        while (this._addedAnnotations.length) {
            this.undo();
        }
    }
    saveAnnotation() {
        if (!this._pageId || !this._tempAnnotation) {
            return;
        }
        this._docService.appendAnnotationToPage(this._pageId, this._tempAnnotation);
        this._addedAnnotations.push(this._tempAnnotation);
        this.emitDataChanged(this._addedAnnotations.length, true, true);
        this.createTempStampAnnotationAsync();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointermove", this.onPointerMove);
        this._overlay.addEventListener("pointerup", this.onPointerUp);
        this.createTempStampAnnotationAsync();
    }
    emitDataChanged(count, clearable, undoable) {
        this._docService.eventService.dispatchEvent(new AnnotatorDataChangeEvent({
            annotatorType: "stamp",
            elementCount: count,
            undoable,
            clearable,
            saveable: false,
        }));
    }
    createTempStampAnnotationAsync() {
        return __awaiter$6(this, void 0, void 0, function* () {
            const stamp = StampAnnotation.createStandard(this._type, this._docService.userName);
            const renderResult = yield stamp.renderAsync();
            this._svgGroup.innerHTML = "";
            this._svgGroup.append(renderResult);
            this._tempAnnotation = stamp;
        });
    }
    refreshGroupPosition() {
    }
}
StampAnnotator.lastType = "/Draft";

class ContextMenu {
    constructor() {
        this.onPointerDownOutside = (e) => {
            if (!this._shown) {
                return;
            }
            const target = e.composedPath()[0];
            if (!target.closest("#context-menu")) {
                this.hide();
            }
        };
        this._container = document.createElement("div");
        this._container.id = "context-menu";
        this.hide();
        document.addEventListener("pointerdown", this.onPointerDownOutside);
    }
    set content(value) {
        var _a;
        (_a = this._content) === null || _a === void 0 ? void 0 : _a.forEach(x => x.remove());
        if (value === null || value === void 0 ? void 0 : value.length) {
            value.forEach(x => this._container.append(x));
            this._content = value;
        }
        else {
            this._content = null;
        }
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        this._enabled = !!value;
    }
    destroy() {
        this.clear();
        document.removeEventListener("pointerdown", this.onPointerDownOutside);
    }
    show(pointerPosition, parent) {
        parent.append(this._container);
        this._shown = true;
        setTimeout(() => {
            this.setContextMenuPosition(pointerPosition, parent);
            this._container.style.opacity = "1";
        }, 0);
    }
    hide() {
        this._container.style.opacity = "0";
        this._container.remove();
        this._shown = false;
    }
    clear() {
        this.hide();
        this.content = null;
    }
    setContextMenuPosition(pointerPosition, parent) {
        const menuDimension = new Vec2(this._container.offsetWidth, this._container.offsetHeight);
        const menuPosition = new Vec2();
        const parentRect = parent.getBoundingClientRect();
        const relPointerPosition = new Vec2(pointerPosition.x - parentRect.x, pointerPosition.y - parentRect.y);
        if (relPointerPosition.x + menuDimension.x > parentRect.width + parentRect.x) {
            menuPosition.x = relPointerPosition.x - menuDimension.x;
        }
        else {
            menuPosition.x = relPointerPosition.x;
        }
        if (relPointerPosition.y + menuDimension.y > parentRect.height + parentRect.y) {
            menuPosition.y = relPointerPosition.y - menuDimension.y;
        }
        else {
            menuPosition.y = relPointerPosition.y;
        }
        this._container.style.left = menuPosition.x + parent.scrollLeft + "px";
        this._container.style.top = menuPosition.y + parent.scrollTop + "px";
    }
}

class TextAnnotator extends Annotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent);
        this._color = (options === null || options === void 0 ? void 0 : options.color) || [0, 0, 0, 1];
        this._strokeWidth = (options === null || options === void 0 ? void 0 : options.strokeWidth) || 3;
    }
    emitDataChanged(count, saveable, clearable, undoable) {
        this._docService.eventService.dispatchEvent(new AnnotatorDataChangeEvent({
            annotatorType: "text",
            elementCount: count,
            undoable,
            clearable,
            saveable,
        }));
    }
}

class TextMarkupAnnotator extends TextAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options);
        this._svgGroupByPageId = new Map();
        this._coordsByPageId = new Map();
        this.onTextSelectionChange = (e) => {
            var _a;
            this.updateCoords(((_a = e === null || e === void 0 ? void 0 : e.detail) === null || _a === void 0 ? void 0 : _a.selectionInfos) || []);
        };
    }
    destroy() {
        this._docService.eventService.removeListener(textSelectionChangeEvent, this.onTextSelectionChange);
        this.clearGroup();
        super.destroy();
    }
    undo() {
        this.clear();
    }
    clear() {
        this._coordsByPageId.clear();
        this.clearGroup();
    }
    init() {
        super.init();
        this._docService.eventService.addListener(textSelectionChangeEvent, this.onTextSelectionChange);
    }
    clearGroup() {
        this._svgGroupByPageId.forEach(x => x.innerHTML = "");
        this.emitDataChanged(0);
    }
    refreshGroupPosition() {
        const { height: vh, top: vtop, left: vx } = this._overlay.getBoundingClientRect();
        const scale = this._pageService.scale;
        this._pageService.renderedPages.forEach(x => {
            const { height: ph, top: ptop, left: px } = x.viewContainer.getBoundingClientRect();
            const py = ptop + ph;
            const vy = vtop + vh;
            const offsetX = (px - vx) / scale;
            const offsetY = (vy - py) / scale;
            let svg;
            if (this._svgGroupByPageId.has(x.id)) {
                svg = this._svgGroupByPageId.get(x.id);
            }
            else {
                svg = document.createElementNS("http://www.w3.org/2000/svg", "g");
                this._svgGroupByPageId.set(x.id, svg);
                this._svgGroup.append(svg);
            }
            svg.setAttribute("transform", `matrix(${[1, 0, 0, 1, offsetX, offsetY].join(" ")})`);
        });
    }
    updateCoords(selections) {
        var _a;
        this._coordsByPageId.clear();
        for (const selection of selections) {
            const bl = this._pageService.getPageCoordsUnderPointer(selection.bottomLeft.x, selection.bottomLeft.y);
            const br = this._pageService.getPageCoordsUnderPointer(selection.bottomRight.x, selection.bottomRight.y);
            const tr = this._pageService.getPageCoordsUnderPointer(selection.topRight.x, selection.topRight.y);
            const tl = this._pageService.getPageCoordsUnderPointer(selection.topLeft.x, selection.topLeft.y);
            if (!bl || !br || !tr || !tl) {
                continue;
            }
            if (new Set([bl.pageId, br.pageId, tr.pageId, tl.pageId]).size > 1) {
                throw new Error("Not all the text selection corners are inside the same page");
            }
            const quadPoints = [
                tl.pageX, tl.pageY,
                tr.pageX, tr.pageY,
                bl.pageX, bl.pageY,
                br.pageX, br.pageY,
            ];
            const pageId = bl.pageId;
            if (this._coordsByPageId.has(pageId)) {
                this._coordsByPageId.get(pageId).push(quadPoints);
            }
            else {
                this._coordsByPageId.set(pageId, [quadPoints]);
            }
        }
        this.redraw();
        if ((_a = this._coordsByPageId) === null || _a === void 0 ? void 0 : _a.size) {
            this.emitDataChanged(this._coordsByPageId.size, true, true);
        }
        else {
            this.emitDataChanged(0);
        }
    }
    buildAnnotationDtos(type) {
        const nowString = new Date().toISOString();
        const dtos = [];
        this._coordsByPageId.forEach((quads, pageId) => {
            const dto = {
                uuid: getRandomUuid(),
                annotationType: type,
                pageId,
                dateCreated: nowString,
                dateModified: nowString,
                author: this._docService.userName || "unknown",
                textContent: null,
                rect: null,
                quadPoints: quads.flat(),
                color: this._color,
                strokeWidth: this._strokeWidth,
                strokeDashGap: null,
            };
            dtos.push(dto);
        });
        return dtos;
    }
}

class TextHighlightAnnotator extends TextMarkupAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this.init();
    }
    saveAnnotation() {
        if (!this._coordsByPageId.size) {
            return;
        }
        const dtos = this.buildAnnotationDtos("/Highlight");
        dtos.forEach(dto => {
            const annotation = HighlightAnnotation.createFromDto(dto);
            this._docService.appendAnnotationToPage(dto.pageId, annotation);
        });
        this.clear();
    }
    redraw() {
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._svgGroupByPageId.forEach((group, pageId) => {
            group.innerHTML = "";
            const quads = this._coordsByPageId.get(pageId);
            if (quads === null || quads === void 0 ? void 0 : quads.length) {
                quads.forEach(quad => {
                    const [x3, y3, x2, y2, x0, y0, x1, y1] = quad;
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("fill", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
                    path.setAttribute("stroke", "none");
                    path.setAttribute("d", `M ${x0},${y0} L ${x1},${y1} L ${x2},${y2} L ${x3},${y3} Z`);
                    group.append(path);
                });
            }
        });
    }
}

class TextSquigglyAnnotator extends TextMarkupAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this.init();
    }
    saveAnnotation() {
        if (!this._coordsByPageId.size) {
            return;
        }
        const dtos = this.buildAnnotationDtos("/Squiggly");
        dtos.forEach(dto => {
            const annotation = SquigglyAnnotation.createFromDto(dto);
            this._docService.appendAnnotationToPage(dto.pageId, annotation);
        });
        this.clear();
    }
    redraw() {
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._svgGroupByPageId.forEach((group, pageId) => {
            group.innerHTML = "";
            const quads = this._coordsByPageId.get(pageId);
            if (quads === null || quads === void 0 ? void 0 : quads.length) {
                quads.forEach(quad => {
                    const [, , , , x0, y0, x1, y1] = quad;
                    const squigglyLinePoints = buildSquigglyLine(new Vec2(x0, y0), new Vec2(x1, y1), SquigglyAnnotation.squiggleSize);
                    if (squigglyLinePoints === null || squigglyLinePoints === void 0 ? void 0 : squigglyLinePoints.length) {
                        let pathTextData = `M ${squigglyLinePoints[0].x},${squigglyLinePoints[0].y} `;
                        for (let j = 1; j < squigglyLinePoints.length; j++) {
                            pathTextData += `L ${squigglyLinePoints[j].x},${squigglyLinePoints[j].y} `;
                        }
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute("fill", "none");
                        path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
                        path.setAttribute("stroke-width", this._strokeWidth + "");
                        path.setAttribute("stroke-linecap", "square");
                        path.setAttribute("d", pathTextData);
                        group.append(path);
                    }
                });
            }
        });
    }
}

class TextStrikeoutAnnotator extends TextMarkupAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this.init();
    }
    saveAnnotation() {
        if (!this._coordsByPageId.size) {
            return;
        }
        const dtos = this.buildAnnotationDtos("/Strikeout");
        dtos.forEach(dto => {
            const annotation = StrikeoutAnnotation.createFromDto(dto);
            this._docService.appendAnnotationToPage(dto.pageId, annotation);
        });
        this.clear();
    }
    redraw() {
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._svgGroupByPageId.forEach((group, pageId) => {
            group.innerHTML = "";
            const quads = this._coordsByPageId.get(pageId);
            const bottomLeft = new Vec2();
            const bottomRight = new Vec2();
            const topRight = new Vec2();
            const topLeft = new Vec2();
            const start = new Vec2();
            const end = new Vec2();
            if (quads === null || quads === void 0 ? void 0 : quads.length) {
                quads.forEach(quad => {
                    const [x3, y3, x2, y2, x0, y0, x1, y1] = quad;
                    bottomLeft.set(x0, y0);
                    bottomRight.set(x1, y1);
                    topRight.set(x2, y2);
                    topLeft.set(x3, y3);
                    start.setFromVec2(bottomLeft).add(topLeft).multiplyByScalar(0.5);
                    end.setFromVec2(bottomRight).add(topRight).multiplyByScalar(0.5);
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("fill", "none");
                    path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
                    path.setAttribute("stroke-width", this._strokeWidth + "");
                    path.setAttribute("stroke-linecap", "square");
                    path.setAttribute("d", `M ${start.x},${start.y} L ${end.x},${end.y}`);
                    group.append(path);
                });
            }
        });
    }
}

class TextUnderlineAnnotator extends TextMarkupAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this.init();
    }
    saveAnnotation() {
        if (!this._coordsByPageId.size) {
            return;
        }
        const dtos = this.buildAnnotationDtos("/Underline");
        dtos.forEach(dto => {
            const annotation = UnderlineAnnotation.createFromDto(dto);
            this._docService.appendAnnotationToPage(dto.pageId, annotation);
        });
        this.clear();
    }
    redraw() {
        const [r, g, b, a] = this._color || [0, 0, 0, 1];
        this._svgGroupByPageId.forEach((group, pageId) => {
            group.innerHTML = "";
            const quads = this._coordsByPageId.get(pageId);
            if (quads === null || quads === void 0 ? void 0 : quads.length) {
                quads.forEach(quad => {
                    const [, , , , x0, y0, x1, y1] = quad;
                    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.setAttribute("fill", "none");
                    path.setAttribute("stroke", `rgba(${r * 255},${g * 255},${b * 255},${a})`);
                    path.setAttribute("stroke-width", this._strokeWidth + "");
                    path.setAttribute("stroke-linecap", "square");
                    path.setAttribute("d", `M ${x0},${y0} L ${x1},${y1}`);
                    group.append(path);
                });
            }
        });
    }
}

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class TextNoteAnnotator extends TextAnnotator {
    constructor(docService, pageService, parent, options) {
        super(docService, pageService, parent, options || {});
        this._addedAnnotations = [];
        this.onPointerMove = (e) => {
            if (!e.isPrimary) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            const { height: oh, top, left: ox } = this._parent.getBoundingClientRect();
            const oy = top + oh;
            const offsetX = (cx - ox) / this._pageService.scale;
            const offsetY = (oy - cy) / this._pageService.scale;
            const [x1, y1, x2, y2] = this._tempAnnotation.Rect;
            this._svgGroup.setAttribute("transform", `translate(${offsetX - (x2 - x1) / 4} ${offsetY - (y2 - y1) / 4})`);
            this.updatePointerCoords(cx, cy);
        };
        this.onPointerUp = (e) => {
            var _a, _b, _c;
            if (!e.isPrimary || e.button === 2) {
                return;
            }
            const { clientX: cx, clientY: cy } = e;
            if (e.pointerType === "touch") {
                const longTap = performance.now() - ((_a = this._lastPointerDownInfo) === null || _a === void 0 ? void 0 : _a.timestamp) > 700;
                if (longTap) {
                    const downX = ((_b = this._lastPointerDownInfo) === null || _b === void 0 ? void 0 : _b.clientX) || 0;
                    const downY = ((_c = this._lastPointerDownInfo) === null || _c === void 0 ? void 0 : _c.clientY) || 0;
                    const displacement = Math.abs(getDistance(cx, cy, downX, downY));
                    const displaced = displacement > 7.5;
                    if (!displaced) {
                        return;
                    }
                }
            }
            const pageCoords = this._pageService.getPageCoordsUnderPointer(cx, cy);
            this._pointerCoordsInPageCS = pageCoords;
            if (!pageCoords || !this._tempAnnotation) {
                return;
            }
            const { pageId, pageX, pageY } = this._pointerCoordsInPageCS;
            const [x1, y1, x2, y2] = this._tempAnnotation.Rect;
            this._tempAnnotation.moveTo(pageX + (x2 - x1) / 4, pageY + (y2 - y1) / 4);
            this._pageId = pageId;
            this.saveAnnotation();
        };
        this.init();
    }
    destroy() {
        this.emitDataChanged(0);
        this._tempAnnotation = null;
        super.destroy();
    }
    undo() {
        if (!this._addedAnnotations.length) {
            return;
        }
        const lastAnnotation = this._addedAnnotations.pop();
        this._docService.removeAnnotation(lastAnnotation);
        const empty = !this._addedAnnotations.length;
        this.emitDataChanged(this._addedAnnotations.length, false, !empty, !empty);
    }
    clear() {
        while (this._addedAnnotations.length) {
            this.undo();
        }
    }
    saveAnnotation() {
        if (!this._pageId || !this._tempAnnotation) {
            return;
        }
        this._docService.appendAnnotationToPage(this._pageId, this._tempAnnotation);
        this._addedAnnotations.push(this._tempAnnotation);
        this.emitDataChanged(this._addedAnnotations.length, false, true, true);
        this.createTempNoteAnnotationAsync();
    }
    init() {
        super.init();
        this._overlay.addEventListener("pointermove", this.onPointerMove);
        this._overlay.addEventListener("pointerup", this.onPointerUp);
        this.createTempNoteAnnotationAsync();
    }
    createTempNoteAnnotationAsync() {
        return __awaiter$5(this, void 0, void 0, function* () {
            const note = TextAnnotation.createStandard(this._docService.userName, this._color);
            const renderResult = yield note.renderAsync();
            this._svgGroup.innerHTML = "";
            this._svgGroup.append(renderResult);
            this._tempAnnotation = note;
        });
    }
    refreshGroupPosition() {
    }
}

const textAnnotatorTypes = ["highlight", "strikeout", "squiggly", "underline",
    "note", "freeText", "freeTextCallout"];
class TextAnnotatorFactory {
    createAnnotator(docService, pageService, parent, options, type) {
        type || (type = this._lastType || "highlight");
        this._lastType = type;
        const color = (options === null || options === void 0 ? void 0 : options.color) || this._lastColor || [0, 0, 0, 0.9];
        this._lastColor = color;
        const strokeWidth = (options === null || options === void 0 ? void 0 : options.strokeWidth) || this._lastStrokeWidth || 2;
        this._lastStrokeWidth = strokeWidth;
        const combinedOptions = {
            color,
            strokeWidth,
        };
        switch (type) {
            case "note":
                return new TextNoteAnnotator(docService, pageService, parent, combinedOptions);
            case "freeText":
                return null;
            case "freeTextCallout":
                return null;
            case "highlight":
                return new TextHighlightAnnotator(docService, pageService, parent, combinedOptions);
            case "squiggly":
                return new TextSquigglyAnnotator(docService, pageService, parent, combinedOptions);
            case "strikeout":
                return new TextStrikeoutAnnotator(docService, pageService, parent, combinedOptions);
            case "underline":
                return new TextUnderlineAnnotator(docService, pageService, parent, combinedOptions);
            default:
                throw new Error(`Invalid geometric annotator type: ${type}`);
        }
    }
}

class AnnotationService {
    constructor(docService, pageService, viewer) {
        this._annotationColors = [
            [0, 0, 0, 0.5],
            [0.804, 0, 0, 0.5],
            [0, 0.804, 0, 0.5],
            [0, 0, 0.804, 0.5],
            [1, 0.5, 0, 0.5],
            [1, 0.2, 1, 0.5],
        ];
        this._strokeColor = this._annotationColors[0];
        this._strokeWidth = 3;
        this._stampType = supportedStampTypes[0].type;
        this._geometricCloudMode = false;
        this._geometricSubmode = geometricAnnotatorTypes[0];
        this._textSubmode = textAnnotatorTypes[0];
        this.onContextMenu = (event) => {
            if (this._contextMenu.enabled) {
                event.preventDefault();
                this._contextMenu.show(new Vec2(event.clientX, event.clientY), this._viewer.container);
            }
        };
        this.onPagesRendered = (event) => {
            this._contextMenu.hide();
        };
        if (!docService) {
            throw new Error("Document service is not defined");
        }
        if (!pageService) {
            throw new Error("Page service is not defined");
        }
        if (!viewer) {
            throw new Error("Viewer is not defined");
        }
        this._docService = docService;
        this._pageService = pageService;
        this._viewer = viewer;
        this.init();
    }
    get mode() {
        return this._mode;
    }
    set mode(value) {
        this.setMode(value);
    }
    get annotator() {
        return this._annotator;
    }
    destroy() {
        var _a, _b, _c;
        this._docService.eventService.removeListener(pagesRenderedEvent, this.onPagesRendered);
        this._viewer.container.removeEventListener("contextmenu", this.onContextMenu);
        (_a = this._viewerResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this._contextMenu) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this._annotator) === null || _c === void 0 ? void 0 : _c.destroy();
    }
    init() {
        this._docService.eventService.addListener(pagesRenderedEvent, this.onPagesRendered);
        this._viewer.container.addEventListener("contextmenu", this.onContextMenu);
        const viewerRObserver = new ResizeObserver((entries) => {
            var _a;
            (_a = this._contextMenu) === null || _a === void 0 ? void 0 : _a.hide();
        });
        viewerRObserver.observe(this._viewer.container);
        this._viewerResizeObserver = viewerRObserver;
        this._contextMenu = new ContextMenu();
        this._geometricFactory = new GeometricAnnotatorFactory();
        this._textFactory = new TextAnnotatorFactory();
    }
    setMode(mode) {
        var _a;
        mode || (mode = this._mode);
        this._contextMenu.content = [];
        (_a = this._annotator) === null || _a === void 0 ? void 0 : _a.destroy();
        this._docService.setSelectedAnnotation(null);
        this._mode = mode;
        if (this._mode === "text"
            && (this._textSubmode === "highlight"
                || this._textSubmode === "squiggly"
                || this._textSubmode === "strikeout"
                || this._textSubmode === "underline")) {
            this._viewer.container.classList.add("mode-text-markup");
        }
        else {
            this._viewer.container.classList.remove("mode-text-markup");
        }
        switch (mode) {
            case "select":
                this._contextMenu.enabled = false;
                return;
            case "stamp":
                this._annotator = new StampAnnotator(this._docService, this._pageService, this._viewer.container, this._stampType);
                break;
            case "pen":
                this._annotator = new PenAnnotator(this._docService, this._pageService, this._viewer.container, {
                    strokeWidth: this._strokeWidth,
                    color: this._strokeColor,
                });
                break;
            case "geometric":
                this._annotator = this._geometricFactory.createAnnotator(this._docService, this._pageService, this._viewer.container, {
                    strokeWidth: this._strokeWidth,
                    color: this._strokeColor,
                    cloudMode: this._geometricCloudMode,
                }, this._geometricSubmode);
                break;
            case "text":
                this._strokeWidth = 2;
                this._annotator = this._textFactory.createAnnotator(this._docService, this._pageService, this._viewer.container, {
                    strokeWidth: this._strokeWidth,
                    color: this._strokeColor,
                }, this._textSubmode);
                break;
            default:
                throw new Error(`Invalid annotation mode: ${mode}`);
        }
        const cmContent = this.buildContextMenuContent();
        this._contextMenu.content = cmContent;
        this._contextMenu.enabled = true;
    }
    buildContextMenuContent() {
        switch (this._mode) {
            case "select":
                return [];
            case "stamp":
                return [this.buildStampTypePicker()];
            case "pen":
                return [
                    this.buildStrokeColorPicker(),
                    this.buildStrokeWidthSlider(false),
                ];
            case "geometric":
                return [
                    this.buildGeometricSubmodePicker(),
                    this.buildStrokeColorPicker(),
                    this.buildStrokeWidthSlider(true),
                ];
            case "text":
                return [
                    this.buildTextSubmodePicker(),
                    this.buildStrokeColorPicker(),
                ];
            default:
                throw new Error(`Invalid annotation mode: ${this._mode}`);
        }
    }
    buildStampTypePicker() {
        const stampTypes = supportedStampTypes;
        const pickerDiv = document.createElement("div");
        pickerDiv.classList.add("context-menu-content", "column");
        stampTypes.forEach(x => {
            const item = document.createElement("div");
            item.classList.add("context-menu-stamp-select-button");
            if (x.type === this._stampType) {
                item.classList.add("on");
            }
            item.addEventListener("click", () => {
                this._stampType = x.type;
                this.setMode();
            });
            const stampName = document.createElement("div");
            stampName.innerHTML = x.name;
            item.append(stampName);
            pickerDiv.append(item);
        });
        return pickerDiv;
    }
    buildGeometricSubmodePicker() {
        const submodePicker = document.createElement("div");
        submodePicker.classList.add("context-menu-content", "row");
        geometricAnnotatorTypes.forEach(x => {
            const item = document.createElement("div");
            item.classList.add("panel-button");
            if (x === this._geometricSubmode) {
                item.classList.add("on");
            }
            item.addEventListener("click", () => {
                this._geometricSubmode = x;
                this.setMode();
            });
            item.innerHTML = geometricIcons[x];
            submodePicker.append(item);
        });
        return submodePicker;
    }
    buildTextSubmodePicker() {
        const submodePicker = document.createElement("div");
        submodePicker.classList.add("context-menu-content", "row");
        textAnnotatorTypes.forEach(x => {
            const item = document.createElement("div");
            item.classList.add("panel-button");
            if (x === "freeText" || x === "freeTextCallout") {
                item.classList.add("disabled");
            }
            if (x === this._textSubmode) {
                item.classList.add("on");
            }
            item.addEventListener("click", () => {
                this._textSubmode = x;
                this.setMode();
            });
            item.innerHTML = textIcons[x];
            submodePicker.append(item);
        });
        return submodePicker;
    }
    buildStrokeColorPicker() {
        const colorPickerDiv = document.createElement("div");
        colorPickerDiv.classList.add("context-menu-content", "row");
        this._annotationColors.forEach(x => {
            const item = document.createElement("div");
            item.classList.add("panel-button");
            if (x === this._strokeColor) {
                item.classList.add("on");
            }
            item.addEventListener("click", () => {
                this._strokeColor = x;
                this.setMode();
            });
            const colorIcon = document.createElement("div");
            colorIcon.classList.add("context-menu-color-icon");
            colorIcon.style.backgroundColor = `rgb(${x[0] * 255},${x[1] * 255},${x[2] * 255})`;
            item.append(colorIcon);
            colorPickerDiv.append(item);
        });
        return colorPickerDiv;
    }
    buildStrokeWidthSlider(cloudButtons) {
        const disableLineTypeButtons = !cloudButtons
            || this._geometricSubmode === "polyline"
            || this._geometricSubmode === "line"
            || this._geometricSubmode === "arrow";
        const div = document.createElement("div");
        div.classList.add("context-menu-content", "row");
        const cloudyLineButton = document.createElement("div");
        cloudyLineButton.classList.add("panel-button");
        if (disableLineTypeButtons) {
            cloudyLineButton.classList.add("disabled");
        }
        else {
            if (this._geometricCloudMode) {
                cloudyLineButton.classList.add("on");
            }
            cloudyLineButton.addEventListener("click", () => {
                this._geometricCloudMode = true;
                this.setMode();
            });
        }
        cloudyLineButton.innerHTML = lineTypeIcons.cloudy;
        div.append(cloudyLineButton);
        const straightLineButton = document.createElement("div");
        straightLineButton.classList.add("panel-button");
        if (disableLineTypeButtons) {
            straightLineButton.classList.add("disabled");
        }
        else {
            if (!this._geometricCloudMode) {
                straightLineButton.classList.add("on");
            }
            straightLineButton.addEventListener("click", () => {
                this._geometricCloudMode = false;
                this.setMode();
            });
        }
        straightLineButton.innerHTML = lineTypeIcons.straight;
        div.append(straightLineButton);
        const slider = document.createElement("input");
        slider.setAttribute("type", "range");
        slider.setAttribute("min", "1");
        slider.setAttribute("max", "32");
        slider.setAttribute("step", "1");
        slider.setAttribute("value", this._strokeWidth + "");
        slider.classList.add("context-menu-slider");
        slider.addEventListener("change", () => {
            this._strokeWidth = slider.valueAsNumber;
            this.setMode();
        });
        div.append(slider);
        return div;
    }
}

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const viewerModes = ["text", "hand", "annotation"];
class Viewer {
    constructor(pageService, container, options) {
        this._scale = 1;
        this._pointerInfo = {
            lastPos: null,
            downPos: null,
            downScroll: null,
        };
        this._pinchInfo = {
            active: false,
            lastDist: 0,
            minDist: 10,
            sensitivity: 0.025,
            target: null,
        };
        this.onPagesLoaded = (event) => {
            var _a;
            (_a = event.detail.pages) === null || _a === void 0 ? void 0 : _a.forEach(x => {
                x.scale = this._scale;
                this._container.append(x.viewContainer);
            });
            this.renderVisible();
        };
        this.onScrollRequest = (event) => {
            this.scrollToPage(event.detail.pageIndex);
        };
        this.onPointerMove = (event) => {
            const { clientX, clientY } = event;
            this._pointerInfo.lastPos = new Vec2(clientX, clientY);
        };
        this.onScroll = (e) => {
            this.renderVisible();
        };
        this.onPointerDownScroll = (event) => {
            if (this._mode !== "hand") {
                return;
            }
            const { clientX, clientY } = event;
            this._pointerInfo.downPos = new Vec2(clientX, clientY);
            this._pointerInfo.downScroll = new Vec2(this._container.scrollLeft, this._container.scrollTop);
            const onPointerMove = (moveEvent) => {
                const { x, y } = this._pointerInfo.downPos;
                const { x: left, y: top } = this._pointerInfo.downScroll;
                const dX = moveEvent.clientX - x;
                const dY = moveEvent.clientY - y;
                this._container.scrollTo(left - dX, top - dY);
            };
            const onPointerUp = (upEvent) => {
                this._pointerInfo.downPos = null;
                this._pointerInfo.downScroll = null;
                document.removeEventListener("pointermove", onPointerMove);
                document.removeEventListener("pointerup", onPointerUp);
                document.removeEventListener("pointerout", onPointerUp);
            };
            document.addEventListener("pointermove", onPointerMove);
            document.addEventListener("pointerup", onPointerUp);
            document.addEventListener("pointerout", onPointerUp);
        };
        this.onWheelZoom = (event) => {
            if (!event.ctrlKey) {
                return;
            }
            event.preventDefault();
            if (event.deltaY > 0) {
                this.zoomOutCentered(this._pointerInfo.lastPos);
            }
            else {
                this.zoomInCentered(this._pointerInfo.lastPos);
            }
        };
        this.onTouchZoom = (event) => {
            if (event.touches.length !== 2) {
                return;
            }
            const a = event.touches[0];
            const b = event.touches[1];
            this._pinchInfo.active = true;
            this._pinchInfo.lastDist = getDistance(a.clientX, a.clientY, b.clientX, b.clientY);
            const onTouchMove = (moveEvent) => {
                if (moveEvent.touches.length !== 2) {
                    return;
                }
                const mA = moveEvent.touches[0];
                const mB = moveEvent.touches[1];
                const dist = getDistance(mA.clientX, mA.clientY, mB.clientX, mB.clientY);
                const delta = dist - this._pinchInfo.lastDist;
                const factor = Math.floor(delta / this._pinchInfo.minDist);
                if (factor) {
                    const center = new Vec2((mB.clientX + mA.clientX) / 2, (mB.clientY + mA.clientY) / 2);
                    this._pinchInfo.lastDist = dist;
                    this.zoom(factor * this._pinchInfo.sensitivity, center);
                }
            };
            const onTouchEnd = (endEvent) => {
                this._pinchInfo.active = false;
                this._pinchInfo.lastDist = 0;
                event.target.removeEventListener("touchmove", onTouchMove);
                event.target.removeEventListener("touchend", onTouchEnd);
                event.target.removeEventListener("touchcancel", onTouchEnd);
            };
            event.target.addEventListener("touchmove", onTouchMove);
            event.target.addEventListener("touchend", onTouchEnd);
            event.target.addEventListener("touchcancel", onTouchEnd);
        };
        if (!container) {
            throw new Error("Container is not defined");
        }
        this._pageService = pageService;
        this._container = container;
        this._minScale = (options === null || options === void 0 ? void 0 : options.minScale) || 0.25;
        this._maxScale = (options === null || options === void 0 ? void 0 : options.maxScale) || 4;
        this.init();
    }
    get container() {
        return this._container;
    }
    get mode() {
        return this._mode;
    }
    set mode(value) {
        if (this._dialogClose) {
            this._dialogClose();
        }
        if (!value || value === this._mode) {
            return;
        }
        this._mode = value;
    }
    get scale() {
        return this._scale;
    }
    destroy() {
        this._pageService.eventService.removeListener(pagesLoadedEvent, this.onPagesLoaded);
        this._pageService.eventService.removeListener(currentPageChangeRequestEvent, this.onScrollRequest);
    }
    zoomOut() {
        this.zoomOutCentered();
    }
    zoomIn() {
        this.zoomInCentered();
    }
    zoomFitViewer() {
        const cWidth = this._container.getBoundingClientRect().width;
        const pWidth = this._pageService.getCurrentPage().viewContainer.getBoundingClientRect().width;
        const scale = clamp((cWidth - 20) / pWidth * this._scale, this._minScale, this._maxScale);
        this.setScale(scale);
        this.scrollToPage(this._pageService.currentPageIndex);
    }
    zoomFitPage() {
        const { width: cWidth, height: cHeight } = this._container.getBoundingClientRect();
        const { width: pWidth, height: pHeight } = this._pageService.getCurrentPage().viewContainer.getBoundingClientRect();
        const hScale = clamp((cWidth - 20) / pWidth * this._scale, this._minScale, this._maxScale);
        const vScale = clamp((cHeight - 20) / pHeight * this._scale, this._minScale, this._maxScale);
        this.setScale(Math.min(hScale, vScale));
        this.scrollToPage(this._pageService.currentPageIndex);
    }
    showTextDialogAsync(initialText) {
        return __awaiter$4(this, void 0, void 0, function* () {
            if (this._dialogClose) {
                return;
            }
            const dialogContainer = document.createElement("div");
            dialogContainer.id = "text-dialog";
            dialogContainer.classList.add("full-size-dialog");
            dialogContainer.innerHTML = textDialogHtml;
            this._container.append(dialogContainer);
            this._container.classList.add("dialog-shown");
            let value = initialText || "";
            const input = dialogContainer.querySelector("#text-input");
            input.placeholder = "Enter text...";
            input.value = value;
            input.addEventListener("change", () => value = input.value);
            const textPromise = new Promise((resolve, reject) => {
                const ok = () => {
                    resolve(value || "");
                };
                const cancel = () => {
                    resolve(null);
                };
                dialogContainer.addEventListener("click", (e) => {
                    if (e.target === dialogContainer) {
                        cancel();
                    }
                });
                dialogContainer.querySelector("#text-ok").addEventListener("click", ok);
                dialogContainer.querySelector("#text-cancel").addEventListener("click", cancel);
                this._dialogClose = () => resolve(null);
            });
            const result = yield textPromise;
            this._dialogClose = null;
            dialogContainer.remove();
            this._container.classList.remove("dialog-shown");
            return result;
        });
    }
    scrollToPage(pageNumber) {
        if (!this._pageService.pages.length) {
            return;
        }
        const { top: cTop } = this._container.getBoundingClientRect();
        const { top: pTop } = this._pageService.getPage(pageNumber).viewContainer.getBoundingClientRect();
        const scroll = pTop - (cTop - this._container.scrollTop);
        this._container.scrollTo(this._container.scrollLeft, scroll);
    }
    init() {
        this._container.addEventListener("scroll", this.onScroll);
        this._container.addEventListener("wheel", this.onWheelZoom, { passive: false });
        this._container.addEventListener("pointermove", this.onPointerMove);
        this._container.addEventListener("pointerdown", this.onPointerDownScroll);
        this._container.addEventListener("touchstart", this.onTouchZoom);
        this._pageService.eventService.addListener(pagesLoadedEvent, this.onPagesLoaded);
        this._pageService.eventService.addListener(currentPageChangeRequestEvent, this.onScrollRequest);
    }
    renderVisible() {
        this._pageService.renderVisiblePages(this._container);
    }
    setScale(scale, cursorPosition = null) {
        if (!scale || scale === this._scale) {
            return;
        }
        let pageContainerUnderPivot;
        let xPageRatio;
        let yPageRatio;
        if (cursorPosition) {
            for (const page of this._pageService.pages) {
                const { x: x, y: y } = cursorPosition;
                const { x: pX, y: pY, width: pWidth, height: pHeight } = page.viewContainer.getBoundingClientRect();
                if (pX <= x
                    && pX + pWidth >= x
                    && pY <= y
                    && pY + pHeight >= y) {
                    pageContainerUnderPivot = page.viewContainer;
                    xPageRatio = (x - pX) / pWidth;
                    yPageRatio = (y - pY) / pHeight;
                    break;
                }
            }
        }
        this._scale = scale;
        this._pageService.scale = scale;
        if (pageContainerUnderPivot
            &&
                (this._container.scrollHeight > this._container.clientHeight
                    || this._container.scrollWidth > this._container.clientWidth)) {
            const { x: initialX, y: initialY } = cursorPosition;
            const { x: pX, y: pY, width: pWidth, height: pHeight } = pageContainerUnderPivot.getBoundingClientRect();
            const resultX = pX + (pWidth * xPageRatio);
            const resultY = pY + (pHeight * yPageRatio);
            let scrollLeft = this._container.scrollLeft + (resultX - initialX);
            let scrollTop = this._container.scrollTop + (resultY - initialY);
            scrollLeft = scrollLeft < 0
                ? 0
                : scrollLeft;
            scrollTop = scrollTop < 0
                ? 0
                : scrollTop;
            if (scrollTop !== this._container.scrollTop
                || scrollLeft !== this._container.scrollLeft) {
                this._container.scrollTo(scrollLeft, scrollTop);
                return;
            }
        }
        setTimeout(() => this.renderVisible(), 0);
    }
    zoom(diff, cursorPosition = null) {
        const scale = clamp(this._scale + diff, this._minScale, this._maxScale);
        this.setScale(scale, cursorPosition || this.getCenterPosition());
    }
    zoomOutCentered(center = null) {
        this.zoom(-0.25, center);
    }
    zoomInCentered(center = null) {
        this.zoom(0.25, center);
    }
    getCenterPosition() {
        const { x, y, width, height } = this._container.getBoundingClientRect();
        return new Vec2(x + width / 2, y + height / 2);
    }
}

class Previewer {
    constructor(pageService, container, options) {
        this._hidden = true;
        this.onPagesLoaded = (event) => {
            var _a;
            (_a = event.detail.pages) === null || _a === void 0 ? void 0 : _a.forEach(x => {
                x.previewContainer.addEventListener("click", this.onPreviewerPageClick);
                this._container.append(x.previewContainer);
            });
            this.renderVisible();
        };
        this.onCurrentPageChanged = (event) => {
            this.scrollToPreview(event.detail.newIndex);
        };
        this.onPreviewerPageClick = (e) => {
            let target = e.target;
            let pageNumber;
            while (target && !pageNumber) {
                const data = target.dataset["pageNumber"];
                if (data) {
                    pageNumber = +data;
                }
                else {
                    target = target.parentElement;
                }
            }
            if (pageNumber) {
                this._pageService.requestSetCurrentPageIndex(pageNumber - 1);
            }
        };
        this.onPreviewerScroll = (e) => {
            this.renderVisible();
        };
        if (!pageService) {
            throw new Error("Page service is not defined");
        }
        if (!container) {
            throw new Error("Container is not defined");
        }
        this._pageService = pageService;
        this._container = container;
        this._canvasWidth = (options === null || options === void 0 ? void 0 : options.canvasWidth) || 100;
        this.init();
    }
    get canvasWidth() {
        return this._canvasWidth;
    }
    get hidden() {
        return this._hidden;
    }
    destroy() {
        this._pageService.eventService.removeListener(pagesLoadedEvent, this.onPagesLoaded);
        this._pageService.eventService.removeListener(currentPageChangeEvent, this.onCurrentPageChanged);
    }
    show() {
        this._hidden = false;
        setTimeout(() => this.renderVisible(), 1000);
    }
    hide() {
        this._hidden = true;
    }
    renderVisible() {
        if (this._hidden) {
            return;
        }
        this._pageService.renderVisiblePreviews(this._container);
    }
    init() {
        this._container.addEventListener("scroll", this.onPreviewerScroll);
        this._pageService.eventService.addListener(pagesLoadedEvent, this.onPagesLoaded);
        this._pageService.eventService.addListener(currentPageChangeEvent, this.onCurrentPageChanged);
    }
    scrollToPreview(pageIndex) {
        if (!this._pageService.pages.length) {
            return;
        }
        const { top: cTop, height: cHeight } = this._container.getBoundingClientRect();
        const { top: pTop, height: pHeight } = this._pageService.getPage(pageIndex).previewContainer.getBoundingClientRect();
        const cCenter = cTop + cHeight / 2;
        const pCenter = pTop + pHeight / 2;
        const scroll = pCenter - cCenter + this._container.scrollTop;
        this._container.scrollTo(0, scroll);
    }
}

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PageTextView {
    constructor(pageProxy) {
        this.onPointerDown = (e) => {
            var _a;
            if (this._divModeTimer) {
                clearTimeout(this._divModeTimer);
                this._divModeTimer = null;
            }
            (_a = this._renderTask) === null || _a === void 0 ? void 0 : _a.expandTextDivs(true);
        };
        this.onPointerUp = (e) => {
            this._divModeTimer = setTimeout(() => {
                var _a;
                (_a = this._renderTask) === null || _a === void 0 ? void 0 : _a.expandTextDivs(false);
                this._divModeTimer = null;
            }, 300);
        };
        if (!pageProxy) {
            throw new Error("Page proxy is not defined");
        }
        this._pageProxy = pageProxy;
        this._container = document.createElement("div");
        this._container.classList.add("page-text");
        this._container.addEventListener("pointerdown", this.onPointerDown);
        this._container.addEventListener("pointerup", this.onPointerUp);
    }
    static appendPageTextAsync(pageProxy, parent, scale) {
        return __awaiter$3(this, void 0, void 0, function* () {
            const textObj = new PageTextView(pageProxy);
            yield textObj.renderTextLayerAsync(scale);
            parent.append(textObj._container);
            return textObj;
        });
    }
    destroy() {
        this.destroyRenderTask();
        if (this._container) {
            this._container.remove();
            this._container = null;
        }
    }
    renderTextLayerAsync(scale) {
        return __awaiter$3(this, void 0, void 0, function* () {
            this.clear();
            this.destroyRenderTask();
            const viewport = this._pageProxy.getViewport({ scale });
            const textContentStream = this._pageProxy.streamTextContent();
            this._renderTask = renderTextLayer({
                container: this._container,
                textContentStream,
                viewport,
                enhanceTextSelection: false,
            });
            try {
                yield this._renderTask.promise;
            }
            catch (error) {
                if (error.message === "TextLayer task cancelled.") {
                    return false;
                }
                else {
                    throw error;
                }
            }
            const spans = this._container.querySelectorAll("span");
            spans.forEach(x => {
                const blCornerSpan = document.createElement("span");
                blCornerSpan.classList.add("dummy-corner", "bl");
                const brCornerSpan = document.createElement("span");
                brCornerSpan.classList.add("dummy-corner", "br");
                const trCornerSpan = document.createElement("span");
                trCornerSpan.classList.add("dummy-corner", "tr");
                const tlCornerSpan = document.createElement("span");
                tlCornerSpan.classList.add("dummy-corner", "tl");
                x.append(blCornerSpan, brCornerSpan, trCornerSpan, tlCornerSpan);
            });
            return true;
        });
    }
    clear() {
        this._container.innerHTML = "";
    }
    destroyRenderTask() {
        if (this._renderTask) {
            this._renderTask.cancel();
            this._renderTask = null;
        }
    }
}

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PageAnnotationView {
    constructor(docService, pageId, pageDimensions) {
        this._rendered = new Set();
        this.onAnnotationSelectionChange = (e) => {
            var _a;
            if (e.detail.type === "select") {
                if ((_a = e.detail.annotations) === null || _a === void 0 ? void 0 : _a.length) {
                    this._container.style.touchAction = "none";
                }
                else {
                    this._container.style.touchAction = "";
                }
            }
        };
        if (!docService || isNaN(pageId) || !pageDimensions) {
            throw new Error("Required argument not found");
        }
        this._pageId = pageId;
        this._pageDimensions = pageDimensions;
        this._docService = docService;
        this._container = document.createElement("div");
        this._container.classList.add("page-annotations");
        this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this._svg.setAttribute("data-page-id", pageId + "");
        this._svg.setAttribute("viewBox", `0 0 ${pageDimensions.x} ${pageDimensions.y}`);
        this._svg.setAttribute("transform", "scale(1, -1)");
        this._container.append(this._svg);
        this._svg.addEventListener("pointerdown", (e) => {
            if (e.target === this._svg) {
                docService.setSelectedAnnotation(null);
            }
        });
    }
    destroy() {
        this.remove();
        this._container = null;
        this._destroyed = true;
        this._rendered.forEach(x => {
            x.$onPointerDownAction = null;
            x.$onPointerEnterAction = null;
            x.$onPointerLeaveAction = null;
        });
        this._rendered.clear();
    }
    remove() {
        var _a;
        (_a = this._container) === null || _a === void 0 ? void 0 : _a.remove();
        this._docService.eventService.removeListener(annotChangeEvent, this.onAnnotationSelectionChange);
    }
    appendAsync(parent) {
        return __awaiter$2(this, void 0, void 0, function* () {
            if (this._destroyed) {
                return;
            }
            yield this.renderAnnotationsAsync();
            parent.append(this._container);
            this._docService.eventService.addListener(annotChangeEvent, this.onAnnotationSelectionChange);
        });
    }
    renderAnnotationsAsync() {
        return __awaiter$2(this, void 0, void 0, function* () {
            this.clear();
            const annotations = this._docService.getPageAnnotations(this._pageId) || [];
            for (let i = 0; i < annotations.length || 0; i++) {
                const annotation = annotations[i];
                if (annotation.deleted) {
                    continue;
                }
                let renderResult;
                if (!this._rendered.has(annotation)) {
                    annotation.$onPointerDownAction = (e) => {
                        this._docService.eventService.dispatchEvent(new AnnotSelectionRequestEvent({ annotation }));
                    };
                    annotation.$onPointerEnterAction = (e) => {
                        this._docService.eventService.dispatchEvent(new AnnotFocusRequestEvent({ annotation }));
                    };
                    annotation.$onPointerLeaveAction = (e) => {
                        this._docService.eventService.dispatchEvent(new AnnotFocusRequestEvent({ annotation: null }));
                    };
                    renderResult = yield annotation.renderAsync();
                }
                else {
                    renderResult = annotation.lastRenderResult || (yield annotation.renderAsync());
                }
                if (!renderResult) {
                    continue;
                }
                this._rendered.add(annotation);
                this._svg.append(renderResult);
            }
            return true;
        });
    }
    clear() {
        this._svg.innerHTML = "";
    }
}

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PageView {
    constructor(docService, pageProxy, previewWidth) {
        if (!pageProxy) {
            throw new Error("Page proxy is not defined");
        }
        if (!docService) {
            throw new Error("Annotation data is not defined");
        }
        this._pageProxy = pageProxy;
        this._viewport = pageProxy.getViewport({ scale: 1 });
        this._docService = docService;
        this.number = pageProxy.pageNumber;
        this.id = pageProxy.ref["num"];
        this.generation = pageProxy.ref["gen"];
        const { width, height } = this._viewport;
        previewWidth = Math.max(previewWidth !== null && previewWidth !== void 0 ? previewWidth : 0, 50);
        const previewHeight = previewWidth * (height / width);
        this._dimensions = { width, height, previewWidth, previewHeight };
        this._previewContainer = document.createElement("div");
        this._previewContainer.classList.add("page-preview");
        this._previewContainer.setAttribute("data-page-number", this.number + "");
        this._previewContainer.setAttribute("data-page-id", this.id + "");
        this._previewContainer.setAttribute("data-page-gen", this.generation + "");
        this._previewContainer.style.width = this._dimensions.previewWidth + "px";
        this._previewContainer.style.height = this._dimensions.previewHeight + "px";
        this._viewContainer = document.createElement("div");
        this._viewContainer.classList.add("page");
        this._viewContainer.setAttribute("data-page-number", this.number + "");
        this._viewContainer.setAttribute("data-page-id", this.id + "");
        this._viewContainer.setAttribute("data-page-gen", this.generation + "");
        this.scale = 1;
    }
    get previewContainer() {
        return this._previewContainer;
    }
    get viewContainer() {
        return this._viewContainer;
    }
    set _viewRendered(value) {
        this.$viewRendered = value;
        this._viewContainer.setAttribute("data-loaded", value + "");
    }
    get _viewRendered() {
        return this.$viewRendered;
    }
    get scale() {
        return this._scale;
    }
    set scale(value) {
        if (value <= 0 || this._scale === value) {
            return;
        }
        this._scale = value;
        const dpr = window.devicePixelRatio;
        this._dimensions.scaledWidth = this._dimensions.width * this._scale;
        this._dimensions.scaledHeight = this._dimensions.height * this._scale;
        this._dimensions.scaledDprWidth = this._dimensions.scaledWidth * dpr;
        this._dimensions.scaledDprHeight = this._dimensions.scaledHeight * dpr;
        this._viewContainer.style.width = this._dimensions.scaledWidth + "px";
        this._viewContainer.style.height = this._dimensions.scaledHeight + "px";
        if (this._viewCanvas) {
            this._viewCanvas.style.width = this._dimensions.scaledWidth + "px";
            this._viewCanvas.style.height = this._dimensions.scaledHeight + "px";
        }
        this._scaleIsValid = false;
    }
    get viewValid() {
        return this._scaleIsValid && this._viewRendered;
    }
    destroy() {
        this._previewContainer.remove();
        this._viewContainer.remove();
        this._pageProxy.cleanup();
    }
    renderPreviewAsync(force = false) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this._renderPromise) {
                if (force) {
                    this.cancelRenderTask();
                }
                yield this._renderPromise;
            }
            if (!force && this._previewRendered) {
                return;
            }
            this._renderPromise = this.runPreviewRenderAsync();
            return this._renderPromise;
        });
    }
    renderViewAsync(force = false) {
        return __awaiter$1(this, void 0, void 0, function* () {
            if (this._renderPromise) {
                if (force) {
                    this.cancelRenderTask();
                }
                yield this._renderPromise;
            }
            if (!force && this.viewValid) {
                return;
            }
            this._renderPromise = this.runViewRenderAsync();
            return this._renderPromise;
        });
    }
    clearPreview() {
        this._previewContainer.innerHTML = "";
    }
    clearView() {
        var _a, _b, _c;
        (_a = this._annotations) === null || _a === void 0 ? void 0 : _a.destroy();
        this._annotations = null;
        (_b = this._text) === null || _b === void 0 ? void 0 : _b.destroy();
        this._text = null;
        (_c = this._viewCanvas) === null || _c === void 0 ? void 0 : _c.remove();
        this._viewRendered = false;
    }
    cancelRenderTask() {
        if (this._renderTask) {
            this._renderTask.cancel();
            this._renderTask = null;
        }
    }
    runRenderTaskAsync(renderParams) {
        return __awaiter$1(this, void 0, void 0, function* () {
            this.cancelRenderTask();
            this._renderTask = this._pageProxy.render(renderParams);
            try {
                yield this._renderTask.promise;
            }
            catch (error) {
                if (error instanceof RenderingCancelledException) {
                    return false;
                }
                else {
                    throw error;
                }
            }
            finally {
                this._renderTask = null;
            }
            return true;
        });
    }
    createPreviewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("page-canvas");
        const dpr = window.devicePixelRatio;
        const { previewWidth: width, previewHeight: height } = this._dimensions;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        return canvas;
    }
    createViewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("page-canvas");
        canvas.style.width = this._dimensions.scaledWidth + "px";
        canvas.style.height = this._dimensions.scaledHeight + "px";
        canvas.width = this._dimensions.scaledDprWidth;
        canvas.height = this._dimensions.scaledDprHeight;
        return canvas;
    }
    runPreviewRenderAsync() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const canvas = this.createPreviewCanvas();
            const params = {
                canvasContext: canvas.getContext("2d"),
                viewport: this._viewport.clone({ scale: canvas.width / this._dimensions.width }),
            };
            const result = yield this.runRenderTaskAsync(params);
            if (!result) {
                this._previewRendered = false;
                return;
            }
            this._previewContainer.innerHTML = "";
            this._previewContainer.append(canvas);
            this._previewRendered = true;
        });
    }
    runViewRenderAsync() {
        var _a, _b;
        return __awaiter$1(this, void 0, void 0, function* () {
            const scale = this._scale;
            (_a = this._text) === null || _a === void 0 ? void 0 : _a.destroy();
            this._text = null;
            const canvas = this.createViewCanvas();
            const params = {
                canvasContext: canvas.getContext("2d"),
                viewport: this._viewport.clone({ scale: scale * window.devicePixelRatio }),
                enableWebGL: true,
            };
            const result = yield this.runRenderTaskAsync(params);
            if (!result || scale !== this._scale) {
                return;
            }
            (_b = this._viewCanvas) === null || _b === void 0 ? void 0 : _b.remove();
            this._viewContainer.append(canvas);
            this._viewCanvas = canvas;
            this._viewRendered = true;
            this._text = yield PageTextView.appendPageTextAsync(this._pageProxy, this._viewContainer, scale);
            if (!this._annotations) {
                const { width: x, height: y } = this._dimensions;
                this._annotations = new PageAnnotationView(this._docService, this.id, new Vec2(x, y));
            }
            yield this._annotations.appendAsync(this.viewContainer);
            if (scale === this._scale) {
                this._scaleIsValid = true;
            }
        });
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class TsPdfViewer {
    constructor(options) {
        this._timers = {
            hidePanels: 0,
        };
        this.onTextSelectionChange = () => {
            const selection = this._shadowRoot.getSelection();
            if (!selection.rangeCount) {
                return;
            }
            if (this._eventService.hasListenersForKey(textSelectionChangeEvent)) {
                const selectionInfos = getSelectionInfosFromSelection(selection);
                this._eventService.dispatchEvent(new TextSelectionChangeEvent({ selectionInfos }));
            }
        };
        this.onFileInput = () => {
            const files = this._fileInput.files;
            if (files.length === 0) {
                return;
            }
            this.openPdfAsync(files[0]);
            this._fileInput.value = null;
        };
        this.onOpenFileButtonClick = () => {
            this._shadowRoot.getElementById("open-file-input").click();
        };
        this.onSaveFileButtonClick = () => {
            const blob = this.getCurrentPdf();
            if (!blob) {
                return;
            }
            TsPdfViewer.downloadFile(blob, `file_${new Date().toISOString()}.pdf`);
        };
        this.onCloseFileButtonClick = () => {
            this.closePdfAsync();
        };
        this.onTextModeButtonClick = () => {
            this.setViewerMode("text");
        };
        this.onHandModeButtonClick = () => {
            this.setViewerMode("hand");
        };
        this.onAnnotationModeButtonClick = () => {
            this.setViewerMode("annotation");
        };
        this.onZoomOutClick = () => {
            this._viewer.zoomOut();
        };
        this.onZoomInClick = () => {
            this._viewer.zoomIn();
        };
        this.onZoomFitViewerClick = () => {
            this._viewer.zoomFitViewer();
        };
        this.onZoomFitPageClick = () => {
            this._viewer.zoomFitPage();
        };
        this.onPaginatorInput = (event) => {
            if (event.target instanceof HTMLInputElement) {
                event.target.value = event.target.value.replace(/[^\d]+/g, "");
            }
        };
        this.onPaginatorChange = (event) => {
            if (event.target instanceof HTMLInputElement) {
                const pageNumber = Math.max(Math.min(+event.target.value, this._pdfDocument.numPages), 1);
                if (pageNumber + "" !== event.target.value) {
                    event.target.value = pageNumber + "";
                }
                this._pageService.requestSetCurrentPageIndex(pageNumber - 1);
            }
        };
        this.onPaginatorPrevClick = () => {
            const pageIndex = clamp(this._pageService.currentPageIndex - 1, 0, this._pageService.length - 1);
            this._pageService.requestSetCurrentPageIndex(pageIndex);
        };
        this.onPaginatorNextClick = () => {
            const pageIndex = clamp(this._pageService.currentPageIndex + 1, 0, this._pageService.length - 1);
            this._pageService.requestSetCurrentPageIndex(pageIndex);
        };
        this.onCurrentPagesChanged = (event) => {
            const { newIndex } = event.detail;
            this._shadowRoot.getElementById("paginator-input").value = newIndex + 1 + "";
        };
        this.annotatorUndo = () => {
            var _a;
            (_a = this._annotationService.annotator) === null || _a === void 0 ? void 0 : _a.undo();
        };
        this.annotatorClear = () => {
            var _a;
            (_a = this._annotationService.annotator) === null || _a === void 0 ? void 0 : _a.clear();
        };
        this.annotatorSave = () => {
            var _a;
            (_a = this._annotationService.annotator) === null || _a === void 0 ? void 0 : _a.saveAnnotation();
        };
        this.onAnnotationChange = (e) => {
            if (!e.detail) {
                return;
            }
            const annotations = e.detail.annotations;
            switch (e.detail.type) {
                case "focus":
                    if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                        this._mainContainer.classList.add("annotation-focused");
                    }
                    else {
                        this._mainContainer.classList.remove("annotation-focused");
                    }
                    const annotation = annotations[0];
                    if (annotation) {
                        this._shadowRoot.querySelector("#focused-annotation-author")
                            .textContent = annotation.author || "";
                        this._shadowRoot.querySelector("#focused-annotation-date")
                            .textContent = new Date(annotation.dateModified || annotation.dateCreated).toDateString();
                        this._shadowRoot.querySelector("#focused-annotation-text")
                            .textContent = annotation.textContent || "";
                    }
                    else {
                        this._shadowRoot.querySelector("#focused-annotation-author")
                            .textContent = "";
                        this._shadowRoot.querySelector("#focused-annotation-date")
                            .textContent = "";
                        this._shadowRoot.querySelector("#focused-annotation-text")
                            .textContent = "";
                    }
                    break;
                case "select":
                    if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                        this._mainContainer.classList.add("annotation-selected");
                    }
                    else {
                        this._mainContainer.classList.remove("annotation-selected");
                    }
                    break;
                case "add":
                case "edit":
                case "delete":
                    if (annotations === null || annotations === void 0 ? void 0 : annotations.length) {
                        const pageIdSet = new Set(annotations.map(x => x.pageId));
                        this._pageService.renderSpecifiedPages(pageIdSet);
                    }
                    break;
            }
            if (this._annotChangeCallback) {
                this._annotChangeCallback(e.detail);
            }
        };
        this.onAnnotatorDataChanged = (event) => {
            annotatorTypes.forEach(x => {
                this._mainContainer.classList.remove(x + "-annotator-data-saveable");
                this._mainContainer.classList.remove(x + "-annotator-data-undoable");
                this._mainContainer.classList.remove(x + "-annotator-data-clearable");
            });
            if (event.detail.saveable) {
                this._mainContainer.classList.add(event.detail.annotatorType + "-annotator-data-saveable");
            }
            if (event.detail.undoable) {
                this._mainContainer.classList.add(event.detail.annotatorType + "-annotator-data-undoable");
            }
            if (event.detail.clearable) {
                this._mainContainer.classList.add(event.detail.annotatorType + "-annotator-data-clearable");
            }
        };
        this.onAnnotationEditTextButtonClick = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const initialText = (_a = this._docService) === null || _a === void 0 ? void 0 : _a.getSelectedAnnotationTextContent();
            const text = yield this._viewer.showTextDialogAsync(initialText);
            if (text === null) {
                return;
            }
            (_b = this._docService) === null || _b === void 0 ? void 0 : _b.setSelectedAnnotationTextContent(text);
        });
        this.onAnnotationDeleteButtonClick = () => {
            var _a;
            (_a = this._docService) === null || _a === void 0 ? void 0 : _a.removeSelectedAnnotation();
        };
        this.onAnnotationSelectModeButtonClick = () => {
            this.setAnnotationMode("select");
        };
        this.onAnnotationStampModeButtonClick = () => {
            this.setAnnotationMode("stamp");
        };
        this.onAnnotationPenModeButtonClick = () => {
            this.setAnnotationMode("pen");
        };
        this.onAnnotationGeometricModeButtonClick = () => {
            this.setAnnotationMode("geometric");
        };
        this.onAnnotationTextModeButtonClick = () => {
            this.setAnnotationMode("text");
        };
        this.onPdfLoadingProgress = (progressData) => {
        };
        this.onPreviewerToggleClick = () => {
            if (this._previewer.hidden) {
                this._mainContainer.classList.remove("hide-previewer");
                this._shadowRoot.querySelector("div#toggle-previewer").classList.add("on");
                this._previewer.show();
            }
            else {
                this._mainContainer.classList.add("hide-previewer");
                this._shadowRoot.querySelector("div#toggle-previewer").classList.remove("on");
                this._previewer.hide();
            }
        };
        this.onMainContainerPointerMove = (event) => {
            const { clientX, clientY } = event;
            const { x: rectX, y: rectY, width, height } = this._mainContainer.getBoundingClientRect();
            const l = clientX - rectX;
            const t = clientY - rectY;
            const r = width - l;
            const b = height - t;
            if (Math.min(l, r, t, b) > 150) {
                if (!this._panelsHidden && !this._timers.hidePanels) {
                    this._timers.hidePanels = setTimeout(() => {
                        this._mainContainer.classList.add("hide-panels");
                        this._panelsHidden = true;
                        this._timers.hidePanels = null;
                    }, 5000);
                }
            }
            else {
                if (this._timers.hidePanels) {
                    clearTimeout(this._timers.hidePanels);
                    this._timers.hidePanels = null;
                }
                if (this._panelsHidden) {
                    this._mainContainer.classList.remove("hide-panels");
                    this._panelsHidden = false;
                }
            }
        };
        if (!options) {
            throw new Error("No options provided");
        }
        const container = document.querySelector(options.containerSelector);
        if (!container) {
            throw new Error("Container not found");
        }
        else if (!(container instanceof HTMLDivElement)) {
            throw new Error("Container is not a DIV element");
        }
        else {
            this._outerContainer = container;
        }
        if (!options.workerSource) {
            throw new Error("Worker source path not defined");
        }
        GlobalWorkerOptions.workerSrc = options.workerSource;
        this._userName = options.userName || "Guest";
        this._fileOpenAction = options.fileOpenAction;
        this._fileSaveAction = options.fileSaveAction;
        this._fileCloseAction = options.fileCloseAction;
        this._annotChangeCallback = options.annotChangeCallback;
        const visibleAdjPages = options.visibleAdjPages || 0;
        const previewWidth = options.previewWidth || 100;
        const minScale = options.minScale || 0.25;
        const maxScale = options.maxScale || 4;
        this._shadowRoot = this._outerContainer.attachShadow({ mode: "open" });
        this._shadowRoot.innerHTML = styles + html;
        this._mainContainer = this._shadowRoot.querySelector("div#main-container");
        this._eventService = new ElementEventService(this._mainContainer);
        this._pageService = new PageService(this._eventService, { visibleAdjPages: visibleAdjPages });
        this._previewer = new Previewer(this._pageService, this._shadowRoot.querySelector("#previewer"), { canvasWidth: previewWidth });
        this._viewer = new Viewer(this._pageService, this._shadowRoot.querySelector("#viewer"), { minScale: minScale, maxScale: maxScale });
        this.initMainContainerEventHandlers();
        this.initViewControls();
        this.initFileButtons(options.fileButtons || []);
        this.initModeSwitchButtons();
        this.initAnnotationButtons();
        this._eventService.addListener(annotChangeEvent, this.onAnnotationChange);
        this._eventService.addListener(currentPageChangeEvent, this.onCurrentPagesChanged);
        this._eventService.addListener(annotatorDataChangeEvent, this.onAnnotatorDataChanged);
        document.addEventListener("selectionchange", this.onTextSelectionChange);
    }
    static downloadFile(blob, name) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("download", name);
        link.href = url;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setTimeout(() => URL.revokeObjectURL(url), 10000);
    }
    destroy() {
        var _a, _b, _c, _d;
        this._annotChangeCallback = null;
        this._eventService.destroy();
        (_a = this._pdfLoadingTask) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this._annotationService) === null || _b === void 0 ? void 0 : _b.destroy();
        this._viewer.destroy();
        this._previewer.destroy();
        this._pageService.destroy();
        if (this._pdfDocument) {
            this._pdfDocument.cleanup();
            this._pdfDocument.destroy();
        }
        (_c = this._docService) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this._mainContainerRObserver) === null || _d === void 0 ? void 0 : _d.disconnect();
        this._shadowRoot.innerHTML = "";
        document.removeEventListener("selectionchange", this.onTextSelectionChange);
    }
    openPdfAsync(src) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.closePdfAsync();
            let data;
            let doc;
            try {
                if (src instanceof Uint8Array) {
                    data = src;
                }
                else {
                    let blob;
                    if (typeof src === "string") {
                        const res = yield fetch(src);
                        blob = yield res.blob();
                    }
                    else {
                        blob = src;
                    }
                    const buffer = yield blob.arrayBuffer();
                    data = new Uint8Array(buffer);
                }
            }
            catch (e) {
                throw new Error(`Cannot load file data: ${e.message}`);
            }
            const docService = new DocumentService(this._eventService, data, this._userName);
            let password;
            while (true) {
                const authenticated = docService.tryAuthenticate(password);
                if (!authenticated) {
                    password = yield this.showPasswordDialogAsync();
                    if (password === null) {
                        throw new Error("File loading cancelled: authentication aborted");
                    }
                    continue;
                }
                break;
            }
            try {
                if (this._pdfLoadingTask) {
                    yield this.closePdfAsync();
                    return this.openPdfAsync(data);
                }
                this._pdfLoadingTask = getDocument({
                    data: docService.getDataWithoutSupportedAnnotations(),
                    password,
                });
                this._pdfLoadingTask.onProgress = this.onPdfLoadingProgress;
                doc = yield this._pdfLoadingTask.promise;
                this._pdfLoadingTask = null;
            }
            catch (e) {
                throw new Error(`Cannot open PDF: ${e.message}`);
            }
            this._pdfDocument = doc;
            this._docService = docService;
            yield this.refreshPagesAsync();
            this._annotationService = new AnnotationService(this._docService, this._pageService, this._viewer);
            this.setAnnotationMode("select");
            this._mainContainer.classList.remove("disabled");
        });
    }
    closePdfAsync() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._pdfLoadingTask) {
                if (!this._pdfLoadingTask.destroyed) {
                    yield this._pdfLoadingTask.destroy();
                }
                this._pdfLoadingTask = null;
            }
            this._mainContainer.classList.add("disabled");
            this._mainContainer.classList.remove("annotation-focused");
            this._mainContainer.classList.remove("annotation-selected");
            this.setViewerMode();
            if (this._pdfDocument) {
                this._pdfDocument.destroy();
                this._pdfDocument = null;
                (_a = this._annotationService) === null || _a === void 0 ? void 0 : _a.destroy();
                (_b = this._docService) === null || _b === void 0 ? void 0 : _b.destroy();
                this._docService = null;
            }
            yield this.refreshPagesAsync();
        });
    }
    importAnnotations(dtos) {
        var _a;
        try {
            (_a = this._docService) === null || _a === void 0 ? void 0 : _a.appendSerializedAnnotations(dtos);
        }
        catch (e) {
            console.log(`Error while importing annotations: ${e.message}`);
        }
    }
    exportAnnotations() {
        var _a;
        const dtos = (_a = this._docService) === null || _a === void 0 ? void 0 : _a.serializeAnnotations(true);
        return dtos;
    }
    importAnnotationsFromJson(json) {
        var _a;
        try {
            const dtos = JSON.parse(json);
            (_a = this._docService) === null || _a === void 0 ? void 0 : _a.appendSerializedAnnotations(dtos);
        }
        catch (e) {
            console.log(`Error while importing annotations: ${e.message}`);
        }
    }
    exportAnnotationsToJson() {
        var _a;
        const dtos = (_a = this._docService) === null || _a === void 0 ? void 0 : _a.serializeAnnotations(true);
        return JSON.stringify(dtos);
    }
    getCurrentPdf() {
        var _a;
        const data = (_a = this._docService) === null || _a === void 0 ? void 0 : _a.getDataWithUpdatedAnnotations();
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            return null;
        }
        const blob = new Blob([data], {
            type: "application/pdf",
        });
        return blob;
    }
    initMainContainerEventHandlers() {
        const mcResizeObserver = new ResizeObserver((entries) => {
            const { width } = this._mainContainer.getBoundingClientRect();
            if (width < 721) {
                this._mainContainer.classList.add("mobile");
            }
            else {
                this._mainContainer.classList.remove("mobile");
            }
        });
        mcResizeObserver.observe(this._mainContainer);
        this._mainContainerRObserver = mcResizeObserver;
        this._mainContainer.addEventListener("pointermove", this.onMainContainerPointerMove);
    }
    initViewControls() {
        const paginatorInput = this._shadowRoot.getElementById("paginator-input");
        paginatorInput.addEventListener("input", this.onPaginatorInput);
        paginatorInput.addEventListener("change", this.onPaginatorChange);
        this._shadowRoot.querySelector("#paginator-prev")
            .addEventListener("click", this.onPaginatorPrevClick);
        this._shadowRoot.querySelector("#paginator-next")
            .addEventListener("click", this.onPaginatorNextClick);
        this._shadowRoot.querySelector("#zoom-out")
            .addEventListener("click", this.onZoomOutClick);
        this._shadowRoot.querySelector("#zoom-in")
            .addEventListener("click", this.onZoomInClick);
        this._shadowRoot.querySelector("#zoom-fit-viewer")
            .addEventListener("click", this.onZoomFitViewerClick);
        this._shadowRoot.querySelector("#zoom-fit-page")
            .addEventListener("click", this.onZoomFitPageClick);
        this._shadowRoot.querySelector("#toggle-previewer")
            .addEventListener("click", this.onPreviewerToggleClick);
    }
    initFileButtons(fileButtons) {
        const openButton = this._shadowRoot.querySelector("#button-open-file");
        const saveButton = this._shadowRoot.querySelector("#button-save-file");
        const closeButton = this._shadowRoot.querySelector("#button-close-file");
        if (fileButtons.includes("open")) {
            this._fileInput = this._shadowRoot.getElementById("open-file-input");
            this._fileInput.addEventListener("change", this.onFileInput);
            openButton.addEventListener("click", this._fileOpenAction || this.onOpenFileButtonClick);
        }
        else {
            openButton.remove();
        }
        if (fileButtons.includes("save")) {
            saveButton.addEventListener("click", this._fileSaveAction || this.onSaveFileButtonClick);
        }
        else {
            saveButton.remove();
        }
        if (fileButtons.includes("close")) {
            closeButton.addEventListener("click", this._fileCloseAction || this.onCloseFileButtonClick);
        }
        else {
            closeButton.remove();
        }
    }
    initModeSwitchButtons() {
        this._shadowRoot.querySelector("#button-mode-text")
            .addEventListener("click", this.onTextModeButtonClick);
        this._shadowRoot.querySelector("#button-mode-hand")
            .addEventListener("click", this.onHandModeButtonClick);
        this._shadowRoot.querySelector("#button-mode-annotation")
            .addEventListener("click", this.onAnnotationModeButtonClick);
        this.setViewerMode();
    }
    initAnnotationButtons() {
        this._shadowRoot.querySelector("#button-annotation-mode-select")
            .addEventListener("click", this.onAnnotationSelectModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-stamp")
            .addEventListener("click", this.onAnnotationStampModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-pen")
            .addEventListener("click", this.onAnnotationPenModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-geometric")
            .addEventListener("click", this.onAnnotationGeometricModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-text")
            .addEventListener("click", this.onAnnotationTextModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-edit-text")
            .addEventListener("click", this.onAnnotationEditTextButtonClick);
        this._shadowRoot.querySelector("#button-annotation-delete")
            .addEventListener("click", this.onAnnotationDeleteButtonClick);
        this._shadowRoot.querySelector("#button-annotation-stamp-undo")
            .addEventListener("click", this.annotatorUndo);
        this._shadowRoot.querySelector("#button-annotation-stamp-clear")
            .addEventListener("click", this.annotatorClear);
        this._shadowRoot.querySelector("#button-annotation-pen-undo")
            .addEventListener("click", this.annotatorUndo);
        this._shadowRoot.querySelector("#button-annotation-pen-clear")
            .addEventListener("click", this.annotatorClear);
        this._shadowRoot.querySelector("#button-annotation-pen-save")
            .addEventListener("click", this.annotatorSave);
        this._shadowRoot.querySelector("#button-annotation-geometric-undo")
            .addEventListener("click", this.annotatorUndo);
        this._shadowRoot.querySelector("#button-annotation-geometric-clear")
            .addEventListener("click", this.annotatorClear);
        this._shadowRoot.querySelector("#button-annotation-geometric-save")
            .addEventListener("click", this.annotatorSave);
        this._shadowRoot.querySelector("#button-annotation-text-undo")
            .addEventListener("click", this.annotatorUndo);
        this._shadowRoot.querySelector("#button-annotation-text-clear")
            .addEventListener("click", this.annotatorClear);
        this._shadowRoot.querySelector("#button-annotation-text-save")
            .addEventListener("click", this.annotatorSave);
    }
    setViewerMode(mode) {
        mode = mode || "text";
        viewerModes.forEach(x => {
            this._mainContainer.classList.remove("mode-" + x);
            this._shadowRoot.querySelector("#button-mode-" + x).classList.remove("on");
        });
        this.setAnnotationMode("select");
        this._mainContainer.classList.add("mode-" + mode);
        this._shadowRoot.querySelector("#button-mode-" + mode).classList.add("on");
        this._viewer.mode = mode;
    }
    setAnnotationMode(mode) {
        var _a, _b;
        if (!this._annotationService || !mode) {
            return;
        }
        const prevMode = this._annotationService.mode;
        (_a = this._shadowRoot.querySelector(`#button-annotation-mode-${prevMode}`)) === null || _a === void 0 ? void 0 : _a.classList.remove("on");
        (_b = this._shadowRoot.querySelector(`#button-annotation-mode-${mode}`)) === null || _b === void 0 ? void 0 : _b.classList.add("on");
        this._annotationService.mode = mode;
    }
    refreshPagesAsync() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const docPagesNumber = ((_a = this._pdfDocument) === null || _a === void 0 ? void 0 : _a.numPages) || 0;
            this._shadowRoot.getElementById("paginator-total").innerHTML = docPagesNumber + "";
            const pages = [];
            if (docPagesNumber) {
                for (let i = 0; i < docPagesNumber; i++) {
                    const pageProxy = yield this._pdfDocument.getPage(i + 1);
                    const page = new PageView(this._docService, pageProxy, this._previewer.canvasWidth);
                    pages.push(page);
                }
            }
            this._pageService.pages = pages;
        });
    }
    showPasswordDialogAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            const passwordPromise = new Promise((resolve, reject) => {
                const dialogContainer = document.createElement("div");
                dialogContainer.id = "password-dialog";
                dialogContainer.classList.add("full-size-dialog");
                dialogContainer.innerHTML = passwordDialogHtml;
                this._mainContainer.append(dialogContainer);
                let value = "";
                const input = this._shadowRoot.getElementById("password-input");
                input.placeholder = "Enter password...";
                input.addEventListener("change", () => value = input.value);
                const ok = () => {
                    dialogContainer.remove();
                    resolve(value);
                };
                const cancel = () => {
                    dialogContainer.remove();
                    resolve(null);
                };
                dialogContainer.addEventListener("click", (e) => {
                    if (e.target === dialogContainer) {
                        cancel();
                    }
                });
                this._shadowRoot.getElementById("password-ok").addEventListener("click", ok);
                this._shadowRoot.getElementById("password-cancel").addEventListener("click", cancel);
            });
            return passwordPromise;
        });
    }
}

export { AnnotEvent, TsPdfViewer };
