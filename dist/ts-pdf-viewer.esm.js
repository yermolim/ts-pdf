/**
 * Copyright 2021 yermolim
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 * FlateStream class is based on the corresponding one from PDF.js,
 * so the code of that class is also subject to the next license notice:
 * 
 * Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Copyright 1996-2003 Glyph & Cog, LLC
 * 
 * The flate stream implementation contained in this file is a JavaScript port
 * of XPDF's implementation, made available under the Apache 2.0 open source
 * license.
 */

import { renderTextLayer, RenderingCancelledException, GlobalWorkerOptions, getDocument } from 'pdfjs-dist';
import { v4 } from 'uuid';
import Crypto from 'crypto-es';
import Pako from 'pako';

var img = "data:image/png;base64,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";

var img$1 = "data:image/png;base64,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";

var img$2 = "data:image/png;base64,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";

var img$3 = "data:image/png;base64,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";

var img$4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR42u2bMW/EIAyFA7qla5Ol///HdUm6dguFKlQuBwnh7ADKs5TlTsrxPp6NAZ16H0czCMTXsijO90mNUw83DwC4OwAV5hZ37rYWoV6kAAAAAAAAAAAAAAAAAAAAAADcMh6CO63F7iwnkR2cUmqe57YcEIq3zyg4cWaapnYARM7rRjtLYupXY9ggaAHxzqKDtSgbAXdIkwBqqgK4QryP8J3OBe6xLjBVAFwpnjoh9rmDUJoOuhfxqXTwTiitCbon8WE6ROrCaQi6N/GxdFjX9XtzwWkIukS8/cHPmuKfnKD1W6kTdMnM2x/8qC0+VhNIPciGoEts7+nb75ro53cm4nCJ3L0ZkrqRvWSXRwokBZR9M9SzeJoOR82SziHYe5C6kA/A2cZB8E/PsXfh+zgqLt4+DgIl2cotsivEdizJlD0aZ84ymOy/G5nd5FhyJukQwHby8td60jW3hULpxP8Wu605O+vQrEaIQqDtZ20nePG+OStJz+xW+MkJpP2s4QQqvmTmizZDUSdsg7jSCVzii7bDHkK4PF5VEzjFFx+IOAip/lsSArf4YgCxZkl6iZQQ/zKAVJ/AnQ5S4lkA0Jog3Msv3OK5HBBdHZjj300TZxvOdjcoCYHrjlHMAT0HAAAAAAAAAAAAAAAAAAAAANwzFP47jBQAgFvHDyRnPtj60cBDAAAAAElFTkSuQmCC";

var img$5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZG9S8NQFMVPW8Wi1Q46SHHIUMWhhaIgjlLBLtWhrWDVJXlN2kKShpcUKa6Ci0PBQXTxa/A/0FVwVRAERRBx8R/wa5ES72sKLdLe8PJ+nHfP5eUE8Kd1Zth9CcAwHZ5JJaW1/Lo08A4fRhBEHBGZ2dZydimHnvXzSN1UD3Exq3df1xoqqDYDfEHiOWZxh3iBOL3lWIL3iMdYSS4QnxDHOF2Q+Fboisdvgosefwnmucwi4BczpWIHKx3MStwgniaOGnqVte4jviSkmqtZ2iO0JmAjgxSSkKCgijJ0OJRLGSZl1t2XaPpWUCEPo7eFGjg5iiiRN0ZqlaaqtGukq/ToqInc/+dpa7Mz3vRQEuh/dd3PSWBgH2jUXff31HUbZ0DgBbg22/4K5TT/TXq9rUWPgfAOcHnT1pQD4GoXGH+2ZC43pQAtv6YBHxfAcB4YvQcGN7ysWuc4fwJy2/SL7oDDI2CK+sObf/JNaAQfxWcoAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB30lEQVR42u2bzXKDIBCAw+ql6cnqpQ/Q93+f9gF60aan9GKwmkqHsXZA5Wd3YWcyySFO+D4WCLKKU+R4qush5u/DKfHIAlIXIFIDXs45eQhkAYlHiaUhTdMMcvgZniDcTE397Xb9vFweKQgoFfwU+ue1kFJ+AcDDf6J+RQKcqWRAv+cikyhqc4Ax71WPT73Pbg746Lpd/0uO7iVIrwIuNlJkBIyrhJddJBkBbdt62UIDp7Qf5xExL5PvLAXYwM+rxDM7AbbwLIeAL3gSAnzCoxfgGx61gBDwaAWEgkcpICQ8OgGh4VEJiAGPRkAseBQCPMF3JAQo+LV7e3vh9esGKd9M3xeppT2Kk6GYY/5PBiwb47sBmOCDZwA2eCsBVVW9Tg0fX63TsadNfLHgrQQIgBebHtza8+pQIyb81iFQc0n7YHMAdnivAijAexNABd6LAErwzgVQg3cqgCK8MwFU4Z0IoAx/WAB1+EMCOMBvEqAfOXOB3yRAHTlzgne6DOrwy3IW9gKWPa+Xs7AXQDHt9ThcJ7h2p8eiglPMdYF85oCpfvf+ble+OpDMAFNx8o7f7tELGHv2WhbF2SQGisJYv7soh+9JZICp3p565EdmsoDEQ8R+dpfSwUgeAlkAw/gGgdL3j4c6UpkAAAAASUVORK5CYII=";

var img$6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcmlDQ1BpY2MAACiRdZE9S8NQFIbftkpFWwrqIOKQoYpCC0VBHKWCXapDW8GqS3KbtEKShpsUKa6Ci0PBQXTxa/Af6Cq4KgiCIoi4+Af8WqTEc5tCi7Qn3JyH9573cO+5gD+tM8PuSQCG6fBMKimt5tek4Dt8GEQYQ5iSmW0tZRdz6Bo/j1RN8RAXvbrXdYyBgmozwNdHPMss7hDPE6e3HEvwHvEwK8kF4hPiGKcDEt8KXfH4TXDR4y/BPJdZAPyip1RsY6WNWYkbxJPEUUOvsOZ5xE1CqrmSpTxKaww2MkghCQkKKtiEDgdxyibNrLMv0fAto0weRn8LVXByFFEib4zUCnVVKWukq/TpqIq5/5+nrc1Me91DSaD31XU/x4HgPlCvue7vqevWz4DAC3BttvxlmtPcN+m1lhY9BiI7wOVNS1MOgKtdYOTZkrnckAK0/JoGfFwA4TwwdA/0r3uzau7j/AnIbdMT3QGHR8AE1Uc2/gDt82gCvNGYhAAAAAlwSFlzAAALEwAACxMBAJqcGAAAAcpJREFUeNrtWwFuwyAMjBEPWNf8/4XpugesoWMKUppBYidQ5cAnVZWaRtGdDxscoC6Bvu9d7PfRue6sMETJa8MwRC8Slzi6ACkhiEu8FgGWQpiucdBW9FNj5wiWzyvxjOk5/muVm30n8Xfjl8NfkNeEMLHo10Cem/CbyAHeCZMb/sGePfqTfXfh5/Hovu/3F25Lx9ujiURad6WIld1xHDtjTLLshXv8f7Zgka2dY04ClQNCxDmR5eL0Dvi63Vavf16vh1xjzzy13YKUPPQQWFaDHOShBJjX8VzkIRdDa+RDvvBlskoBOOSlVcLURr7KIVCKPIQAJclDJsGc5FkzwdBUqJE8pANykocTIDd59mKI2zIv0Q8oSR7GAaXIQwhQkjx0GVQBGI5xjEWRrTGqkmGjQ0AFUAFUABVABVAB2sXmRMi3pEbnSDLJyNm3h3MAEvnsAqCRZw0Bb/l5Q2THjg1qaghoFVABVAAVQAVQAVQAFUCCI9thxYSJXj5WcspCHaACNNgP+LhcTr+gySqAX/nNX2nP99ujI/aaX3NAbAPDkQ0RSNFfPTUWbkA/QLUVTNoT9RpOj+rJ0aUDJE5AdkDy8LRECEQBUrnsCeUexwK5uUFRAAAAAElFTkSuQmCC";

var img$7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/N4piFBEtRCxSRLFQCApiKRFMoxYxgq8mu24SIRuX3Q0itoKNRcBCtPFV+A+0FWwVBEERRGz8A74akfVOVohIMsvs/Tgz5zJzBrTJvGG59TGwCp6TTMQjc/MLkcYXQmiE6aQ9bbj21MxEiprj8446VW8HVa/a+6qO8LLpGlDXJDxi2I4nPCY8uebZireFO41celn4UHjAkQMKXyldD/hZcTbgd8VOKjkOmuoZyf5h/Q8bOccS7heOWvmi8XsedZMWszA7I7VbZg8uSRLEiaBTZIU8HoNSC5JZdV+s7JtmVTyG/G3WccSRJSfeAVGL0tWUmhHdlC/Pusr9f55uZngo6N4Sh4Yn33/rhcYd+C75/teR738fQ+gRLgoV/6rkNPoheqmiRQ+gbRPOLiuavgvnW9D1YKeddFkKydQyGXg9hdZ56LiB5sUgq991Tu4htSFPdA17+9An+9uWfgCZXmfbLPy9EwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAtBJREFUeNrlWwtuwjAMra2cALj/CWFHWLYiQKGLEzu282GRqiFo3bznT23PhY1Yl8vl/vd6vW6VFTf5AitZp/P5JQsByPMoHEABr12oAE/d21IWG0+gTuywYrLx2OumR8sOSnmg3LwaONcFiqZT0j4jBngAhoZYVDX/HLbQCfgRWJT6MkVGycefn0tEQO5HS7YJWWwCanI5+y8REKxUu99UEEhzsQO0hFOKK5GFrdrfhT2PQU+RJiVVCdA8WkYA0O4DPTdrHUg5AKUk4AhNzURy0DIqDH4uJB/3sH+mAt+fVPg7Ri+Nx5bonpFtIscrFeZkfFGxeSs5pLLQGfww2Vy3xIXAu9wDO2xMY7bgTQJODF5EQi4Q59zg+B1ODt7FElIS4HQ+v/34dbv1Ah8NrqleW+t14OSad7cEXAi8Cwm4GHgVCRbl8Azgm0igiqagBf/rR+BZCVaKGaor/ZY2l/aEC2reNCaE9LGXtrgy1diM4KuW8Lt/YPcDMqayAniVO+CiZm/mDvhB4JtIwA8DLyYBt3++Qmsw6bUa8wq2FeOoRoTjErkw9io6ZgR/dwGLVHMl8Mf+BzIaCCtYQvOTC5m9tJlJUD22JdVg1h0etQKsCP7lAtyO6mSWYJKwoaQWn4gEs2wVGxOOkSSYpuqaVHgECeZ1ingqy3BTUXl+E/gU3z4aYFEM9bAEc/B38wdonxLrSIJreW5ZDnuQYAaecm3UChjQNDG7B/m/QcoNJiDBXDZ22CiMluM6K1wQDoqgaqb12mMdS/6hcINlFqZDz9z3hVYnIcUVtg9dZmNyveZ+e4En3xpLL+aAfp43G0Fdp8UVsSCOKKWzEyKcbtAKbpAL4hwMotfmDF6vE78252mJr1RYo+G9KfpojHIOiYuwjlalNI3LCwYopFle1ChAky2GI7iOSc4xz+/SVK0+BrlEPH6HwgyR1MebSOBOqVHf/wB4polu0KoYHQAAAABJRU5ErkJggg==";

var img$8 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABcWlDQ1BpY2MAACiRdZE9S8NQFIbfpkpFqx3qIMUhQxWHFoqCOEoFu1SHtoJVl+Q2aYQkDUmKFFfBxaHgILr4NfgPdBVcFQRBEURc/AN+LVLiuU2hRdoTbs7De897uPdcQMjqzHD6UoBhunYukxZXi2ti6B0BxDACAVGJOdZSfrGAnvHzSNUUD0neq3dd1xgqKQ4DAgPEs8yyXeJ54uyWa3HeIx5lmlQiPiFO2HRA4luuyz6/cS77/MXZLuQWAIH3FMsdLHcw02yDeIo4buhV1joPv0lYMVfylGO0xuEghwzSECGjik3ocJGkbNLMuvtSTd8yKuRh9LdQg02OMjTyJkitUleFskq6Qp+OGp/7/3k66sy03z2cBvpfPe9zAgjtA4265/2eel7jDAi+ANdm21+hOc19k15va/FjILIDXN60NfkAuNoFxp4tyZaaUpCWoKrAxwUwXASi98Dguj+r1j7On4DCNj3RHXB4BExSfWTjD603Z+Sp2ztrAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGklEQVR42uVbC47jIAytESeY6f1P2NkjLCOqInmoP5g4BChSpLZJAT8/G9sQuDHtfr+Tv/9P6WZp/35+tP6lDsEyXgBg7z0eD3qAVsE9AWgU/s8cOQG+vr+bAOCAiK2Cn9CS4TnwGrTIWYAItw9voGmfo56DJlI1DnD38jx75qGxOvcZRwuuCV++V888zaCmLyUkvlc+S0BE6uZBtBMDKHjYbvnMzVG6Rz0bvbSaByWo+0frR0GQWCSZicSE0Kv93Fm5mAl10V/4PSkrSGpRkgrAUXoatWbq8yVA8ujfFQBOg56UbxXQCoIXACytvUHwBjkepffL+Q0PYGqQseaxw5WWyScDcmyPr6uEYOzdnT3YcTcxwMsBtsTlXv1aVoJwpv0bNH16tDl8FThTmwygXeYSBtn61YAmLn6YlgFW0Bg/UgueatMYWQ+AWRiFQZjSBOql6kwneWlF6MyaA8E+6EqHtUleEQUeMD2ofcJH1QRPS4cno7tp/NjoMGbSIljpL4EfPo3ybwzAOzd5aRC0DSOTllEgBEPykBSAlmzBkjkhILyWJLb2Vy7qP54heW89oGu/rgiEKskiRdGETyurBUr7L08L0sA9FdhpTYBaZopmpMKjBwjO+5KiuVD9xVYPSuzXTRdAtdQRc90TnyMIBxBetuHib+jQxjYgPNnQ68m3igOsjm0nEALl4Q2BzvIgRC3Qwaewciu5A9pzr4sM65nAQRYszYioxPzqQUXsDzJbOMZMDwAX6GQB6vM522WDStKzdYt1HlCzQNrBXZEROAxuDYS2YUGtrAwGmw1+SmsNhdMm2n87Wxha1/PdvH/xa8GQg69eEL3ufMBszg+zPBjD2jRwgmfavv7CxC7rvqbcgA89E4cKYQNfkCTlDt0XmGDZezNt1QmuGBgJwvNvjeE/t5Siy3ncq/f9LcJTrA1Wp7GAQ2SFJ0+ItGx5C0XQNJPmhYIuiG+Otm5P9QzQypwjpmSlPR4TNDoTr6iRA40+ak/l95QD1+RaemdIE96UDqMDCUuBYBW+lhM0O1VC4nQl/SkW1MJrcvwCJhH28gf87HUAAAAASUVORK5CYII=";

var img$9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIU/N4piFBEtRCxSRLFQCApiKRFMoxYxgq8mu24SIRuX3Q0itoKNRcBCtPFV+A+0FWwVBEERRGz8A74akfVOVohIMsvs/Tgz5zJzBrTJvGG59TGwCp6TTMQjc/MLkcYXQmiE6aQ9bbj21MxEiprj8446VW8HVa/a+6qO8LLpGlDXJDxi2I4nPCY8uebZireFO41celn4UHjAkQMKXyldD/hZcTbgd8VOKjkOmuoZyf5h/Q8bOccS7heOWvmi8XsedZMWszA7I7VbZg8uSRLEiaBTZIU8HoNSC5JZdV+s7JtmVTyG/G3WccSRJSfeAVGL0tWUmhHdlC/Pusr9f55uZngo6N4Sh4Yn33/rhcYd+C75/teR738fQ+gRLgoV/6rkNPoheqmiRQ+gbRPOLiuavgvnW9D1YKeddFkKydQyGXg9hdZ56LiB5sUgq991Tu4htSFPdA17+9An+9uWfgCZXmfbLPy9EwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAhxJREFUeNrtW1lywyAMtRhO0OT+J3SaHqCxanfijsuAEQaEWDTjn2CM3kMbS2ByyP1+R9vvC+IkVRSAs22eZ2sjUIHXToCLCKACb4UAkwg1dS7gm32X78TIOp45RhZw73FOsWlO4NzyJhbOiFC22W8BPDXgdxEDNktwuZmWPvtmvAiR79dr+no+/2EzLV7nVCBFgLOl3WVZJqWUM+3tfbZ3fKJrNu0UNYmOncFYCwktdDbQlJlNRkBp+Xw8Tts/brcoq4H1A2gMSAmCUuthr+4m3iu2hIINJli37tcCKoeZSXaB4CDoiPLkgWxZ5Opi6Czg7cHSfMcXRKtxAQp4LhdoBnwVBOQEX3UWSAF+FEKbBWxMBrLZVCG0d/p9THZ87wt9KBbw94ClU9MuYOquMw7UbCnc/VpgEDAIaEhitsQ4MgFItQCuNIjDBYQSwFUHgOQYAD1bwEiDzRBw3HEJPWWpUUyMuhfgLhJ0dyZvHKnrkKtlIwgOAgYB7RNAvTJbo9iwjauyLmZauyzpwqh9HWonwufScMX3z66nHc7pkxK3fhcpVSu1rslyXf54xLYrnBK8OUbS/YCdkZRZYFM81hJSEmlzaedd4VRExJCQEjz5P0MJBH3xhvk7/jQokATk0jdnirsKAjl1zZ3jQ8Egt54cRQ4VFJbQkavK84HDUvpxlrkoUTfuOh+l6VVioYOSdCq50kNBuhQloegO1A9Y7hjyBIja5wAAAABJRU5ErkJggg==";

var img$a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABbmlDQ1BpY2MAACiRdZG9S0JRGMZ/amGY4VBDRIODhYRCFERjGORiDWqQ1aLXr8CPy71KSGvQ0iA0RC19Df0HtQatBUFQBBEt/QN9LSG392RghJ7Lue+P55zn5ZzngD1S0Ipm1zgUSxUjGg55lxLLXucLDly4GcOf1Ex9PjYXp+P4vMOm6m1Q9eq8r+3oTWdMDWw9wlOablSEZ4Qj6xVd8bbwgJZPpoUPhQOGHFD4SumpJj8rzjX5XbERj86CXfX05v5w6g9reaMo7Bf2FQtV7fc86ibuTGkxJnVI5jAmUcKE8JKiyhoFKgSlliSz9r7xH98CZfFo8tepYYgjR168AVGr0jUjNSt6Rr4CNZX7/zzN7OREs7s7BN1PlvU2As4daNQt6+vIshrH4HiEi1LLX5acpj9Er7c03wF4NuHssqWlduF8CwYf9KSR/JEcMu3ZLLyeQl8C+m/AtdLM6nedk3uIb8gTXcPePozKfs/qNw5zaBHJcPVKAAAACXBIWXMAAAsTAAALEwEAmpwYAAADIUlEQVR42u1bPY7UMBS2PZYQotmdTMMhqFhKGsR23IN6F1pEg7bj5xZUnICSluEAXIBmnEkFQsomPId45bGcxEnsTJ4nT7I0cX7s73u/diaUNMhms7H2F2VJ+kgqhK3b9hBqu3CdJM5jMUobz+12O2s/dwWOXRQukwgeO/AuIhg5caFd2m/ynZHiHAN8aLsNG58Y+KSiMLQRwWwnYwDvaiEnEQOkQp3T4Ny0PyY75be3JNvvD7CZz+MhJ+CDUFvhVRQFYYw1Fj7qHnlNl3DMpt23KrUGQUyAlcZdNOsqR7EAWd/rawTz2GEtMWitYLMa7sOMhpIwh2egcQEzGPsAj4oAPZv4Ao9yMdQGXsULmSajJMAFfN8swWIDH6ULhAKPgoCQ4FEGQZ/gnSrBOe4N+AKP0gJ8gkdHgG/wzouhMXsCvlwoBHg0FhAKPAoCQoJHnQYXAhwspnRYFPEYtdrHbRYXWAhYCFgIWAhYCDhhGV0H5Hn+iDF2Qyh9UedgGmqy6yT5/xanLL+lafpMDu/DAkqjmYNWr5NUU+/aVaOUfqnBi4NJhgIvhdKnSZK8HPioA7zjXYCxz/WvxDpZ3+DvOKBfZxED9kK8BZN87zJpX+DlsGB9PychQNbV8rW0anJzRG/VNWn6OgQJlvv3MIfHMKf17LKAbxJs9wH456D5H7NNgxUJhHwYS0KD5i98gw9SB4B5vhpDgpbq/mqavwTwWzSFUE0C6UuCOl8UxR8I8/e0gBcEfNBKUBZEBSEfXUnQ+6Gwul9r/sJnwAtSCXZsmV/nUDwBy1e1Zn8BuIct12fQztTvkJqfbC2QCXGtLKEDPKnBZ7Xmz6NZDOkk2ERahpHqtmQimWw1KEkAJ/9kr6Yry8hgFfUkNHi9qKua2RFSoGy+aiIBRr4UQnyPfj9AkmA3kOnBH21DRKZIsIR34Pu/pwx4gwg4O/c/N5k6V5S+4avVAzjcHvODLdtncyUEortgoP/fHrtIbLNwgTkJ07XdxlSM2pfYedcNNoKwAzfSb3+tH+sv9q6FjosoxS5fjg7xf8wWYLo0HeI7GAloimX/ANBjieJDfrkhAAAAAElFTkSuQmCC";

var img$b = "data:image/png;base64,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";

var img$c = "data:image/png;base64,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";

var img$d = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAA0dJREFUeNrlWwmO5CAMjBEv2On/v7BnnjDeZhUkixgfQELIIkXqzgG4XD64YKuU1+vF3v9F3Dzl5/vbVX9PewGg+uz9frP3wduxskMVAdHSlgeImgB/vr5MANTqid6OGAoK92GbXLKcGYgwuH7sfH55iZr2a9TrBAmkdjxsrPkYrZ70LLUZBwpes3vUQCjbSv+5zpf05YSkz/JvCYjAPRykdZCcX6vtWjTrqTOeZPtgZMIQQDTFSUwIrdpPlY2IHFqnRxauzrDNKzhKwz2hPFxA/22UL7AI6AVhJgOGULrXVOJoRK8UvhY2c4zXwuQ/BqTcnl53FHB09KCgTDeBGsPOYl5pNuHJmr7ECVobKqnXo+GRoIWRdmUNU/m9VhBGmkeYaecjtcy9Lw2oLgWgFq8/93BPpNjrrDR5ehRwJDBIQDqFlXGG8C3ffDqMwrfQCkLs7fBVmaLSD2wF4w5jAahcbpB306qaDAfi5SZAhfl0SJoqB6pdmt9bTWYTpt1cANxlQLSDAJY5hV1g1TSWHg5z5qL4iQNgkU4rJ9oI2gZrsjEJiEx70VSSj/i8BwcG5I8lBBWAblO0PlJHGYzCl0B0aarQWjVR2jUJLSGucKTDw2BTZrYLBVR4ia4EHI+tm/xEdpKB0z7pJAidw22tYosCOcxkzaT/QrzGM+21IW3WzAVcY4Fi4hFmaN0DAuMzDiXtJ6D7CMIIGq1W6ORvaNDGY0BIV2ik5CNAYBlgsfMngRA4D+9IdJYHIQqJDmSvSUseO5Clp+Fr/5ebQCcLlmZEVHJ+0NYLqT9IbKkx5vYA1BKdJMCoFZ0losCIQc+yJsCxgNuadsMJEbvGSRpsTYQew4LDstgHjOpo8H8p1lQYH6L9w4auYI3nT/P+2a8FxxgcFwcBe0zgUc6Psjw401q8sINn2r5+YOIpcV9TbqD7e5hNhfAAX4CScmNHpbCA3auHt1QnuGJiJAhfPzVGP7ZMRe9bVuCsjY5nCM+xNnidxgIOsSo8e2DCsuQtTILinTQvTOiCeHLUujzV0oCVOT2m5KU9bRM0OjNH1NiGZm21V84LgybX0itDmvCu4bB19+YKiyKS8KWcoNmpkhLjTPpzLCiF1+T4C+eX+V1keq0EAAAAAElFTkSuQmCC";

var img$e = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAZBJREFUeNrtmlGOwyAMRDOoJ9jm/idM9wjrzVZaKWpDoBI2YzBSf6oqeB5jjGmWZfKBDnMKU0wgEd0tPpAKN4sTDsSrxgqyPDffH2AoHp2eYwqgddDqEEAs3gQCyMWrPz85KbHUZVA6VxewOsDFSOTWV392UrAkW3Nl6gCL5grMKSDsK94aAAhSIKpAACADIF7yvxUAeM3/SAFFAOIltRKLFXvNqZkCwr76sQc0BgBv9rdwgDDbP1Ig2uFwQAAIAI46QZU5wgEOdmzEHuAEgOV/BMJk0VxAFu8eQA3Auq6nlH/k/evvx+Ptu6/7van6mjkS8jy2bUMVgJzwKwCvAbYWXzvHFYAcCNQKLwGg2NBQnxH/IKavAiitfi53vIySttuowo86dgjZ0okzQqOIP7ggW0qn2AP2BX1+sifB4w9GW/2Ss3FiC4zshteUjzK4n6jk7Jg5w/g7TWLheNNr2AsRfgBajYunFOh1qdG9BYgUCAABIADcPuymnsPLrVCuAQoHXABAafWd3gNM0+x9PH4BvDJ3ZJJMpIIAAAAASUVORK5CYII=";

var img$f = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAaNJREFUeNrlm0sOgzAMRHHEEbj/CbmDq7Ko2opWxBk79pBNuwCTN/4lCshSc+jbfxkxJMXhhzmEAH6IRUjgzTxCBG9iaoXhBSBW+gi4Aq8jbELiebMIQhL2ZhGEBN58rxDBm2wIGXy3LSGE77LZSOEv399I4S8viORm8GlqQDR8qjaYBn5GDZie8zMjIEXOzxIgJXyUAGnhIwRIDe8tQHp4TwFKwHsJUAbeQ4BS8GgBysEjBSgJf2pk27bjd993evjnWL/B7+J5xGaoPPxLAIP3KeCtEUADfxg+8/6fAkgF3xsBdPCnAvzwPiX8Rxsk8Tz8bDAzPOStkdUw8dnwipxf73l7NnjxqgG6+AwFpSKsQDYQQEl49EqwHPw/g8iXEhHwbmsCj91gGfgeAQSYDqneS2oArym4jWqkWM2hZmgV+F8PUcM1iLDXGWnSgMKhcj60RvTsBTwLni6ThjhOxgIf3iHWIFFTwp89VIPAU8BbIqDiV2bDAngfoU8VVYInqdkiKmpTolnTCXEuUBbeskTtTZ30RTRqpZa2eyA/R6FvmZTjAXQIhaMv+ge0AAAAAElFTkSuQmCC";

var img$g = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABb2lDQ1BpY2MAACiRdZE7SwNBFIW/JIpioim0ELHYIgaLCKIglhJBG7WIEYzabDabRNjEZTdBgq1gYyFYiDa+Cv+BtoKtgiAogoiNf8BXI2G9Y4SImFlm78eZOZeZM+CfsoyC2zQIhWLJSUzGtfnUgtbyTIAQHQSJ6oZrT89OJGk4Pm7xqXozoHo13vfvCGZM1wBfq/CIYTsl4THhqdWSrXhTuMvI6xnhA+GYIwcUvlR6usZPinM1flPsJBPj4Fc9tdwvTv9iI+8UhPuFIwWrbPycR90kZBbnZqX2yOzFJcEkcTTSlFnGosSA1KJk9r9v8Ns3w4p4DPnbVHDEkSMv3pioZelqSs2KbspnUVG5/83TzQ4P1bqH4tD86HmvfdCyDdUtz/s89LzqEQQe4LxY969ITqPvom/Vtcg+hNfh9KKupXfgbAO6723d0b+lgEx/NgsvJ9Cegs5raFusZfWzzvEdJNfkia5gdw+isj+89AXPlWf0rTeiAwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAeNJREFUeNrlm2uOwjAMhDsWJ4De/4bsEfD+WGm3QqTNw54460hIBbWNP2ec2G3Alq/p4RhIDP/jgczwmRyghd9NQ0AbzkUEeAtD1MBAzIIf6VwdjAUbvqdTJUgWLPjWztQAQAlO0JZ7wgAeTnMIvOFrOlFSzFr0oz3Xw/qGrNi1shWB4Hv7HrJVAiYvICjm9EQNkjJf2WGiUgSFv7LHLERlW6+Zzk8IPPotyVO3nRKkYhuBG7JTiDl+yLpBssV8rQMQHN5UQp6TX/TQgqw8ehY2SmD5U5psydst0JJVM9urgVo1ogKmld+SGT6CA6bCz3bAdPiSAzQL/CwFWD/4HHYAFpU9VlPACLyyQ4CVx09Pu+XEEA0MD28FRBp5ZSiAqYJReDDmgH+zzrc6wEIFVvCUx/S1D0SUHK+0dxRiMLIMeHoq3PoqWo3A6XPHaP6NzX/vkOvuMa809JNj0OFc9xXq1jByq+wSc00pV9knWM0g+77/fjkeTzAOMxKlCApgQzfPAbUZngaGLucB98fDKr3F26ck8VD1AIzga64L+cpdnOCXaZIZ/swBKeBLDkgD/8kBqeDfHZAO/uiAlPBX9TxKNcJL/y75ej5nFk5uq0CajVKXD0UrKsTlQ+AoV9afF8PwfwNGBXNgWGrhCQAAAABJRU5ErkJggg==";

const styles = `
  <style>
    :host {
      --color-primary-final: var(--color-primary, rgba(40,40,40,1));
      --color-primary-tr-final: var(--color-primary-tr, rgba(40,40,40,0.9));
      --color-secondary-final: var(--color-secondary, rgba(60,60,60,1));
      --color-secondary-tr-final: var(--color-secondary-tr, rgba(60,60,60,0.9));
      --color-accent-final: var(--color-accent, rgba(96,96,96,1));
      --color-shadow-final: var(--color-shadow, rgba(0,0,0,0.75));
      --color-bg-final: var(--color-bg, rgba(128,128,128,1));
      --color-fg-primary-final: var(--color-fg-primary, rgba(255,255,255,1));
      --color-fg-secondary-final: var(--color-fg-secondary, rgba(187,187,187,1));
      --color-fg-accent-final: var(--color-fg-accent, rgba(255,255,255,1));
      --color-text-selection-final: var(--color-text-selection, rgba(104,104,128,0.3));
    }

    .disabled {
      pointer-events: none;
    }

    .relative {
      position: relative;
    }
    .absolute {
      position: absolute;
    }
    .abs-stretch {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }
    .abs-topleft {
      position: absolute;
      left: 0;
      top: 0;
    }
    .stretch {
      width: 100%;
      height: 100%;
    }
    
    .no-margin {
      margin: 0;
    }
    .no-padding {
      padding: 0;
    }
    .margin-s-5 {
      margin: 0 5px;
    }

    #main-container {
      box-sizing: border-box;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: stretch;
      align-items: stretch;
      width: 100%;
      height: 100%;
      background: var(--color-bg-final);
    }
  
    #top-panel {
      position: relative;
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      width: 100%;
      height: 50px;
      background: var(--color-primary-final);
      box-shadow: 0 0 10px var(--color-shadow-final);
      z-index: 1;
      transition: height 0.25s ease-out 0.1s;
    }
    .hide-panels #top-panel {
      height: 0;
      transition: height 0.25s ease-in 0.2s;
    }
  
    #bottom-panel {
      position: absolute;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      flex-grow: 0;
      flex-shrink: 0;
      left: calc(50% - 160px);
      bottom: 20px;
      width: 320px;
      height: 50px;  
      background: var(--color-primary-tr-final);
      box-shadow: 0 0 10px var(--color-shadow-final);
      z-index: 1;
      transition: height 0.25s ease-out, bottom 0.1s linear 0.25s;
    }
    .hide-panels #bottom-panel {
      bottom: 0;
      height: 0;
      transition: bottom 0.1s linear 0.1s, height 0.25s ease-in 0.2s;
    }
    
    #annotation-panel {
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      flex-grow: 0;
      flex-shrink: 0;
      top: 80px;
      right: 0;
      width: 0;
      z-index: 1;
      transition: right 0.1s linear 0.1s, width 0.25s ease-in 0.2s;
    }
    .mode-annotation #annotation-panel {
      right: 20px;
      width: 50px;
      transition: width 0.25s ease-out, right 0.1s linear 0.25s;
    }

    .panel-v-separator {
      width: 1px;
      height: 30px;
      background-color: var(--color-fg-secondary-final);
    }
  
    .panel-button {
      cursor: pointer;
      user-select: none;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 36px;
      height: 36px;
      border-radius: 50%;
    }
    .panel-button:hover,
    .panel-button.on {
      background-color: var(--color-accent-final);
    }
    .panel-button img {
      width: 20px;
      height: 20px;
      filter: invert() opacity(0.5) drop-shadow(0 0 0 var(--color-fg-primary-final)) saturate(1000%);
    }  
    .panel-button:hover img,
    .panel-button.on img {
      filter: invert() opacity(0.5) drop-shadow(0 0 0 var(--color-fg-accent-final)) saturate(1000%);
    }  
  
    .subpanel {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      margin: 0 4px;
    }    
    
    .panel-item {
      transform: scale(1);
      transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
    }
    .hide-panels .panel-item {
      cursor: default;      
      opacity: 0;
      transform: scale(0);
      transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
    }

    .annotation-panel-item {
      margin: 3px;
      cursor: default;      
      opacity: 0;
      background: var(--color-primary-tr-final);
      box-shadow: 0 0 10px var(--color-shadow-final);
      transform: scale(0);
      transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
    }    
    .mode-annotation .annotation-panel-item { 
      cursor: pointer;
      opacity: 100;
      transform: scale(1);    
      transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
    }
  
    #paginator {  
      user-select: none;
      font-family: sans-serif;
      font-size: 16px;
      color: var(--color-fg-primary-final);
    }
    #paginator-input {
      text-align: center; 
      font-size: 16px;
      width: 30px;
      height: 30px;
      margin: 2px;
      padding: 0;
      outline: none;
      border: none;
      color: var(--color-fg-primary-final);
      background-color: var(--color-primary-final);
    }
    #paginator-total {
      margin: 4px;
    }

    #toggle-previewer {
      margin: 4px;
    }
      
    #previewer {
      box-sizing: border-box;
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      overflow-y: auto;
      left: 0;
      top: 50px;
      bottom: 0;
      width: 160px; 
      padding-top: 0px;
      background: var(--color-secondary-final);
      box-shadow: 0 0 10px var(--color-shadow-final);
      z-index: 1;
      transition: padding-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, width 0.25s ease-out;
    } 
    .hide-panels #previewer {
      top: 0;
      padding-top: 50px;
      transition: padding-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
    }   
    .mobile #previewer {
      background: var(--color-secondary-tr-final);
    } 
    .hide-previewer #previewer {
      width: 0;
      transition: width 0.25s ease-in 0.1s;
    }
    #previewer .page-preview {      
      transform: scaleX(1);
      transition: opacity 0.1s ease-out 0.35s, transform 0s linear 0.35s;
    }
    .hide-previewer #previewer .page-preview {
      opacity: 0;
      transform: scaleX(0);
      transition: opacity 0.1s ease-in, transform 0s linear 0.1s;
    }
  
    #viewer {
      box-sizing: border-box;
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      overflow: auto;
      left: 160px;
      right: 0;
      top: 50px;
      bottom: 0;
      margin-top: 0;
      transition: margin-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-out;
    }
    .mode-hand #viewer {
      cursor: grab !important;
      user-select: none !important;
    }
    .hide-panels #viewer {
      top: 0;
      margin-top: 50px;
      transition: margin-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s;
    }      
    .hide-panels.mobile #viewer,
    .hide-panels.hide-previewer #viewer {
      top: 0;
      margin-top: 50px;
      left: 0;
      transition: margin-top 0.25s ease-in 0.2s, top 0.25s ease-in 0.2s, left 0.25s ease-in;
    }   
    .mobile #viewer,
    .hide-previewer #viewer {
      top: 50px;
      margin-top: 0px;
      left: 0;
      transition: margin-top 0.25s ease-out 0.1s, top 0.25s ease-out 0.1s, left 0.25s ease-in;
    }
  
    .page {    
      position: relative;
      display: flex;
      flex-grow: 0;
      flex-shrink: 0;
      margin: 10px auto;
      background-color: white;
      box-shadow: 0 0 10px var(--color-shadow-final);
    }
    .page-preview {   
      cursor: pointer; 
      position: relative;
      display: flex;
      flex-grow: 0;
      flex-shrink: 0;
      margin: 0 auto;
      background-color: white;
      background-clip: content-box;
      border-style: solid;
      border-width: 10px 10px 20px 10px;
      border-color: transparent;
    }
    .page-preview:hover,
    .page-preview.current {
      border-color: var(--color-accent-final);
    }
    .page-preview::after {
      display: inline-block;
      position: absolute;
      top: calc(100% + 3px);
      width: 100%;
      text-align: center;
      font-family: sans-serif;
      font-size: 14px;
      line-height: 1;
      color: var(--color-fg-primary-final);
      content: attr(data-page-number) " ";
    }

    .page-canvas {
      background-color: white;
    } 
    
    .page-text {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: 0;
      padding: 0;
      overflow: hidden;
      line-height: 1;
    }
    .page-text span {
      cursor: text;
      position: absolute;
      white-space: pre;
      color: transparent;
      transform-origin: 0% 0%;
    }
    .page-text ::selection {
      background: var(--color-text-selection-final);
    }
    .mode-hand .page-text span {
      cursor: grab;
    }
    
    .page-annotations {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .mode-text .page-annotations,
    .mode-hand .page-annotations {
      pointer-events: none;
    }
    
    #password-dialog {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: var(--color-secondary-tr-final);
      z-index: 2;
    }
    #password-dialog .form {
      position: absolute;
      display: flex;
      flex-direction: row;
      justify-content: stretch;
      align-items: stretch;
      flex-grow: 0;
      flex-shrink: 0;
      left: calc(50% - 160px);
      top: calc(50% - 25px);
      width: 320px;
      height: 50px;  
      background: var(--color-primary-tr-final);
      box-shadow: 0 0 10px var(--color-shadow-final);
    }
    #password-dialog input {
      width: 220px;
      margin: 10px 0 10px 10px;
      padding: 5px;
      font-size: 16px;
      outline: none;
      border: none;
      color: var(--color-fg-primary-final);
      background-color: var(--color-primary-final);
    }
    #password-dialog input::placeholder {
      font-size: 14px;
      font-style: italic;
      color: var(--color-fg-primary-final);
    }
    #password-dialog .buttons {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      flex-grow: 1;
      flex-shrink: 1;
      width: 100px;
    } 

    .svg-annotation {
      cursor: pointer;
    }     
    .out .svg-annotation {
      cursor: not-allowed;
    }
    .svg-annot-rect,
    .svg-annot-box {
      fill: transparent;
    }
    .mode-annotation .svg-annotation.selected {
      cursor: grab;
    } 
    .mode-annotation .svg-annotation.selected .svg-annot-rect,
    .mode-annotation .svg-annotation.selected .svg-annot-box {
      stroke: var(--color-secondary-tr-final);
      stroke-dasharray: 3 3;
    } 
    .mode-annotation .svg-annotation.selected .svg-annot-handle-scale,
    .mode-annotation .svg-annotation.selected .svg-annot-handle-rotation {
      r: 8;
      fill: var(--color-primary-final);
      cursor: pointer;
    }
    .mode-annotation .svg-annotation.selected .svg-annot-rotation {
      fill: none;
      cursor: pointer;
    }
    .mode-annotation .svg-annotation.selected .svg-annot-rotation .circle {
      r: 25;
    }
    .mode-annotation .svg-annotation.selected .svg-annot-rotation .dashed {
      stroke: var(--color-secondary-tr-final);
      stroke-dasharray: 3 3;
    }
  </style>
`;
const html = `
  <div id="main-container" class="hide-previewer" 
    ondragstart="return false;" ondrop="return false;">
    <div id="viewer"></div>
    <div id="previewer"></div>
    <div id="top-panel"> 
      <div class="subpanel panel-item">
        <div id="toggle-previewer" class="panel-button panel-item">
          <img src="${img$6}"/>
        </div> 
      </div>
      <div id="modes" class="subpanel panel-item">
        <div id="button-mode-text" class="panel-button panel-item">
          <img src="${img$7}"/>
        </div> 
        <div id="button-mode-hand" class="panel-button panel-item">
          <img src="${img$8}"/>
        </div> 
        <div id="button-mode-annotation" class="panel-button panel-item">
          <img src="${img$9}"/>
        </div> 
        <div class="panel-v-separator margin-s-5 panel-item"></div>
        <div id="button-download-file" class="panel-button panel-item">
          <img src="${img$a}"/>
        </div> 
      </div>
    </div>
    <div id="bottom-panel" class="disabled">
      <div id="paginator" class="subpanel panel-item">
        <div id="paginator-prev" class="panel-button">
          <img src="${img}"/>
        </div>
        <div id="paginator-next" class="panel-button">
          <img src="${img$1}"/>
        </div>
        <input id="paginator-input" type="text">
        <span>&nbsp/&nbsp</span>
        <span id="paginator-total">0</span>
      </div>
      <div class="panel-v-separator panel-item"></div>
      <div id="zoomer" class="subpanel panel-item">
        <div id="zoom-out" class="panel-button">
          <img src="${img$2}"/>
        </div>
        <div id="zoom-in" class="panel-button">
          <img src="${img$3}"/>
        </div>
        <div id="zoom-fit-viewer" class="panel-button">
          <img src="${img$4}"/>
        </div>
        <div id="zoom-fit-page" class="panel-button">
          <img src="${img$5}"/>
        </div>
      </div>
    </div>
    <div id="annotation-panel">
      <div id="button-annotation-mode-select" 
        class="panel-button annotation-panel-item">
        <img src="${img$d}"/>
      </div> 
      <div id="button-annotation-mode-stamp" 
        class="panel-button annotation-panel-item">
        <img src="${img$e}"/>
      </div> 
      <div id="button-annotation-mode-pen" 
        class="panel-button annotation-panel-item">
        <img src="${img$f}"/>
      </div> 
      <div id="button-annotation-mode-geometric" 
        class="panel-button annotation-panel-item">
        <img src="${img$g}"/>
      </div> 
    </div>
  </div>
`;
const passwordDialogHtml = `
    <div class="form">
      <input id="password-input" type="password" maxlength="127"/>
      <div class="buttons">
        <div id="password-ok" class="panel-button">
          <img src="${img$b}"/>
        </div>
        <div id="password-cancel" class="panel-button">
          <img src="${img$c}"/>
        </div>
      </div>
    </div>
`;

function getRandomUuid() {
    return v4();
}
function getDistance(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
}
class LinkedListNode {
    constructor(data) {
        this.data = data;
    }
}
class LinkedList {
    constructor(head) {
        this._length = 0;
        if (head) {
            this.push(head);
        }
    }
    get head() {
        return this._head.data;
    }
    get length() {
        return this._length;
    }
    get tail() {
        return this.get(this._length - 1);
    }
    push(value) {
        const node = new LinkedListNode(value);
        let current;
        if (!this._head) {
            this._head = node;
        }
        else {
            current = this._head;
            while (current.next) {
                current = current.next;
            }
            current.next = node;
        }
        this._length++;
    }
    insert(value, n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        const node = new LinkedListNode(value);
        let previous;
        let current = this._head;
        let i = 0;
        if (!n) {
            this._head = node;
        }
        else {
            while (i++ < n) {
                previous = current;
                current = current.next;
            }
            previous.next = node;
        }
        node.next = current;
        this._length++;
        return node.data;
    }
    replace(value, n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        const node = new LinkedListNode(value);
        let previous;
        let current = this._head;
        let i = 0;
        if (!n) {
            this._head = node;
        }
        else {
            while (i++ < n) {
                previous = current;
                current = current.next;
            }
            previous.next = node;
        }
        node.next = current.next;
        return current.data;
    }
    remove(n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        let previous;
        let current = this._head;
        let i = 0;
        if (!n) {
            this._head = current.next;
        }
        else {
            while (i++ < n) {
                previous = current;
                current = current.next;
            }
            previous.next = current.next;
        }
        this._length--;
        return current.data;
    }
    clear() {
        this._head = null;
        this._length = 0;
    }
    get(n) {
        if (n < 0 || n > this._length - 1) {
            return null;
        }
        let current = this._head;
        let i = 0;
        while (i++ < n) {
            current = current.next;
        }
        return current.data;
    }
    pop() {
        return this.remove(this._length - 1);
    }
    has(value, comparator) {
        if (!this._length) {
            return false;
        }
        comparator || (comparator = (a, b) => a === b);
        let current = this._head;
        let i = 0;
        while (i < this._length) {
            if (comparator(value, current.data)) {
                return true;
            }
            current = current.next;
            i++;
        }
        return false;
    }
    findIndex(value, comparator) {
        if (!this._length) {
            return -1;
        }
        comparator || (comparator = (a, b) => a === b);
        let current = this._head;
        let i = 0;
        while (i < this._length) {
            if (comparator(value, current.data)) {
                return i;
            }
            current = current.next;
            i++;
        }
        return -1;
    }
    *[Symbol.iterator]() {
        let current = this._head;
        while (current) {
            yield current.data;
            current = current.next;
        }
    }
}

function clamp(v, min, max) {
    return Math.max(min, Math.min(v, max));
}
class Vec2 {
    constructor(x = 0, y = 0) {
        this.length = 2;
        this.x = x;
        this.y = y;
    }
    static multiplyByScalar(v, s) {
        return new Vec2(v.x * s, v.y * s);
    }
    static addScalar(v, s) {
        return new Vec2(v.x + s, v.y + s);
    }
    static normalize(v) {
        return new Vec2().setFromVec2(v).normalize();
    }
    static add(v1, v2) {
        return new Vec2(v1.x + v2.x, v1.y + v2.y);
    }
    static substract(v1, v2) {
        return new Vec2(v1.x - v2.x, v1.y - v2.y);
    }
    static dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
    }
    static applyMat3(v, m) {
        return v.clone().applyMat3(m);
    }
    static lerp(v1, v2, t) {
        return v1.clone().lerp(v2, t);
    }
    static rotate(v, center, theta) {
        return v.clone().rotate(center, theta);
    }
    static equals(v1, v2, precision = 6) {
        return v1.equals(v2);
    }
    static getDistance(v1, v2) {
        const x = v2.x - v1.x;
        const y = v2.y - v1.y;
        return Math.sqrt(x * x + y * y);
    }
    clone() {
        return new Vec2(this.x, this.y);
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setFromVec2(vec2) {
        this.x = vec2.x;
        this.y = vec2.y;
        return this;
    }
    multiplyByScalar(s) {
        this.x *= s;
        this.y *= s;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    getMagnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    normalize() {
        const m = this.getMagnitude();
        if (m) {
            this.x /= m;
            this.y /= m;
        }
        return this;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    substract(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    dotProduct(v) {
        return Vec2.dotProduct(this, v);
    }
    applyMat3(m) {
        if (m.length !== 9) {
            throw new Error("Matrix must contain 9 elements");
        }
        const { x, y } = this;
        const [x_x, x_y, , y_x, y_y, , z_x, z_y,] = m;
        this.x = x * x_x + y * y_x + z_x;
        this.y = x * x_y + y * y_y + z_y;
        return this;
    }
    lerp(v, t) {
        this.x += t * (v.x - this.x);
        this.y += t * (v.y - this.y);
        return this;
    }
    rotate(center, theta) {
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
    equals(v, precision = 6) {
        return +this.x.toFixed(precision) === +v.x.toFixed(precision)
            && +this.y.toFixed(precision) === +v.y.toFixed(precision);
    }
    toArray() {
        return [this.x, this.y];
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
    }
}
class Vec3 {
    constructor(x = 0, y = 0, z = 0) {
        this.length = 3;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static multiplyByScalar(v, s) {
        return new Vec3(v.x * s, v.y * s, v.z * s);
    }
    static addScalar(v, s) {
        return new Vec3(v.x + s, v.y + s, v.z + s);
    }
    static normalize(v) {
        return new Vec3().setFromVec3(v).normalize();
    }
    static add(v1, v2) {
        return new Vec3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
    }
    static substract(v1, v2) {
        return new Vec3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    }
    static dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    }
    static crossProduct(v1, v2) {
        return new Vec3(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
    }
    static onVector(v1, v2) {
        return v1.clone().onVector(v2);
    }
    static onPlane(v, planeNormal) {
        return v.clone().onPlane(planeNormal);
    }
    static applyMat3(v, m) {
        return v.clone().applyMat3(m);
    }
    static lerp(v1, v2, t) {
        return v1.clone().lerp(v2, t);
    }
    static equals(v1, v2, precision = 6) {
        if (!v1) {
            return false;
        }
        return v1.equals(v2, precision);
    }
    static getDistance(v1, v2) {
        const x = v2.x - v1.x;
        const y = v2.y - v1.y;
        const z = v2.z - v1.z;
        return Math.sqrt(x * x + y * y + z * z);
    }
    static getAngle(v1, v2) {
        return v1.getAngle(v2);
    }
    clone() {
        return new Vec3(this.x, this.y, this.z);
    }
    set(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setFromVec3(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    multiplyByScalar(s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    getMagnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    getAngle(v) {
        const d = this.getMagnitude() * v.getMagnitude();
        if (!d) {
            return Math.PI / 2;
        }
        const cos = this.dotProduct(v) / d;
        return Math.acos(clamp(cos, -1, 1));
    }
    normalize() {
        const m = this.getMagnitude();
        if (m) {
            this.x /= m;
            this.y /= m;
            this.z /= m;
        }
        return this;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    substract(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    dotProduct(v) {
        return Vec3.dotProduct(this, v);
    }
    crossProduct(v) {
        this.x = this.y * v.z - this.z * v.y;
        this.y = this.z * v.x - this.x * v.z;
        this.z = this.x * v.y - this.y * v.x;
        return this;
    }
    onVector(v) {
        const magnitude = this.getMagnitude();
        if (!magnitude) {
            return this.set(0, 0, 0);
        }
        return v.clone().multiplyByScalar(v.clone().dotProduct(this) / (magnitude * magnitude));
    }
    onPlane(planeNormal) {
        return this.substract(this.clone().onVector(planeNormal));
    }
    applyMat3(m) {
        if (m.length !== 9) {
            throw new Error("Matrix must contain 9 elements");
        }
        const { x, y, z } = this;
        const [x_x, x_y, x_z, y_x, y_y, y_z, z_x, z_y, z_z] = m;
        this.x = x * x_x + y * y_x + z * z_x;
        this.y = x * x_y + y * y_y + z * z_y;
        this.z = x * x_z + y * y_z + z * z_z;
        return this;
    }
    lerp(v, t) {
        this.x += t * (v.x - this.x);
        this.y += t * (v.y - this.y);
        this.z += t * (v.z - this.z);
        return this;
    }
    equals(v, precision = 6) {
        if (!v) {
            return false;
        }
        return +this.x.toFixed(precision) === +v.x.toFixed(precision)
            && +this.y.toFixed(precision) === +v.y.toFixed(precision)
            && +this.z.toFixed(precision) === +v.z.toFixed(precision);
    }
    toArray() {
        return [this.x, this.y, this.z];
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
    }
}
class Mat3 {
    constructor() {
        this.length = 9;
        this._matrix = new Array(this.length);
        this._matrix[0] = 1;
        this._matrix[1] = 0;
        this._matrix[2] = 0;
        this._matrix[3] = 0;
        this._matrix[4] = 1;
        this._matrix[5] = 0;
        this._matrix[6] = 0;
        this._matrix[7] = 0;
        this._matrix[8] = 1;
    }
    get x_x() {
        return this._matrix[0];
    }
    get x_y() {
        return this._matrix[1];
    }
    get x_z() {
        return this._matrix[2];
    }
    get y_x() {
        return this._matrix[3];
    }
    get y_y() {
        return this._matrix[4];
    }
    get y_z() {
        return this._matrix[5];
    }
    get z_x() {
        return this._matrix[6];
    }
    get z_y() {
        return this._matrix[7];
    }
    get z_z() {
        return this._matrix[8];
    }
    static fromMat3(m) {
        return new Mat3().setFromMat3(m);
    }
    static multiply(m1, m2) {
        const [a11, a12, a13, a21, a22, a23, a31, a32, a33] = m1._matrix;
        const [b11, b12, b13, b21, b22, b23, b31, b32, b33] = m2._matrix;
        const m = new Mat3();
        m.set(a11 * b11 + a12 * b21 + a13 * b31, a11 * b12 + a12 * b22 + a13 * b32, a11 * b13 + a12 * b23 + a13 * b33, a21 * b11 + a22 * b21 + a23 * b31, a21 * b12 + a22 * b22 + a23 * b32, a21 * b13 + a22 * b23 + a23 * b33, a31 * b11 + a32 * b21 + a33 * b31, a31 * b12 + a32 * b22 + a33 * b32, a31 * b13 + a32 * b23 + a33 * b33);
        return m;
    }
    static multiplyScalar(m, s) {
        const res = new Mat3();
        for (let i = 0; i < this.length; i++) {
            res._matrix[i] = m._matrix[i] * s;
        }
        return res;
    }
    static transpose(m) {
        const res = new Mat3();
        res.set(m.x_x, m.y_x, m.z_x, m.x_y, m.y_y, m.z_y, m.x_z, m.y_z, m.z_z);
        return res;
    }
    static invert(m) {
        const mTemp = new Mat3();
        mTemp.set(m.y_y * m.z_z - m.z_y * m.y_z, m.y_x * m.z_z - m.z_x * m.y_z, m.y_x * m.z_y - m.z_x * m.y_y, m.x_y * m.z_z - m.z_y * m.x_z, m.x_x * m.z_z - m.z_x * m.x_z, m.x_x * m.z_y - m.z_x * m.x_y, m.x_y * m.y_z - m.y_y * m.x_z, m.x_x * m.y_z - m.y_x * m.x_z, m.x_x * m.y_y - m.y_x * m.x_y);
        mTemp.set(mTemp.x_x, -mTemp.x_y, mTemp.x_z, -mTemp.y_x, mTemp.y_y, -mTemp.y_z, mTemp.z_x, -mTemp.z_y, mTemp.z_z);
        const det = m.x_x * mTemp.x_x + m.x_y * mTemp.x_y + m.x_z * mTemp.x_z;
        const inversed = new Mat3();
        if (!det) {
            inversed.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        else {
            const detInv = 1 / 10;
            inversed.set(detInv * mTemp.x_x, detInv * mTemp.y_x, detInv * mTemp.z_x, detInv * mTemp.x_y, detInv * mTemp.y_y, detInv * mTemp.z_y, detInv * mTemp.x_z, detInv * mTemp.y_z, detInv * mTemp.z_z);
        }
        return inversed;
    }
    static buildScale(x, y = undefined) {
        y !== null && y !== void 0 ? y : (y = x);
        return new Mat3().set(x, 0, 0, 0, y, 0, 0, 0, 1);
    }
    static buildRotation(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        return new Mat3().set(c, -s, 0, s, c, 0, 0, 0, 1);
    }
    static buildTranslate(x, y) {
        return new Mat3().set(1, 0, 0, 0, 1, 0, x, y, 1);
    }
    static equals(m1, m2, precision = 6) {
        return m1.equals(m2, precision);
    }
    clone() {
        return new Mat3().set(this.x_x, this.x_y, this.x_z, this.y_x, this.y_y, this.y_z, this.z_x, this.z_y, this.z_z);
    }
    set(x_x, x_y, x_z, y_x, y_y, y_z, z_x, z_y, z_z) {
        this._matrix[0] = x_x;
        this._matrix[1] = x_y;
        this._matrix[2] = x_z;
        this._matrix[3] = y_x;
        this._matrix[4] = y_y;
        this._matrix[5] = y_z;
        this._matrix[6] = z_x;
        this._matrix[7] = z_y;
        this._matrix[8] = z_z;
        return this;
    }
    reset() {
        this._matrix[0] = 1;
        this._matrix[1] = 0;
        this._matrix[2] = 0;
        this._matrix[3] = 0;
        this._matrix[4] = 1;
        this._matrix[5] = 0;
        this._matrix[6] = 0;
        this._matrix[7] = 0;
        this._matrix[8] = 1;
        return this;
    }
    setFromMat3(m) {
        for (let i = 0; i < this.length; i++) {
            this._matrix[i] = m._matrix[i];
        }
        return this;
    }
    multiply(m) {
        const [a11, a12, a13, a21, a22, a23, a31, a32, a33] = this._matrix;
        const [b11, b12, b13, b21, b22, b23, b31, b32, b33] = m._matrix;
        this._matrix[0] = a11 * b11 + a12 * b21 + a13 * b31;
        this._matrix[1] = a11 * b12 + a12 * b22 + a13 * b32;
        this._matrix[2] = a11 * b13 + a12 * b23 + a13 * b33;
        this._matrix[3] = a21 * b11 + a22 * b21 + a23 * b31;
        this._matrix[4] = a21 * b12 + a22 * b22 + a23 * b32;
        this._matrix[5] = a21 * b13 + a22 * b23 + a23 * b33;
        this._matrix[6] = a31 * b11 + a32 * b21 + a33 * b31;
        this._matrix[7] = a31 * b12 + a32 * b22 + a33 * b32;
        this._matrix[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        for (let i = 0; i < this.length; i++) {
            this._matrix[i] *= s;
        }
        return this;
    }
    transpose() {
        const temp = new Mat3().setFromMat3(this);
        this.set(temp.x_x, temp.y_x, temp.z_x, temp.x_y, temp.y_y, temp.z_y, temp.x_z, temp.y_z, temp.z_z);
        return this;
    }
    invert() {
        const mTemp = new Mat3();
        mTemp.set(this.y_y * this.z_z - this.z_y * this.y_z, this.y_x * this.z_z - this.z_x * this.y_z, this.y_x * this.z_y - this.z_x * this.y_y, this.x_y * this.z_z - this.z_y * this.x_z, this.x_x * this.z_z - this.z_x * this.x_z, this.x_x * this.z_y - this.z_x * this.x_y, this.x_y * this.y_z - this.y_y * this.x_z, this.x_x * this.y_z - this.y_x * this.x_z, this.x_x * this.y_y - this.y_x * this.x_y);
        mTemp.set(mTemp.x_x, -mTemp.x_y, mTemp.x_z, -mTemp.y_x, mTemp.y_y, -mTemp.y_z, mTemp.z_x, -mTemp.z_y, mTemp.z_z);
        const det = this.x_x * mTemp.x_x + this.x_y * mTemp.x_y + this.x_z * mTemp.x_z;
        if (!det) {
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
        else {
            const detInv = 1 / 10;
            this.set(detInv * mTemp.x_x, detInv * mTemp.y_x, detInv * mTemp.z_x, detInv * mTemp.x_y, detInv * mTemp.y_y, detInv * mTemp.z_y, detInv * mTemp.x_z, detInv * mTemp.y_z, detInv * mTemp.z_z);
        }
        return this;
    }
    getDeterminant() {
        const [a, b, c, d, e, f, g, h, i] = this._matrix;
        return a * e * i - a * f * h + b * f * g - b * d * i + c * d * h - c * e * g;
    }
    getTRS() {
        const t = new Vec2(this.z_x, this.z_y);
        const s_x = Math.sqrt(this.x_x * this.x_x + this.x_y * this.x_y);
        const s_y = Math.sqrt(this.y_x * this.y_x + this.y_y * this.y_y);
        const s = new Vec2(s_x, s_y);
        const sign = Math.atan(-this.x_y / this.x_x);
        const angle = Math.acos(this.x_x / s_x);
        let r;
        if ((angle > Math.PI / 2 && sign > 0)
            || (angle < Math.PI / 2 && sign < 0)) {
            r = 2 * Math.PI - angle;
        }
        else {
            r = angle;
        }
        return { t, r, s };
    }
    equals(m, precision = 6) {
        for (let i = 0; i < this.length; i++) {
            if (+this._matrix[i].toFixed(precision) !== +m._matrix[i].toFixed(precision)) {
                return false;
            }
        }
        return true;
    }
    applyScaling(x, y = undefined) {
        const m = Mat3.buildScale(x, y);
        return this.multiply(m);
    }
    applyTranslation(x, y) {
        const m = Mat3.buildTranslate(x, y);
        return this.multiply(m);
    }
    applyRotation(theta) {
        const m = Mat3.buildRotation(theta);
        return this.multiply(m);
    }
    toArray() {
        return this._matrix.slice();
    }
    toIntArray() {
        return new Int32Array(this);
    }
    toIntShortArray() {
        return new Int32Array([
            this._matrix[0],
            this._matrix[1],
            this._matrix[3],
            this._matrix[4],
            this._matrix[6],
            this._matrix[7],
        ]);
    }
    toFloatArray() {
        return new Float32Array(this);
    }
    toFloatShortArray() {
        return new Float32Array([
            this._matrix[0],
            this._matrix[1],
            this._matrix[3],
            this._matrix[4],
            this._matrix[6],
            this._matrix[7],
        ]);
    }
    *[Symbol.iterator]() {
        for (let i = 0; i < 9; i++) {
            yield this._matrix[i];
        }
    }
}
function mat3From4Vec2(aMin, aMax, bMin, bMax, noRotation = false) {
    const mat = new Mat3();
    mat.applyTranslation(-aMin.x, -aMin.y);
    const aLen = Vec2.substract(aMax, aMin).getMagnitude();
    const bLen = Vec2.substract(bMax, bMin).getMagnitude();
    const scale = bLen / aLen;
    mat.applyScaling(scale);
    if (!noRotation) {
        const aTheta = Math.atan2(aMax.y - aMin.y, aMax.x - aMin.x);
        const bTheta = Math.atan2(bMax.y - bMin.y, bMax.x - bMin.x);
        const rotation = bTheta - aTheta;
        mat.applyRotation(rotation);
    }
    mat.applyTranslation(bMin.x, bMin.y);
    return mat;
}
function vecMinMax(...values) {
    const min = new Vec2(Math.min(...values.map(x => x.x)), Math.min(...values.map(x => x.y)));
    const max = new Vec2(Math.max(...values.map(x => x.x)), Math.max(...values.map(x => x.y)));
    return { min, max };
}

const codes = {
    NULL: 0,
    BACKSPACE: 8,
    HORIZONTAL_TAB: 9,
    LINE_FEED: 10,
    VERTICAL_TAB: 11,
    FORM_FEED: 12,
    CARRIAGE_RETURN: 13,
    WHITESPACE: 32,
    EXCLAMATION_MARK: 33,
    DOUBLE_QUOTE: 34,
    HASH: 35,
    DOLLAR: 36,
    PERCENT: 37,
    AMPERSAND: 38,
    QUOTE: 39,
    L_PARENTHESE: 40,
    R_PARENTHESE: 41,
    ASTERISK: 42,
    PLUS: 43,
    COMMA: 44,
    MINUS: 45,
    DOT: 46,
    SLASH: 47,
    D_0: 48,
    D_1: 49,
    D_2: 50,
    D_3: 51,
    D_4: 52,
    D_5: 53,
    D_6: 54,
    D_7: 55,
    D_8: 56,
    D_9: 57,
    COLON: 58,
    SEMICOLON: 59,
    LESS: 60,
    EQUAL: 61,
    GREATER: 62,
    QUESTION_MARK: 63,
    AT: 64,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    L_BRACKET: 91,
    BACKSLASH: 92,
    R_BRACKET: 93,
    CARET: 94,
    UNDERSCORE: 95,
    BACKTICK: 96,
    a: 97,
    b: 98,
    c: 99,
    d: 100,
    e: 101,
    f: 102,
    g: 103,
    h: 104,
    i: 105,
    j: 106,
    k: 107,
    l: 108,
    m: 109,
    n: 110,
    o: 111,
    p: 112,
    q: 113,
    r: 114,
    s: 115,
    t: 116,
    u: 117,
    v: 118,
    w: 119,
    x: 120,
    y: 121,
    z: 122,
    L_BRACE: 123,
    VERTICAL_LINE: 124,
    R_BRACE: 125,
    TILDE: 126,
};
const keywordCodes = {
    NULL: [codes.n, codes.u, codes.l, codes.l],
    OBJ: [codes.o, codes.b, codes.j],
    OBJ_END: [codes.e, codes.n, codes.d, codes.o, codes.b, codes.j],
    STREAM_START: [codes.s, codes.t, codes.r, codes.e, codes.a, codes.m],
    STREAM_END: [codes.e, codes.n, codes.d,
        codes.s, codes.t, codes.r, codes.e, codes.a, codes.m],
    DICT_START: [codes.LESS, codes.LESS],
    DICT_END: [codes.GREATER, codes.GREATER],
    ARRAY_START: [codes.L_BRACKET],
    ARRAY_END: [codes.R_BRACKET],
    STR_LITERAL_START: [codes.L_PARENTHESE],
    STR_LITERAL_END: [codes.R_PARENTHESE],
    STR_HEX_START: [codes.LESS],
    STR_HEX_END: [codes.GREATER],
    VERSION: [codes.PERCENT, codes.P, codes.D, codes.F, codes.MINUS],
    PREV: [codes.SLASH, codes.P, codes.r, codes.e, codes.v],
    TYPE: [codes.SLASH, codes.T, codes.y, codes.p, codes.e],
    SUBTYPE: [codes.SLASH, codes.S, codes.u, codes.b, codes.t, codes.y, codes.p, codes.e],
    FORM: [codes.SLASH, codes.F, codes.o, codes.r, codes.m],
    XREF_TABLE: [codes.x, codes.r, codes.e, codes.f],
    XREF_STREAM: [codes.SLASH, codes.X, codes.R, codes.e, codes.f],
    XREF_HYBRID: [codes.X, codes.R, codes.e, codes.f, codes.S, codes.t, codes.m],
    XREF_START: [codes.s, codes.t, codes.a, codes.r, codes.t,
        codes.x, codes.r, codes.e, codes.f],
    TRAILER: [codes.t, codes.r, codes.a, codes.i, codes.l, codes.e, codes.r],
    END_OF_FILE: [codes.PERCENT, codes.PERCENT, codes.E, codes.O, codes.F],
    END_OF_LINE: [codes.CARRIAGE_RETURN, codes.LINE_FEED],
    TRUE: [codes.t, codes.r, codes.u, codes.e],
    FALSE: [codes.f, codes.a, codes.l, codes.s, codes.e],
};
const DELIMITER_CHARS = new Set([
    codes.PERCENT,
    codes.L_PARENTHESE,
    codes.R_PARENTHESE,
    codes.SLASH,
    codes.LESS,
    codes.GREATER,
    codes.L_BRACKET,
    codes.R_BRACKET,
    codes.L_BRACE,
    codes.R_BRACE,
]);
const SPACE_CHARS = new Set([
    codes.NULL,
    codes.HORIZONTAL_TAB,
    codes.LINE_FEED,
    codes.FORM_FEED,
    codes.CARRIAGE_RETURN,
    codes.WHITESPACE,
]);
const DIGIT_CHARS = new Set([
    codes.D_0,
    codes.D_1,
    codes.D_2,
    codes.D_3,
    codes.D_4,
    codes.D_5,
    codes.D_6,
    codes.D_7,
    codes.D_8,
    codes.D_9,
]);
function isRegularChar(code) {
    if (isNaN(code)) {
        return false;
    }
    return !DELIMITER_CHARS.has(code) && !SPACE_CHARS.has(code);
}
function isDigit(code) {
    return DIGIT_CHARS.has(code);
}

const objectTypes = {
    UNKNOWN: 0,
    NULL: 1,
    BOOLEAN: 2,
    NUMBER: 3,
    STRING_LITERAL: 4,
    STRING_HEX: 5,
    NAME: 6,
    ARRAY: 7,
    DICTIONARY: 8,
    STREAM: 9,
};
const xRefTypes = {
    TABLE: 0,
    STREAM: 1,
    HYBRID: 2,
};
const xRefEntryTypes = {
    FREE: 0,
    NORMAL: 1,
    COMPRESSED: 2,
};
const streamFilters = {
    ASCII85: "/ASCII85Decode",
    ASCIIHEX: "/ASCIIHexDecode",
    CCF: "/CCITTFaxDecode",
    CRYPT: "/Crypt",
    DCT: "/DCTDecode",
    FLATE: "/FlateDecode",
    JBIG2: "/JBIG2Decode",
    JPX: "/JPXDecode",
    LZW: "/LZWDecode",
    RLX: "/RunLengthDecode",
};
const flatePredictors = {
    NONE: 1,
    TIFF: 2,
    PNG_NONE: 10,
    PNG_SUB: 11,
    PNG_UP: 12,
    PNG_AVERAGE: 13,
    PNG_PAETH: 14,
    PNG_OPTIMUM: 15,
};
const cryptVersions = {
    RC4_40: 1,
    RC4_128: 2,
    AES_128: 4,
    AES_256: 5,
};
const cryptRevisions = {
    RC4_40: 2,
    RC4_128: 3,
    AES_128: 4,
    AES_256: 5,
    AES_256_V2: 6,
};
const cryptMethods = {
    NONE: "/None",
    RC4: "/V2",
    AES_128: "/AESV2",
    AES_256: "/AESV3",
};
const authEvents = {
    DOC_OPEN: "/DocOpen",
    EMBEDDED_OPEN: "/EFOpen",
};
const streamTypes = {
    XREF: "/XRef",
    OBJECT_STREAM: "/ObjStm",
    FORM_XOBJECT: "/XObject",
    METADATA_STREAM: "/Metadata",
};
const dictTypes = {
    XREF: "/XRef",
    XOBJECT: "/XObject",
    CATALOG: "/Catalog",
    PAGE_TREE: "/Pages",
    PAGE: "/Page",
    ANNOTATION: "/Annot",
    BORDER_STYLE: "/Border",
    OPTIONAL_CONTENT_GROUP: "/OCG",
    OPTIONAL_CONTENT_MD: "/OCMD",
    EXTERNAL_DATA: "/ExDATA",
    ACTION: "/Action",
    MEASURE: "/Measure",
    DEV_EXTENSIONS: "/DeveloperExtensions",
    GRAPHICS_STATE: "/ExtGState",
    CRYPT_FILTER: "/CryptFilter",
    SOFT_MASK: "/Mask",
    GROUP: "/Group",
    FONT: "/Font",
    EMPTY: "",
};
const groupDictTypes = {
    TRANSPARENCY: "/Transparency",
};
const valueTypes = {
    UNKNOWN: 0,
    NULL: 1,
    BOOLEAN: 2,
    NUMBER: 3,
    STRING_LITERAL: 4,
    STRING_HEX: 5,
    NAME: 6,
    ARRAY: 7,
    DICTIONARY: 8,
    STREAM: 9,
    REF: 10,
    COMMENT: 11,
};
const annotationTypes = {
    TEXT: "/Text",
    LINK: "/Link",
    FREE_TEXT: "/FreeText",
    LINE: "/Line",
    SQUARE: "/Square",
    CIRCLE: "/Circle",
    POLYGON: "/Polygon",
    POLYLINE: "/PolyLine",
    HIGHLIGHT: "/Highlight",
    UNDERLINE: "/Underline",
    SQUIGGLY: "/Squiggly",
    STRIKEOUT: "/StrikeOut",
    STAMP: "/Stamp",
    CARET: "/Caret",
    INK: "/Ink",
    POPUP: "/Popup",
    FILE_ATTACHMENT: "/FileAttachment",
    SOUND: "/Sound",
    MOVIE: "/Movie",
    WIDGET: "/Widget",
    SCREEN: "/Screen",
    PRINTER_MARK: "/PrinterMark",
    TRAPNET: "/TrapNet",
    WATERMARK: "/Watermark",
    THREED: "/3D",
    REDACT: "/Redact",
    PROJECTION: "/Projection",
    RICH_MEDIA: "/RichMedia",
};
const lineCapStyles = {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2,
};
const lineJoinStyles = {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2,
};
const renderingIntents = {
    ABSOLUTE: "/AbsoluteColorimetric",
    RELATIVE: "/RelativeColorimetric",
    SATURATION: "/Saturation",
    PERCEPTUAL: "/Perceptual",
};
const blendModes = {
    NORMAL: "/Normal",
    COMPATIBLE: "/Compatible",
    MULTIPLY: "/Multiply",
    SCREEN: "/Screen",
    OVERLAY: "/Overlay",
    DARKEN: "/Darken",
    LIGHTEN: "/Lighten",
    COLOR_DODGE: "/ColorDodge",
    COLOR_BURN: "/ColorBurn",
    HARD_LIGHT: "/HardLight",
    SOFT_LIGHT: "/SoftLight",
    DIFFERENCE: "/Difference",
    EXCLUSION: "/Exclusion",
};
const textRenderModes = {
    FILL: 0,
    STROKE: 1,
    FILL_STROKE: 2,
    INVISIBLE: 3,
    FILL_USE_AS_CLIP: 4,
    STROKE_USE_AS_CLIP: 5,
    FILL_STROKE_USE_AS_CLIP: 6,
    USE_AS_CLIP: 7,
};
const colorSpaces = {
    GRAYSCALE: "/DeviceGray",
    RGB: "/DeviceRGB",
    CMYK: "/DeviceCMYK",
    SPECIAL: "/DeviceN",
    SPECIAL_INDEXED: "/Indexed",
    SPECIAL_PATTERN: "/Pattern",
    SPECIAL_SEPARATION: "/Separation",
};
const softMaskTypes = {
    ALPHA: "/Alpha",
    LUMINOSITY: "/Luminosity",
};
const supportedFilters = new Set([
    streamFilters.FLATE,
    streamFilters.DCT,
    streamFilters.JBIG2,
    streamFilters.JPX,
]);
const maxGeneration = 65535;

function parseIntFromBytes(bytes) {
    if (!(bytes === null || bytes === void 0 ? void 0 : bytes.length)) {
        return 0;
    }
    if (bytes.length === 1) {
        return bytes[0];
    }
    const hex = Array.from(bytes, (byte) => ("0" + (byte & 0xFF).toString(16)).slice(-2)).join("");
    return parseInt(hex, 16);
}
function int8ToBytes(int) {
    const buffer = new ArrayBuffer(1);
    const view = new DataView(buffer);
    view.setInt8(0, int);
    return new Uint8Array(buffer);
}
function int16ToBytes(int, le = false) {
    const buffer = new ArrayBuffer(2);
    const view = new DataView(buffer);
    view.setInt16(0, int, le);
    return new Uint8Array(buffer);
}
function int32ToBytes(int, le = false) {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setInt32(0, int, le);
    return new Uint8Array(buffer);
}
function int32ArrayToBytes(ints, le = false) {
    const buffer = new ArrayBuffer(ints.length * 4);
    const view = new DataView(buffer);
    for (let i = 0; i < ints.length; i++) {
        view.setInt32(i * 4, ints[i], le);
    }
    return new Uint8Array(buffer);
}
function xorBytes(bytes, n) {
    const result = new Uint8Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        result[i] = bytes[i] ^ n;
    }
    return result;
}
function arraysEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
function findSubarrayIndex(arr, sub) {
    if ((arr === null || arr === void 0 ? void 0 : arr.length) && (sub === null || sub === void 0 ? void 0 : sub.length)) {
        let j;
        outer_loop: for (let i = 0; i <= arr.length; i++) {
            let overlap = false;
            for (j = 0; j < sub.length; j++) {
                if (i + j < arr.length) {
                    if (arr[i + j] !== sub[j]) {
                        continue outer_loop;
                    }
                    overlap = true;
                }
                else if (overlap) {
                    return i;
                }
                else {
                    break outer_loop;
                }
            }
        }
    }
    return -1;
}
function hexStringToBytes(hexString) {
    const bytes = new Uint8Array(hexString.length / 2);
    for (let i = 0, j = 0; i < hexString.length; i += 2, j++) {
        bytes[j] = parseInt(hexString.substr(i, 2), 16);
    }
    return bytes;
}

function toWordArray(data) {
    return Crypto.lib.WordArray.create(data);
}
function wordArrayToBytes(wordArray) {
    return int32ArrayToBytes(wordArray.words).slice(0, wordArray.sigBytes);
}
function md5(data) {
    if (data instanceof Uint8Array) {
        data = toWordArray(data);
    }
    const result = Crypto.MD5(data);
    return result;
}
function rc4(data, key) {
    if (data instanceof Uint8Array) {
        data = toWordArray(data);
    }
    if (key instanceof Uint8Array) {
        key = toWordArray(key);
    }
    const result = Crypto.RC4.encrypt(data, key).ciphertext;
    return result;
}
function aes(data, key, decrypt = false) {
    if (data instanceof Uint8Array) {
        data = toWordArray(data);
    }
    if (key instanceof Uint8Array) {
        key = toWordArray(key);
    }
    if (decrypt) {
        const ivWordArray = Crypto.lib.WordArray.create(data.words.slice(0, 4));
        const d = Crypto.algo.AES.createDecryptor(key, {
            mode: Crypto.mode.CBC,
            iv: ivWordArray,
            padding: Crypto.pad.Pkcs7,
        });
        const result = d.finalize(data);
        return result;
    }
    else {
        const ivWordArray = Crypto.lib.WordArray.random(16);
        const e = Crypto.algo.AES.createEncryptor(key, {
            mode: Crypto.mode.CBC,
            iv: ivWordArray,
            padding: Crypto.pad.Pkcs7,
        });
        const result = e.finalize(data);
        return result;
    }
}

const AESV2_KEY_PADDING = [
    0x73, 0x41, 0x6C, 0x54,
];
class AESV2DataCryptor {
    constructor(key) {
        if (!key) {
            throw new Error("Empty key");
        }
        if (key.length !== 16) {
            throw new Error(`Invalid key length: ${key.length} (shall be 16)`);
        }
        this._n = key.length;
        this._key = key;
        this._tempKey = new Uint8Array(key.length + 9);
    }
    encrypt(data, ref) {
        return this.run(data, ref.id, ref.generation);
    }
    decrypt(data, ref) {
        return this.run(data, ref.id, ref.generation, true);
    }
    run(data, id, generation, decrypt = false) {
        const idBytes = int32ToBytes(id, true);
        const genBytes = int32ToBytes(generation, true);
        this._tempKey.set(this._key, 0);
        this._tempKey.set(idBytes.subarray(0, 3), this._n);
        this._tempKey.set(genBytes.subarray(0, 2), this._n + 3);
        this._tempKey.set(AESV2_KEY_PADDING, this._n + 5);
        const hash = wordArrayToBytes(md5(this._tempKey));
        const n = Math.min(this._n + 5, 16);
        const key = hash.slice(0, n);
        const result = wordArrayToBytes(aes(data, key, decrypt));
        return decrypt
            ? result.slice(16)
            : result;
    }
}

class AESV3DataCryptor {
    constructor(key) {
        if (!key) {
            throw new Error("Empty key");
        }
        if (key.length !== 32) {
            throw new Error(`Invalid key length: ${key.length} (shall be 16)`);
        }
        this._n = key.length;
        this._key = key;
    }
    encrypt(data, ref) {
        return this.run(data, ref.id, ref.generation);
    }
    decrypt(data, ref) {
        return this.run(data, ref.id, ref.generation, true);
    }
    run(data, id, generation, decrypt = false) {
        const result = wordArrayToBytes(aes(data, this._key, decrypt));
        return decrypt
            ? result.slice(16)
            : result;
    }
}

class IdentityDataCryptor {
    constructor() {
    }
    encrypt(data, ref) {
        return data;
    }
    decrypt(data, ref) {
        return data;
    }
}

class RC4DataCryptor {
    constructor(key) {
        if (!key) {
            throw new Error("Empty key");
        }
        if (key.length < 5 || key.length > 16) {
            throw new Error(`Invalid key length: ${key.length} (shall be a multiple in range from 40 to 128)`);
        }
        this._n = key.length;
        this._key = key;
        this._tempKey = new Uint8Array(key.length + 5);
    }
    encrypt(data, ref) {
        const idBytes = int32ToBytes(ref.id, true);
        const genBytes = int32ToBytes(ref.generation, true);
        this._tempKey.set(this._key, 0);
        this._tempKey.set(idBytes.slice(0, 3), this._n);
        this._tempKey.set(genBytes.slice(0, 2), this._n + 3);
        const hash = wordArrayToBytes(md5(this._tempKey));
        const n = Math.min(this._n + 5, 16);
        const key = hash.slice(0, n);
        const encrypted = wordArrayToBytes(rc4(data, key));
        return encrypted;
    }
    decrypt(data, ref) {
        return this.encrypt(data, ref);
    }
}

const PASSWORD_32_PADDING = [
    0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41,
    0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,
    0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80,
    0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A,
];
class DataCryptHandler {
    constructor(options, fileId) {
        const { filter, version, revision, permissions, encryptMetadata, keyLength, stringKeyLength, streamKeyLength, stringMethod, streamMethod, oPasswordHash, uPasswordHash, oEncPasswordHash, uEncPasswordHash, perms } = options;
        if (filter !== "/Standard") {
            throw new Error(`Unsupported filter name: ${filter}`);
        }
        if (![1, 2, 4, 5].includes(version)) {
            throw new Error(`Unsupported algorithm version: ${version}`);
        }
        if (![2, 3, 4, 5, 6].includes(revision)) {
            throw new Error(`Unsupported algorithm revision: ${revision}`);
        }
        if (isNaN(permissions)) {
            throw new Error("Permissions not provided");
        }
        if (!oPasswordHash || !uPasswordHash) {
            throw new Error("Password hash not provided");
        }
        this._filter = filter;
        this._version = version;
        this._revision = revision;
        this._permissions = permissions;
        this._keyLength = keyLength;
        this._encryptMetadata = encryptMetadata;
        this._stringKeyLength = stringKeyLength;
        this._streamKeyLength = streamKeyLength;
        this._stringMethod = stringMethod;
        this._streamMethod = streamMethod;
        this._oPasswordHash = oPasswordHash;
        this._uPasswordHash = uPasswordHash;
        this._oEncPasswordHash = oEncPasswordHash;
        this._uEncPasswordHash = uEncPasswordHash;
        this._perms = perms;
        this._fileId = fileId;
    }
    authenticate(password) {
        const version = this._version;
        const stringMethod = this._stringMethod;
        const streamMethod = this._streamMethod;
        let owner = false;
        const ownerAuthenticated = this.authOwnerPassword(password);
        if (ownerAuthenticated) {
            owner = true;
        }
        else {
            const userAuthenticated = this.authUserPassword(password);
            if (!userAuthenticated) {
                return null;
            }
        }
        const key = this._lastEncryptionKey;
        switch (version) {
            case 1:
                const rc4_40 = new RC4DataCryptor(key);
                return {
                    owner,
                    stringCryptor: rc4_40,
                    streamCryptor: rc4_40,
                };
            case 2:
                const rc4_128 = new RC4DataCryptor(key);
                return {
                    owner,
                    stringCryptor: rc4_128,
                    streamCryptor: rc4_128,
                };
            case 4:
                let v4stringCryptor;
                if (!stringMethod || stringMethod === cryptMethods.NONE) {
                    v4stringCryptor = new IdentityDataCryptor();
                }
                else if (stringMethod === cryptMethods.RC4) {
                    v4stringCryptor = new RC4DataCryptor(key);
                }
                else if (stringMethod === cryptMethods.AES_128) {
                    v4stringCryptor = new AESV2DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${stringMethod}`);
                }
                let v4streamCryptor;
                if (!streamMethod || streamMethod === cryptMethods.NONE) {
                    v4streamCryptor = new IdentityDataCryptor();
                }
                else if (streamMethod === cryptMethods.RC4) {
                    v4streamCryptor = new RC4DataCryptor(key);
                }
                else if (streamMethod === cryptMethods.AES_128) {
                    v4streamCryptor = new AESV2DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${streamMethod}`);
                }
                return {
                    owner,
                    stringCryptor: v4stringCryptor,
                    streamCryptor: v4streamCryptor,
                };
            case 5:
                let v5stringCryptor;
                if (!stringMethod || stringMethod === cryptMethods.NONE) {
                    v4stringCryptor = new IdentityDataCryptor();
                }
                else if (stringMethod === cryptMethods.AES_256) {
                    v4stringCryptor = new AESV3DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${stringMethod}`);
                }
                let v5streamCryptor;
                if (!streamMethod || streamMethod === cryptMethods.NONE) {
                    v4streamCryptor = new IdentityDataCryptor();
                }
                else if (streamMethod === cryptMethods.AES_256) {
                    v4streamCryptor = new AESV3DataCryptor(key);
                }
                else {
                    throw new Error(`Invalid crypt method: ${streamMethod}`);
                }
                return {
                    owner,
                    stringCryptor: v5stringCryptor,
                    streamCryptor: v5streamCryptor,
                };
        }
    }
    padPassword32(password) {
        if (!password) {
            return new Uint8Array(PASSWORD_32_PADDING);
        }
        const bytes = new TextEncoder().encode(password);
        const padded = new Uint8Array(32);
        padded.set(bytes.slice(0, 32));
        if (bytes.length < 32) {
            padded.set(PASSWORD_32_PADDING.slice(0, 32 - bytes.length), bytes.length);
        }
        return padded;
    }
    computeEncryptionKey(password) {
        if ([2, 3, 4].includes(this._revision)) {
            const paddedPassword = this.padPassword32(password);
            const permissionsLe = int32ToBytes(this._permissions, true);
            const metadata = this._revision >= 4 && !this._encryptMetadata
                ? new Uint8Array([255, 255, 255, 255])
                : new Uint8Array(0);
            const dataToHash = new Uint8Array([
                ...paddedPassword,
                ...this._oPasswordHash,
                ...permissionsLe,
                ...this._fileId,
                ...metadata,
            ]);
            let hash = wordArrayToBytes(md5(dataToHash));
            const keyLength = this._keyLength >> 3;
            if (this._revision >= 3) {
                for (let i = 0; i < 50; i++) {
                    hash = wordArrayToBytes(md5(hash.slice(0, keyLength)));
                }
            }
            const encryptionKey = hash.slice(0, keyLength);
            this._lastEncryptionKey = encryptionKey;
            return encryptionKey;
        }
        else if (this._revision === 5) {
            throw new Error("Not implemented yet");
        }
        else if (this._revision === 6) {
            throw new Error("Not implemented yet");
        }
    }
    computeOHashEncryptionKey_R2R3R4(password) {
        const paddedPassword = this.padPassword32(password);
        let hash = md5(paddedPassword);
        if (this._revision >= 3) {
            for (let i = 0; i < 50; i++) {
                hash = md5(hash);
            }
        }
        const hashArray = wordArrayToBytes(hash);
        const keyLength = this._keyLength >> 3;
        return hashArray.slice(0, keyLength);
    }
    computeOHash_R2R3R4(oPassword, uPassword) {
        const key = this.computeOHashEncryptionKey_R2R3R4(oPassword || uPassword);
        const paddedUPassword = this.padPassword32(uPassword);
        let hash = rc4(paddedUPassword, key);
        if (this._revision >= 3) {
            for (let i = 1; i < 20; i++) {
                hash = rc4(hash, xorBytes(key, i));
            }
        }
        return wordArrayToBytes(hash);
    }
    computeUHash_R2(password) {
        const key = this.computeEncryptionKey(password);
        const padding = new Uint8Array(PASSWORD_32_PADDING);
        const u = wordArrayToBytes(rc4(padding, key));
        return u;
    }
    computeUHash_R3R4(password) {
        const key = this.computeEncryptionKey(password);
        const dataToHash = new Uint8Array([
            ...PASSWORD_32_PADDING,
            ...this._fileId,
        ]);
        let hash = md5(dataToHash);
        hash = rc4(hash, key);
        for (let i = 1; i < 20; i++) {
            hash = rc4(hash, xorBytes(key, i));
        }
        return wordArrayToBytes(hash);
    }
    authOwnerPassword(password) {
        if ([2, 3, 4].includes(this._revision)) {
            const ownerEncryptionKey = this.computeOHashEncryptionKey_R2R3R4(password);
            let userPasswordPadded;
            if (this._revision === 2) {
                userPasswordPadded = wordArrayToBytes(rc4(this._oPasswordHash, ownerEncryptionKey));
            }
            else {
                let hash = toWordArray(this._oPasswordHash);
                for (let i = 19; i >= 0; i--) {
                    hash = rc4(hash, xorBytes(ownerEncryptionKey, i));
                }
                userPasswordPadded = wordArrayToBytes(hash);
            }
            const j = findSubarrayIndex(userPasswordPadded, new Uint8Array(PASSWORD_32_PADDING));
            const userPassword = new TextDecoder().decode(j === -1
                ? userPasswordPadded
                : userPasswordPadded.subarray(0, j));
            return this.authUserPassword(userPassword);
        }
        else if (this._revision === 5) {
            throw new Error("Not implemented yet");
        }
        else if (this._revision === 6) {
            throw new Error("Not implemented yet");
        }
    }
    authUserPassword(password) {
        let u;
        if (this._revision === 2) {
            u = this.computeUHash_R2(password);
            return arraysEqual(this._uPasswordHash, u);
        }
        else if (this._revision === 3 || this._revision === 4) {
            u = this.computeUHash_R3R4(password);
            return arraysEqual(this._uPasswordHash.subarray(0, 16), u);
        }
        else if (this._revision === 5) {
            throw new Error("Not implemented yet");
        }
        else if (this._revision === 6) {
            throw new Error("Not implemented yet");
        }
    }
}

class DataParser {
    constructor(data) {
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new Error("Data is empty");
        }
        this._data = data;
        this._maxIndex = data.length - 1;
    }
    get maxIndex() {
        return this._maxIndex;
    }
    getPdfVersion() {
        var _a;
        const i = this.findSubarrayIndex(keywordCodes.VERSION);
        if (!i) {
            throw new Error("PDF not valid. Version not found");
        }
        const version = (_a = this.parseNumberAt(i.end + 1, true)) === null || _a === void 0 ? void 0 : _a.value;
        if (!version) {
            throw new Error("Error parsing version number");
        }
        return version.toFixed(1);
    }
    getLastXrefIndex() {
        const xrefStartIndex = this.findSubarrayIndex(keywordCodes.XREF_START, { maxIndex: this.maxIndex, direction: "reverse" });
        if (!xrefStartIndex) {
            return null;
        }
        const xrefIndex = this.parseNumberAt(xrefStartIndex.end + 1);
        if (!xrefIndex) {
            return null;
        }
        return xrefIndex;
    }
    findSubarrayIndex(sub, options) {
        var _a, _b;
        const arr = this._data;
        if (!(sub === null || sub === void 0 ? void 0 : sub.length)) {
            return null;
        }
        const direction = (options === null || options === void 0 ? void 0 : options.direction) || "straight";
        const minIndex = Math.max(Math.min((_a = options === null || options === void 0 ? void 0 : options.minIndex) !== null && _a !== void 0 ? _a : 0, this._maxIndex), 0);
        const maxIndex = Math.max(Math.min((_b = options === null || options === void 0 ? void 0 : options.maxIndex) !== null && _b !== void 0 ? _b : this._maxIndex, this._maxIndex), 0);
        const allowOpened = !(options === null || options === void 0 ? void 0 : options.closedOnly);
        let i = direction === "straight"
            ? minIndex
            : maxIndex;
        let j;
        if (direction === "straight") {
            outer_loop: for (i; i <= maxIndex; i++) {
                for (j = 0; j < sub.length; j++) {
                    if (arr[i + j] !== sub[j]) {
                        continue outer_loop;
                    }
                }
                if (allowOpened || !isRegularChar(arr[i + j])) {
                    return { start: i, end: i + j - 1 };
                }
            }
        }
        else {
            const subMaxIndex = sub.length - 1;
            outer_loop: for (i; i >= minIndex; i--) {
                for (j = 0; j < sub.length; j++) {
                    if (arr[i - j] !== sub[subMaxIndex - j]) {
                        continue outer_loop;
                    }
                }
                if (allowOpened || !isRegularChar(arr[i - j])) {
                    return { start: i - j + 1, end: i };
                }
            }
        }
        return null;
    }
    findCharIndex(charCode, direction = "straight", start) {
        return this.findSingleCharIndex((value) => charCode === value, direction, start);
    }
    findNewLineIndex(direction = "straight", start) {
        let lineBreakIndex = this.findSingleCharIndex((value) => value === codes.CARRIAGE_RETURN || value === codes.LINE_FEED, direction, start);
        if (lineBreakIndex === -1) {
            return -1;
        }
        if (direction === "straight") {
            if (this._data[lineBreakIndex] === codes.CARRIAGE_RETURN
                && this._data[lineBreakIndex + 1] === codes.LINE_FEED) {
                lineBreakIndex++;
            }
            return Math.min(lineBreakIndex + 1, this._maxIndex);
        }
        else {
            if (this._data[lineBreakIndex] === codes.LINE_FEED
                && this._data[lineBreakIndex - 1] === codes.CARRIAGE_RETURN) {
                lineBreakIndex--;
            }
            return Math.max(lineBreakIndex - 1, 0);
        }
    }
    findSpaceIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => SPACE_CHARS.has(value), direction, start);
    }
    findNonSpaceIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => !SPACE_CHARS.has(value), direction, start);
    }
    findDelimiterIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => DELIMITER_CHARS.has(value), direction, start);
    }
    findNonDelimiterIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => !DELIMITER_CHARS.has(value), direction, start);
    }
    findIrregularIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => !isRegularChar(value), direction, start);
    }
    findRegularIndex(direction = "straight", start) {
        return this.findSingleCharIndex((value) => isRegularChar(value), direction, start);
    }
    getValueTypeAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        const arr = this._data;
        const i = start;
        const charCode = arr[i];
        switch (charCode) {
            case codes.SLASH:
                if (isRegularChar(arr[i + 1])) {
                    return valueTypes.NAME;
                }
                return valueTypes.UNKNOWN;
            case codes.L_BRACKET:
                return valueTypes.ARRAY;
            case codes.L_PARENTHESE:
                return valueTypes.STRING_LITERAL;
            case codes.LESS:
                if (codes.LESS === arr[i + 1]) {
                    return valueTypes.DICTIONARY;
                }
                return valueTypes.STRING_HEX;
            case codes.PERCENT:
                return valueTypes.COMMENT;
            case codes.D_0:
            case codes.D_1:
            case codes.D_2:
            case codes.D_3:
            case codes.D_4:
            case codes.D_5:
            case codes.D_6:
            case codes.D_7:
            case codes.D_8:
            case codes.D_9:
                const nextDelimIndex = this.findDelimiterIndex("straight", i + 1);
                if (nextDelimIndex !== -1) {
                    const refEndIndex = this.findCharIndex(codes.R, "reverse", nextDelimIndex - 1);
                    if (refEndIndex !== -1 && refEndIndex > i && !isRegularChar(arr[refEndIndex + 1])) {
                        return valueTypes.REF;
                    }
                }
                return valueTypes.NUMBER;
            case codes.DOT:
            case codes.MINUS:
                if (isDigit(arr[i + 1])) {
                    return valueTypes.NUMBER;
                }
                return valueTypes.UNKNOWN;
            case codes.s:
                if (arr[i + 1] === codes.t
                    && arr[i + 2] === codes.r
                    && arr[i + 3] === codes.e
                    && arr[i + 4] === codes.a
                    && arr[i + 5] === codes.m) {
                    return valueTypes.STREAM;
                }
                return valueTypes.UNKNOWN;
            case codes.t:
                if (arr[i + 1] === codes.r
                    && arr[i + 2] === codes.u
                    && arr[i + 3] === codes.e) {
                    return valueTypes.BOOLEAN;
                }
                return valueTypes.UNKNOWN;
            case codes.f:
                if (arr[i + 1] === codes.a
                    && arr[i + 2] === codes.l
                    && arr[i + 3] === codes.s
                    && arr[i + 4] === codes.e) {
                    return valueTypes.BOOLEAN;
                }
                return valueTypes.UNKNOWN;
            default:
                return valueTypes.UNKNOWN;
        }
    }
    getIndirectObjectBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        const objStartIndex = this.findSubarrayIndex(keywordCodes.OBJ, { minIndex: start, closedOnly: true });
        if (!objStartIndex) {
            return null;
        }
        let contentStart = this.findNonSpaceIndex("straight", objStartIndex.end + 1);
        if (contentStart === -1) {
            return null;
        }
        const objEndIndex = this.findSubarrayIndex(keywordCodes.OBJ_END, { minIndex: contentStart, closedOnly: true });
        if (!objEndIndex) {
            return null;
        }
        let contentEnd = this.findNonSpaceIndex("reverse", objEndIndex.start - 1);
        if (this.getCharCode(contentStart) === codes.LESS
            && this.getCharCode(contentStart + 1) === codes.LESS
            && this.getCharCode(contentEnd - 1) === codes.GREATER
            && this.getCharCode(contentEnd) === codes.GREATER) {
            contentStart += 2;
            contentEnd -= 2;
        }
        return {
            start: objStartIndex.start,
            end: objEndIndex.end,
            contentStart,
            contentEnd,
        };
    }
    getXrefTableBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this._data[start] !== codes.x) {
            return null;
        }
        const xrefStart = this.findSubarrayIndex(keywordCodes.XREF_TABLE, { minIndex: start });
        if (!xrefStart) {
            return null;
        }
        const contentStart = this.findNonSpaceIndex("straight", xrefStart.end + 1);
        if (contentStart === -1) {
            return null;
        }
        const xrefEnd = this.findSubarrayIndex(keywordCodes.TRAILER, { minIndex: xrefStart.end + 1 });
        if (!xrefEnd) {
            return null;
        }
        const contentEnd = this.findNonSpaceIndex("reverse", xrefEnd.start - 1);
        if (contentEnd < contentStart) {
            return null;
        }
        return {
            start: xrefStart.start,
            end: xrefEnd.end,
            contentStart,
            contentEnd,
        };
    }
    getDictBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)
            || this._data[start] !== codes.LESS
            || this._data[start + 1] !== codes.LESS) {
            return null;
        }
        const contentStart = this.findNonSpaceIndex("straight", start + 2);
        if (contentStart === -1) {
            return null;
        }
        let dictOpened = 1;
        let dictBound = true;
        let literalOpened = 0;
        let i = contentStart;
        let code;
        let prevCode;
        while (dictOpened) {
            prevCode = code;
            code = this._data[i++];
            if (code === codes.L_PARENTHESE
                && (!literalOpened || prevCode !== codes.BACKSLASH)) {
                literalOpened++;
            }
            if (code === codes.R_PARENTHESE
                && (literalOpened && prevCode !== codes.BACKSLASH)) {
                literalOpened--;
            }
            if (literalOpened) {
                continue;
            }
            if (!dictBound) {
                if (code === codes.LESS && code === prevCode) {
                    dictOpened++;
                    dictBound = true;
                }
                else if (code === codes.GREATER && code === prevCode) {
                    dictOpened--;
                    dictBound = true;
                }
            }
            else {
                dictBound = false;
            }
        }
        const end = i - 1;
        const contentEnd = this.findNonSpaceIndex("reverse", end - 2);
        if (contentEnd < contentStart) {
            return {
                start,
                end,
            };
        }
        return {
            start,
            end,
            contentStart,
            contentEnd,
        };
    }
    getArrayBoundsAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this._data[start] !== codes.L_BRACKET) {
            return null;
        }
        let subArrayOpened = 0;
        let i = start + 1;
        let code;
        while (subArrayOpened || code !== codes.R_BRACKET) {
            code = this._data[i++];
            if (code === codes.L_BRACKET) {
                subArrayOpened++;
            }
            else if (subArrayOpened && code === codes.R_BRACKET) {
                subArrayOpened--;
            }
        }
        const arrayEnd = i - 1;
        if (arrayEnd - start < 1) {
            return null;
        }
        return { start, end: arrayEnd };
    }
    getHexBounds(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this.getCharCode(start) !== codes.LESS) {
            return null;
        }
        const end = this.findCharIndex(codes.GREATER, "straight", start + 1);
        if (end === -1) {
            return null;
        }
        return { start, end };
    }
    getLiteralBounds(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this.getCharCode(start) !== codes.L_PARENTHESE) {
            return null;
        }
        let i = start + 1;
        let prevCode;
        let code;
        let opened = 0;
        while (opened || code !== codes.R_PARENTHESE || prevCode === codes.BACKSLASH) {
            if (i > this._maxIndex) {
                return null;
            }
            if (!isNaN(code)) {
                prevCode = code;
            }
            code = this.getCharCode(i++);
            if (prevCode !== codes.BACKSLASH) {
                if (code === codes.L_PARENTHESE) {
                    opened += 1;
                }
                else if (opened && code === codes.R_PARENTHESE) {
                    opened -= 1;
                }
            }
        }
        return { start, end: i - 1 };
    }
    parseNumberAt(start, float = false, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || !isRegularChar(this._data[start])) {
            return null;
        }
        let i = start;
        let numberStr = "";
        let value = this._data[i];
        if (value === codes.MINUS) {
            numberStr += "-";
            value = this._data[++i];
        }
        else if (value === codes.DOT) {
            numberStr += "0.";
            value = this._data[++i];
        }
        while (DIGIT_CHARS.has(value)
            || (float && value === codes.DOT)) {
            numberStr += String.fromCharCode(value);
            value = this._data[++i];
        }
        return numberStr
            ? { value: +numberStr, start, end: i - 1 }
            : null;
    }
    parseNameAt(start, includeSlash = true, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start) || this._data[start] !== codes.SLASH) {
            return null;
        }
        let i = start + 1;
        let result = includeSlash
            ? "/"
            : "";
        let value = this._data[i];
        while (isRegularChar(value)) {
            result += String.fromCharCode(value);
            value = this._data[++i];
        }
        return result.length > 1
            ? { value: result, start, end: i - 1 }
            : null;
    }
    parseStringAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        let i = start;
        let result = "";
        let value = this._data[i];
        while (isRegularChar(value)) {
            result += String.fromCharCode(value);
            value = this._data[++i];
        }
        return result.length !== 0
            ? { value: result, start, end: i - 1 }
            : null;
    }
    parseBoolAt(start, skipEmpty = true) {
        if (skipEmpty) {
            start = this.skipEmpty(start);
        }
        if (this.isOutside(start)) {
            return null;
        }
        const isTrue = this.findSubarrayIndex(keywordCodes.TRUE, { minIndex: start });
        if (isTrue) {
            return { value: true, start, end: isTrue.end };
        }
        const isFalse = this.findSubarrayIndex(keywordCodes.FALSE, { minIndex: start });
        if (isFalse) {
            return { value: true, start, end: isFalse.end };
        }
        return null;
    }
    parseNumberArrayAt(start, float = true, skipEmpty = true) {
        const arrayBounds = this.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const numbers = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = this.parseNumberAt(i, float, true);
            if (!current) {
                break;
            }
            numbers.push(current.value);
            i = current.end + 1;
        }
        return { value: numbers, start: arrayBounds.start, end: arrayBounds.end };
    }
    parseNameArrayAt(start, includeSlash = true, skipEmpty = true) {
        const arrayBounds = this.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const names = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = this.parseNameAt(i, includeSlash, true);
            if (!current) {
                break;
            }
            names.push(current.value);
            i = current.end + 1;
        }
        return { value: names, start: arrayBounds.start, end: arrayBounds.end };
    }
    parseDictType(bounds) {
        return this.parseDictNameProperty(keywordCodes.TYPE, bounds);
    }
    parseDictSubtype(bounds) {
        return this.parseDictNameProperty(keywordCodes.SUBTYPE, bounds);
    }
    parseDictNameProperty(subarray, bounds) {
        const typeProp = this.findSubarrayIndex(subarray, { minIndex: bounds.start, maxIndex: bounds.end });
        if (!typeProp) {
            return null;
        }
        const type = this.parseNameAt(typeProp.end + 1);
        if (!type) {
            return null;
        }
        return type.value;
    }
    skipEmpty(start) {
        let index = this.findNonSpaceIndex("straight", start);
        if (index === -1) {
            return -1;
        }
        if (this._data[index] === codes.PERCENT) {
            const afterComment = this.findNewLineIndex("straight", index + 1);
            if (afterComment === -1) {
                return -1;
            }
            index = this.findNonSpaceIndex("straight", afterComment);
        }
        return index;
    }
    skipToNextName(start, max) {
        start || (start = 0);
        max = max
            ? Math.min(max, this._maxIndex)
            : 0;
        if (max < start) {
            return -1;
        }
        let i = start;
        while (i <= max) {
            const value = this.getValueTypeAt(i, true);
            if (value) {
                let skipValueBounds;
                switch (value) {
                    case valueTypes.DICTIONARY:
                        skipValueBounds = this.getDictBoundsAt(i, false);
                        break;
                    case valueTypes.ARRAY:
                        skipValueBounds = this.getArrayBoundsAt(i, false);
                        break;
                    case valueTypes.STRING_LITERAL:
                        skipValueBounds = this.getLiteralBounds(i, false);
                        break;
                    case valueTypes.STRING_HEX:
                        skipValueBounds = this.getHexBounds(i, false);
                        break;
                    case valueTypes.NUMBER:
                        const numberParseResult = this.parseNumberAt(i, true, false);
                        if (numberParseResult) {
                            skipValueBounds = numberParseResult;
                        }
                        break;
                    case valueTypes.BOOLEAN:
                        const boolParseResult = this.parseBoolAt(i, false);
                        if (boolParseResult) {
                            skipValueBounds = boolParseResult;
                        }
                        break;
                    case valueTypes.COMMENT:
                        break;
                    case valueTypes.NAME:
                        return i;
                    default:
                        i++;
                        continue;
                }
                if (skipValueBounds) {
                    i = skipValueBounds.end + 1;
                    skipValueBounds = null;
                    continue;
                }
            }
            i++;
        }
        return -1;
    }
    getCharCode(index) {
        return this._data[index];
    }
    getChar(index) {
        const code = this._data[index];
        if (!isNaN(code)) {
            return String.fromCharCode(code);
        }
        return null;
    }
    sliceCharCodes(start, end) {
        return this._data.slice(start, (end || start) + 1);
    }
    sliceChars(start, end) {
        return String.fromCharCode(...this._data.slice(start, (end || start) + 1));
    }
    subCharCodes(start, end) {
        return this._data.subarray(start, (end || start) + 1);
    }
    isOutside(index) {
        return (index < 0 || index > this._maxIndex);
    }
    findSingleCharIndex(filter, direction = "straight", start) {
        const arr = this._data;
        let i = isNaN(start)
            ? direction === "straight"
                ? 0
                : this._maxIndex
            : start;
        if (direction === "straight") {
            for (i; i <= this._maxIndex; i++) {
                if (filter(arr[i])) {
                    return i;
                }
            }
        }
        else {
            for (i; i >= 0; i--) {
                if (filter(arr[i])) {
                    return i;
                }
            }
        }
        return -1;
    }
}

class XRefEntry {
    constructor(type, id, generation, byteOffset, nextFreeId, streamId, streamIndex) {
        this.type = type;
        this.id = id;
        this.generation = generation;
        this.byteOffset = byteOffset;
        this.nextFreeId = nextFreeId;
        this.streamId = streamId;
        this.streamIndex = streamIndex;
    }
    static *fromTableBytes(bytes) {
        let i = 0;
        let j = 0;
        while (i < bytes.length) {
            const firstIndexBytes = [];
            let firstIndexDigit = bytes[i++];
            while (DIGIT_CHARS.has(firstIndexDigit)) {
                firstIndexBytes.push(firstIndexDigit);
                firstIndexDigit = bytes[i++];
            }
            let firstIndex = parseInt(firstIndexBytes.map(x => String.fromCharCode(x)).join(""), 10);
            const countBytes = [];
            let countDigit = bytes[i++];
            while (DIGIT_CHARS.has(countDigit)) {
                countBytes.push(countDigit);
                countDigit = bytes[i++];
            }
            const count = parseInt(countBytes.map(x => String.fromCharCode(x)).join(""), 10);
            while (!DIGIT_CHARS.has(bytes[i])) {
                i++;
            }
            for (j = 0; j < count; j++) {
                const value = parseInt(Array.from(bytes.subarray(i, i + 10))
                    .map(x => String.fromCharCode(x)).join(""), 10);
                i += 11;
                const gen = parseInt(Array.from(bytes.subarray(i, i + 5))
                    .map(x => String.fromCharCode(x)).join(""), 10);
                i += 6;
                const typeByte = bytes[i];
                if (typeByte === codes.f) {
                    yield new XRefEntry(xRefEntryTypes.FREE, firstIndex++, gen, null, value);
                }
                else if (typeByte === codes.n) {
                    yield new XRefEntry(xRefEntryTypes.NORMAL, firstIndex++, gen, value);
                }
                i += 3;
            }
        }
        return;
    }
    static *fromStreamBytes(bytes, w, index) {
        const [w1, w2, w3] = w;
        const entryLength = w1 + w2 + w3;
        if (bytes.length % entryLength) {
            throw new Error("Incorrect stream length");
        }
        const count = bytes.length / entryLength;
        const ids = new Array(count);
        if (index === null || index === void 0 ? void 0 : index.length) {
            let id;
            let n;
            let m = 0;
            for (let k = 0; k < index.length; k++) {
                if (!(k % 2)) {
                    id = index[k];
                }
                else {
                    for (n = 0; n < index[k]; n++) {
                        ids[m++] = id + n;
                    }
                }
            }
        }
        else {
            let l = 0;
            while (l < count) {
                ids[l++] = l;
            }
        }
        let i = 0;
        let j = 0;
        let type;
        let value1;
        let value2;
        while (i < bytes.length) {
            type = w1
                ? parseIntFromBytes(bytes.slice(i, i + w1))
                : 1;
            i += w1;
            value1 = parseIntFromBytes(bytes.slice(i, i + w2));
            i += w2;
            value2 = w3
                ? parseIntFromBytes(bytes.slice(i, i + w3))
                : null;
            i += w3;
            switch (type) {
                case xRefEntryTypes.FREE:
                    yield new XRefEntry(xRefEntryTypes.FREE, ids[j++], value2 !== null && value2 !== void 0 ? value2 : maxGeneration, null, value1);
                    break;
                case xRefEntryTypes.NORMAL:
                    yield new XRefEntry(xRefEntryTypes.NORMAL, ids[j++], value2 !== null && value2 !== void 0 ? value2 : 0, value1);
                    break;
                case xRefEntryTypes.COMPRESSED:
                    yield new XRefEntry(xRefEntryTypes.COMPRESSED, ids[j++], 0, null, null, value1, value2);
                    break;
            }
        }
        return;
    }
    static toTableBytes(entries) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length)) {
            return null;
        }
        const encoder = new TextEncoder();
        const groups = this.groupEntries(entries);
        let bytes = new Uint8Array();
        let temp;
        let line;
        for (const group of groups) {
            line = `${group[0]} ${group[1].length}\r\n`;
            temp = new Uint8Array(bytes.length + line.length);
            temp.set(bytes);
            temp.set(encoder.encode(line), bytes.length);
            bytes = temp;
            for (const entry of group[1]) {
                switch (entry.type) {
                    case xRefEntryTypes.FREE:
                        line = `${entry.nextFreeId.toString().padStart(10, "0")} ${entry.generation.toString().padStart(5, "0")} f\r\n`;
                        break;
                    case xRefEntryTypes.NORMAL:
                        line = `${entry.byteOffset.toString().padStart(10, "0")} ${entry.generation.toString().padStart(5, "0")} n\r\n`;
                        break;
                    default:
                        continue;
                }
                temp = new Uint8Array(bytes.length + line.length);
                temp.set(bytes);
                temp.set(encoder.encode(line), bytes.length);
                bytes = temp;
            }
        }
        return bytes;
    }
    static toStreamBytes(entries, w = [1, 4, 2]) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length)) {
            return null;
        }
        if (Math.min(...w) < 0) {
            throw new Error("Negative length values are not permitted");
        }
        let [w1, w2, w3] = w;
        w1 !== null && w1 !== void 0 ? w1 : (w1 = 0);
        w2 !== null && w2 !== void 0 ? w2 : (w2 = 4);
        w3 !== null && w3 !== void 0 ? w3 : (w3 = 0);
        const entryLength = w1 + w2 + w3;
        let w1ToBytesFunc;
        let w2ToBytesFunc;
        let w3ToBytesFunc;
        switch (w1) {
            case 0:
                w1ToBytesFunc = () => new Uint8Array();
                break;
            case 1:
                w1ToBytesFunc = int8ToBytes;
                break;
            case 2:
                w1ToBytesFunc = int16ToBytes;
                break;
            default:
                w2ToBytesFunc = (n) => new Uint8Array([...new Array(w1 - 2).fill(0), ...int16ToBytes(n)]);
                break;
        }
        switch (w2) {
            case 1:
                w2ToBytesFunc = int8ToBytes;
                break;
            case 2:
                w2ToBytesFunc = int16ToBytes;
                break;
            case 3:
                w2ToBytesFunc = (n) => new Uint8Array([0, ...int16ToBytes(n)]);
                break;
            case 4:
                w2ToBytesFunc = int32ToBytes;
                break;
            default:
                w2ToBytesFunc = (n) => new Uint8Array([...new Array(w1 - 4).fill(0), ...int32ToBytes(n)]);
                break;
        }
        switch (w3) {
            case 0:
                w3ToBytesFunc = () => new Uint8Array();
                break;
            case 1:
                w3ToBytesFunc = int8ToBytes;
                break;
            case 2:
                w3ToBytesFunc = int16ToBytes;
                break;
            default:
                w2ToBytesFunc = (n) => new Uint8Array([...new Array(w1 - 2).fill(0), ...int16ToBytes(n)]);
                break;
        }
        new TextEncoder();
        const groups = this.groupEntries(entries);
        const index = [];
        let bytes = new Uint8Array();
        let temp;
        let entryV1;
        let entryV2;
        let entryV3;
        for (const group of groups) {
            index.push(group[0], group[1].length);
            for (const entry of group[1]) {
                switch (entry.type) {
                    case xRefEntryTypes.FREE:
                        entryV1 = w1ToBytesFunc(0);
                        entryV2 = w2ToBytesFunc(entry.nextFreeId);
                        entryV3 = w3ToBytesFunc(entry.generation);
                        break;
                    case xRefEntryTypes.NORMAL:
                        entryV1 = w1ToBytesFunc(1);
                        entryV2 = w2ToBytesFunc(entry.byteOffset);
                        entryV3 = w3ToBytesFunc(entry.generation);
                        break;
                    case xRefEntryTypes.COMPRESSED:
                        entryV1 = w1ToBytesFunc(2);
                        entryV2 = w2ToBytesFunc(entry.streamId);
                        entryV3 = w3ToBytesFunc(entry.streamIndex);
                        break;
                    default:
                        continue;
                }
                temp = new Uint8Array(bytes.length + entryLength);
                temp.set(bytes);
                temp.set(entryV1, bytes.length);
                temp.set(entryV2, bytes.length + w1);
                temp.set(entryV3, bytes.length + w1 + w2);
                bytes = temp;
            }
        }
        return { bytes, index };
    }
    static groupEntries(entries) {
        entries.sort((a, b) => a.id - b.id);
        const groups = [];
        let groupStart;
        let groupEntries;
        let last;
        for (const entry of entries) {
            if (entry.id !== last + 1) {
                if (groupEntries === null || groupEntries === void 0 ? void 0 : groupEntries.length) {
                    groups.push([groupStart, groupEntries]);
                }
                groupStart = entry.id;
                groupEntries = [entry];
            }
            else {
                groupEntries.push(entry);
            }
            last = entry.id;
        }
        if (groupEntries === null || groupEntries === void 0 ? void 0 : groupEntries.length) {
            groups.push([groupStart, groupEntries]);
        }
        return groups;
    }
}

class ReferenceData {
    constructor(xrefs) {
        var _a;
        const allFreeEntries = [];
        const allNormalEntries = [];
        const allCompressedEntries = [];
        let maxId = 0;
        xrefs.forEach(x => {
            for (const entry of x.getEntries()) {
                switch (entry.type) {
                    case xRefEntryTypes.FREE:
                        allFreeEntries.push(entry);
                        break;
                    case xRefEntryTypes.NORMAL:
                        allNormalEntries.push(entry);
                        break;
                    case xRefEntryTypes.COMPRESSED:
                        allCompressedEntries.push(entry);
                        break;
                    default:
                        continue;
                }
                if (entry.id > maxId) {
                    maxId = entry.id;
                }
            }
        });
        this.size = maxId + 1;
        const zeroFreeRef = {
            id: 0,
            generation: maxGeneration,
            nextFreeId: 0,
        };
        const freeLinkedList = new LinkedList(zeroFreeRef);
        const freeOutsideListMap = new Map();
        const freeMap = new Map();
        let zeroFound = false;
        for (const entry of allFreeEntries) {
            if (!zeroFound && entry.id === 0) {
                zeroFound = true;
                zeroFreeRef.nextFreeId = entry.nextFreeId;
                continue;
            }
            const valueFromMap = freeMap.get(entry.id);
            if (!valueFromMap || valueFromMap.generation < entry.generation) {
                freeMap.set(entry.id, {
                    id: entry.id,
                    generation: entry.generation,
                    nextFreeId: entry.nextFreeId
                });
            }
        }
        let nextId = zeroFreeRef.nextFreeId;
        let next;
        while (nextId) {
            next = freeMap.get(nextId);
            freeMap.delete(nextId);
            freeLinkedList.push(next);
            nextId = next.nextFreeId;
        }
        [...freeMap].forEach(x => {
            const value = x[1];
            if (value.generation === maxGeneration && value.nextFreeId === 0) {
                freeOutsideListMap.set(value.id, value);
            }
        });
        this.freeLinkedList = freeLinkedList;
        this.freeOutsideListMap = freeOutsideListMap;
        const normalRefs = new Map();
        for (const entry of allNormalEntries) {
            if (this.isFreed(entry)) {
                continue;
            }
            const valueFromMap = normalRefs.get(entry.id);
            if (valueFromMap && valueFromMap.generation >= entry.generation) {
                continue;
            }
            normalRefs.set(entry.id, {
                id: entry.id,
                generation: entry.generation,
                byteOffset: entry.byteOffset,
            });
        }
        for (const entry of allCompressedEntries) {
            if (this.isFreed(entry)) {
                continue;
            }
            const valueFromMap = normalRefs.get(entry.id);
            if (valueFromMap) {
                continue;
            }
            const offset = (_a = normalRefs.get(entry.streamId)) === null || _a === void 0 ? void 0 : _a.byteOffset;
            if (offset) {
                normalRefs.set(entry.id, {
                    id: entry.id,
                    generation: entry.generation,
                    byteOffset: offset,
                    compressed: true,
                    streamId: entry.streamId,
                    streamIndex: entry.streamIndex,
                });
            }
        }
        this.usedMap = normalRefs;
    }
    getOffset(id) {
        var _a;
        return (_a = this.usedMap.get(id)) === null || _a === void 0 ? void 0 : _a.byteOffset;
    }
    getGeneration(id) {
        var _a;
        return (_a = this.usedMap.get(id)) === null || _a === void 0 ? void 0 : _a.generation;
    }
    isFreed(ref) {
        return this.freeOutsideListMap.has(ref.id)
            || this.freeLinkedList.has(ref, (a, b) => a.id === b.id && a.generation < b.generation);
    }
    isUsed(id) {
        return this.usedMap.has(id);
    }
}
class ReferenceDataChange {
    constructor(refData) {
        this._refData = refData;
        this._size = refData.size;
        const freeLinkedList = new LinkedList();
        for (const freeRef of refData.freeLinkedList) {
            freeLinkedList.push(Object.assign({}, freeRef));
        }
        this._freeLinkedList = freeLinkedList;
        this._usedMap = new Map();
    }
    get size() {
        return this._size;
    }
    takeFreeRef(byteOffset, forceNew = false) {
        let ref;
        if (!forceNew && this._freeLinkedList.length > 1) {
            const freeRef = this._freeLinkedList.pop();
            this._freeLinkedList.tail.nextFreeId = 0;
            ref = {
                id: freeRef.id,
                generation: freeRef.generation,
                byteOffset,
            };
        }
        else {
            ref = {
                id: this._size++,
                generation: 0,
                byteOffset,
            };
        }
        this._usedMap.set(ref.id, ref);
        return ref;
    }
    setRefFree(id) {
        if (this._usedMap.has(id)) {
            this._usedMap.delete(id);
            if (this._size > this._refData.size && this._size === id + 1) {
                this._size--;
            }
        }
        if (this._refData.isUsed(id)) {
            const gen = this._refData.getGeneration(id);
            const ref = { id: id, generation: gen + 1, nextFreeId: 0 };
            const index = this._freeLinkedList.findIndex(ref, (a, b) => a.id === b.id && a.generation <= b.generation);
            if (index !== -1) {
                return;
            }
            const lastFreeRef = this._freeLinkedList.tail;
            lastFreeRef.nextFreeId = id;
            this._freeLinkedList.push(ref);
        }
    }
    updateUsedRef(ref) {
        if (ref.compressed && ref.generation) {
            throw new Error(`Compressed ref generation can't be greater than zero: '${ref.id} ${ref.generation} R'`);
        }
        if (this.isFreed(ref)) {
            throw new Error(`The reference is freed: '${ref.id} ${ref.generation} R'`);
        }
        const current = this._usedMap.get(ref.id);
        if (current) {
            throw new Error(`Same reference has been issued twice: '${current.id} ${current.generation} R'`);
        }
        if (this._refData.isUsed(ref.id)) {
            const gen = this._refData.getGeneration(ref.id);
            if (ref.generation >= gen) {
                this._usedMap.set(ref.id, ref);
                return true;
            }
            throw new Error(`The reference has an old generation: '${current.id} ${current.generation} R'`);
        }
        throw new Error(`The reference is not used: '${current.id} ${current.generation} R'`);
    }
    exportEntries() {
        const entries = [];
        for (const entry of this._freeLinkedList) {
            entries.push(new XRefEntry(xRefEntryTypes.FREE, entry.id, entry.generation, null, entry.nextFreeId));
        }
        this._usedMap.forEach(v => {
            if (v.compressed) {
                entries.push(new XRefEntry(xRefEntryTypes.COMPRESSED, v.id, 0, null, null, v.streamId, v.streamIndex));
            }
            else {
                entries.push(new XRefEntry(xRefEntryTypes.NORMAL, v.id, v.generation, v.byteOffset));
            }
        });
        return entries;
    }
    isFreed(ref) {
        return this._freeLinkedList.has(ref, (a, b) => a.id === b.id && a.generation < b.generation);
    }
    isUsedInSource(id) {
        return this._refData.isUsed(id);
    }
}

class DataWriter {
    constructor(data) {
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new Error("Data is empty");
        }
        this._data = [...data];
        this._pointer = data.length;
        this._encoder = new TextEncoder();
        this.fixEof();
    }
    get offset() {
        return this._pointer;
    }
    getCurrentData() {
        return new Uint8Array(this._data);
    }
    writeBytes(bytes) {
        if (!(bytes === null || bytes === void 0 ? void 0 : bytes.length)) {
            return;
        }
        this._data.push(...bytes);
        this._pointer += bytes.length;
    }
    writeIndirectObject(cryptInfo, obj) {
        if (!(cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) || !obj) {
            return;
        }
        const objBytes = [
            ...this._encoder.encode(`${cryptInfo.ref.id} ${cryptInfo.ref.generation} `),
            ...keywordCodes.OBJ, ...keywordCodes.END_OF_LINE,
            ...obj.toArray(cryptInfo), ...keywordCodes.END_OF_LINE,
            ...keywordCodes.OBJ_END, ...keywordCodes.END_OF_LINE,
        ];
        this.writeBytes(objBytes);
    }
    writeIndirectArray(cryptInfo, objs) {
        if (!(cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) || !objs) {
            return;
        }
        const objBytes = [
            ...this._encoder.encode(`${cryptInfo.ref.id} ${cryptInfo.ref.generation} `),
            ...keywordCodes.OBJ, ...keywordCodes.END_OF_LINE,
            codes.L_BRACKET,
        ];
        for (const obj of objs) {
            objBytes.push(codes.WHITESPACE, ...obj.toArray(cryptInfo));
        }
        objBytes.push(codes.R_BRACKET, ...keywordCodes.END_OF_LINE, ...keywordCodes.OBJ_END, ...keywordCodes.END_OF_LINE);
        this.writeBytes(objBytes);
    }
    writeEof(xrefOffset) {
        const eof = [
            ...keywordCodes.XREF_START, ...keywordCodes.END_OF_LINE,
            ...this._encoder.encode(xrefOffset + ""), ...keywordCodes.END_OF_LINE,
            ...keywordCodes.END_OF_FILE, ...keywordCodes.END_OF_LINE
        ];
        this.writeBytes(eof);
    }
    fixEof() {
        if (this._data[this._pointer - 1] !== codes.LINE_FEED) {
            if (this._data[this._pointer - 2] !== codes.CARRIAGE_RETURN) {
                this._data.push(codes.CARRIAGE_RETURN, codes.LINE_FEED);
                this._pointer += 2;
            }
            else {
                this._data.push(codes.LINE_FEED);
                this._pointer += 1;
            }
        }
    }
}

class ObjectId {
    constructor(id, generation) {
        this.id = id !== null && id !== void 0 ? id : 0;
        this.generation = generation !== null && generation !== void 0 ? generation : 0;
    }
    static parse(parser, start, skipEmpty = true) {
        if (skipEmpty) {
            start = parser.findRegularIndex("straight", start);
        }
        if (start < 0 || start > parser.maxIndex) {
            return null;
        }
        const id = parser.parseNumberAt(start, false, false);
        if (!id || isNaN(id.value)) {
            return null;
        }
        const generation = parser.parseNumberAt(id.end + 2, false, false);
        if (!generation || isNaN(generation.value)) {
            return null;
        }
        return {
            value: new ObjectId(id.value, generation.value),
            start,
            end: generation.end,
        };
    }
    static parseRef(parser, start, skipEmpty = true) {
        const id = ObjectId.parse(parser, start, skipEmpty);
        if (!id) {
            return null;
        }
        const rIndexSupposed = id.end + 2;
        const rIndex = parser.findSubarrayIndex([codes.R], { minIndex: rIndexSupposed, closedOnly: true });
        if (!rIndex || rIndex.start !== rIndexSupposed) {
            return null;
        }
        return {
            value: id.value,
            start: id.start,
            end: rIndex.end,
        };
    }
    static parseRefArray(parser, start, skipEmpty = true) {
        const arrayBounds = parser.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const ids = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = ObjectId.parseRef(parser, i, true);
            if (!current) {
                break;
            }
            ids.push(current.value);
            i = current.end + 1;
        }
        return { value: ids, start: arrayBounds.start, end: arrayBounds.end };
    }
    static fromRef(ref) {
        return new ObjectId(ref.id, ref.generation);
    }
    equals(other) {
        return this.id === other.id
            && this.generation === other.generation;
    }
    toArray(cryptInfo) {
        return new TextEncoder().encode(`${this.id} ${this.generation} R`);
    }
    toString() {
        return this.id + "|" + this.generation;
    }
}

class DateString {
    constructor(source, date) {
        this._source = source;
        this._date = new Date(date);
    }
    get source() {
        return this._source;
    }
    get date() {
        return new Date(this._date);
    }
    static parse(parser, start, cryptInfo = null, skipEmpty = true) {
        if (skipEmpty) {
            start = parser.skipEmpty(start);
        }
        if (parser.isOutside(start) || parser.getCharCode(start) !== codes.L_PARENTHESE) {
            return null;
        }
        const end = parser.findCharIndex(codes.R_PARENTHESE, "straight", start);
        if (end === -1) {
            return null;
        }
        let bytes = parser.subCharCodes(start + 1, end - 1);
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.decrypt(bytes, cryptInfo.ref);
        }
        try {
            const date = DateString.fromArray(bytes);
            return { value: date, start, end };
        }
        catch (_a) {
            return null;
        }
    }
    static fromDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        const hours = String(date.getHours()).padStart(2, "0");
        const minutes = String(date.getMinutes()).padStart(2, "0");
        const seconds = String(date.getSeconds()).padStart(2, "0");
        const source = `D:${year}${month}${day}${hours}${minutes}${seconds}`;
        return new DateString(source, date);
    }
    static fromString(source) {
        const result = /D:(?<Y>\d{4})(?<M>\d{2})(?<D>\d{2})(?<h>\d{2})(?<m>\d{2})(?<s>\d{2})/.exec(source);
        const date = new Date(+result.groups.Y, +result.groups.M - 1, +result.groups.D, +result.groups.h, +result.groups.m, +result.groups.s);
        return new DateString(source, date);
    }
    static fromArray(arr) {
        const source = new TextDecoder().decode(arr);
        return DateString.fromString(source);
    }
    toArray(cryptInfo) {
        let bytes = new TextEncoder().encode(this._source);
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.encrypt(bytes, cryptInfo.ref);
        }
        return new Uint8Array([
            ...keywordCodes.STR_LITERAL_START,
            ...bytes,
            ...keywordCodes.STR_LITERAL_END,
        ]);
    }
}

class LiteralString {
    constructor(literal, bytes) {
        this._literal = literal;
        this._bytes = bytes;
    }
    get literal() {
        return this._literal;
    }
    get bytes() {
        return this._bytes.slice();
    }
    static parse(parser, start, cryptInfo = null, skipEmpty = true) {
        const bounds = parser.getLiteralBounds(start, skipEmpty);
        if (!bounds) {
            return;
        }
        let bytes = LiteralString.unescape(parser.subCharCodes(bounds.start + 1, bounds.end - 1));
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.decrypt(bytes, cryptInfo.ref);
        }
        const result = LiteralString.fromBytes(bytes);
        return { value: result, start: bounds.start, end: bounds.end };
    }
    static fromBytes(bytes) {
        const decoder = bytes[0] === 254 && bytes[1] === 255
            ? new TextDecoder("utf-16be")
            : new TextDecoder();
        const literal = decoder.decode(bytes);
        return new LiteralString(literal, bytes);
    }
    static fromString(source) {
        const bytes = [];
        bytes.push(254, 255);
        for (let i = 0; i < source.length; i++) {
            const charCode = source.charCodeAt(i);
            bytes.push((charCode & 0xFF00) >>> 8);
            bytes.push(charCode & 0xFF);
        }
        return new LiteralString(source, new Uint8Array(bytes));
    }
    static escape(bytes) {
        const result = [];
        for (let i = 0; i < bytes.length; i++) {
            switch (bytes[i]) {
                case codes.LINE_FEED:
                    result.push(codes.BACKSLASH);
                    result.push(codes.n);
                    break;
                case codes.CARRIAGE_RETURN:
                    result.push(codes.BACKSLASH);
                    result.push(codes.r);
                    break;
                case codes.HORIZONTAL_TAB:
                    result.push(codes.BACKSLASH);
                    result.push(codes.t);
                    break;
                case codes.BACKSPACE:
                    result.push(codes.BACKSLASH);
                    result.push(codes.b);
                    break;
                case codes.FORM_FEED:
                    result.push(codes.BACKSLASH);
                    result.push(codes.f);
                    break;
                case codes.L_PARENTHESE:
                    result.push(codes.BACKSLASH);
                    result.push(codes.L_PARENTHESE);
                    break;
                case codes.R_PARENTHESE:
                    result.push(codes.BACKSLASH);
                    result.push(codes.R_PARENTHESE);
                    break;
                case codes.BACKSLASH:
                    result.push(codes.BACKSLASH);
                    result.push(codes.BACKSLASH);
                    break;
                default:
                    result.push(bytes[i]);
                    break;
            }
        }
        return new Uint8Array(result);
    }
    static unescape(bytes) {
        const result = [];
        let escaped = false;
        for (let i = 0; i < bytes.length; i++) {
            if (escaped) {
                switch (bytes[i]) {
                    case codes.n:
                        result.push(codes.LINE_FEED);
                        break;
                    case codes.r:
                        result.push(codes.CARRIAGE_RETURN);
                        break;
                    case codes.t:
                        result.push(codes.HORIZONTAL_TAB);
                        break;
                    case codes.b:
                        result.push(codes.BACKSPACE);
                        break;
                    case codes.f:
                        result.push(codes.FORM_FEED);
                        break;
                    case codes.L_PARENTHESE:
                        result.push(codes.L_PARENTHESE);
                        break;
                    case codes.R_PARENTHESE:
                        result.push(codes.R_PARENTHESE);
                        break;
                    case codes.BACKSLASH:
                        result.push(codes.BACKSLASH);
                        break;
                    default:
                        result.push(bytes[i]);
                        break;
                }
                escaped = false;
                continue;
            }
            if (bytes[i] === codes.BACKSLASH) {
                escaped = true;
                continue;
            }
            result.push(bytes[i]);
        }
        return new Uint8Array(result);
    }
    toArray(cryptInfo) {
        const bytes = (cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor
            ? cryptInfo.stringCryptor.encrypt(this._bytes, cryptInfo.ref)
            : this._bytes;
        return new Uint8Array([
            ...keywordCodes.STR_LITERAL_START,
            ...LiteralString.escape(bytes),
            ...keywordCodes.STR_LITERAL_END,
        ]);
    }
}

class PdfObject {
    constructor() {
        this._edited = false;
        this._deleted = false;
        this.onChange = {
            set: (target, prop, value) => {
                if (!this._edited && prop[0] !== "_") {
                    this._edited = true;
                    console.log(`EDITED prop ${prop}`);
                    console.log(this);
                }
                target[prop] = value;
                return true;
            },
        };
    }
    get ref() {
        return this._ref;
    }
    set ref(ref) {
        this._ref = ref;
    }
    get id() {
        var _a;
        return (_a = this._ref) === null || _a === void 0 ? void 0 : _a.id;
    }
    get generation() {
        var _a;
        return (_a = this._ref) === null || _a === void 0 ? void 0 : _a.generation;
    }
    get edited() {
        return this._edited;
    }
    get deleted() {
        return this._deleted;
    }
    markAsDeleted(value = true) {
        this._deleted = value;
    }
    parseRefProp(propName, parser, index) {
        const parsed = ObjectId.parseRef(parser, index);
        return this.setParsedProp(propName, parsed);
    }
    parseRefArrayProp(propName, parser, index) {
        const parsed = ObjectId.parseRefArray(parser, index);
        return this.setParsedProp(propName, parsed);
    }
    parseBoolProp(propName, parser, index) {
        const parsed = parser.parseBoolAt(index);
        return this.setParsedProp(propName, parsed);
    }
    parseNameProp(propName, parser, index, includeSlash = true) {
        const parsed = parser.parseNameAt(index, includeSlash);
        return this.setParsedProp(propName, parsed);
    }
    parseNameArrayProp(propName, parser, index, includeSlash = true) {
        const parsed = parser.parseNameArrayAt(index, includeSlash);
        return this.setParsedProp(propName, parsed);
    }
    parseNumberProp(propName, parser, index, float = true) {
        const parsed = parser.parseNumberAt(index, float);
        return this.setParsedProp(propName, parsed);
    }
    parseNumberArrayProp(propName, parser, index, float = true) {
        const parsed = parser.parseNumberArrayAt(index, float);
        return this.setParsedProp(propName, parsed);
    }
    parseDateProp(propName, parser, index, cryptInfo) {
        const parsed = DateString.parse(parser, index, cryptInfo);
        return this.setParsedProp(propName, parsed);
    }
    parseLiteralProp(propName, parser, index, cryptInfo) {
        const parsed = LiteralString.parse(parser, index, cryptInfo);
        return this.setParsedProp(propName, parsed);
    }
    setParsedProp(propName, parsed) {
        if (!parsed) {
            throw new Error(`Can't parse ${propName} property value`);
        }
        this[propName.slice(1)] = parsed.value;
        return parsed.end + 1;
    }
}

class PdfDict extends PdfObject {
    constructor(type) {
        super();
        this.Type = type;
    }
    get streamId() {
        return this._streamId;
    }
    toArray(cryptInfo) {
        const encoder = new TextEncoder();
        const bytes = [...keywordCodes.DICT_START];
        if (this.Type) {
            bytes.push(...keywordCodes.TYPE, ...encoder.encode(this.Type));
        }
        bytes.push(...keywordCodes.DICT_END);
        return new Uint8Array(bytes);
    }
    parseProps(parseInfo) {
        var _a;
        if (!parseInfo) {
            throw new Error("Parse info is empty");
        }
        this._ref = (_a = parseInfo.cryptInfo) === null || _a === void 0 ? void 0 : _a.ref;
        this._streamId = parseInfo.streamId;
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        if (i === -1) {
            throw new Error("Dict is empty (has no properties)");
        }
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Type":
                        const type = parser.parseNameAt(i);
                        if (type) {
                            if (this.Type && this.Type !== type.value) {
                                throw new Error(`Ivalid dict type: '${type.value}' instead of '${this.Type}'`);
                            }
                            return;
                        }
                        throw new Error("Can't parse /Type property value");
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class DecodeParamsDict extends PdfDict {
    constructor() {
        super(dictTypes.EMPTY);
        this._intPropMap = new Map();
        this._boolPropMap = new Map();
        this._namePropMap = new Map();
        this._refPropMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new DecodeParamsDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    static parseArray(parser, start, cryptInfo = null, skipEmpty = true) {
        const arrayBounds = parser.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const paramsDicts = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            const paramsBounds = parser.getDictBoundsAt(i);
            current = DecodeParamsDict.parse({ parser, bounds: paramsBounds, cryptInfo });
            if (!current) {
                break;
            }
            paramsDicts.push(current.value);
            i = current.end + 1;
        }
        return { value: paramsDicts, start: arrayBounds.start, end: arrayBounds.end };
    }
    getIntProp(name) {
        return this._intPropMap.get(name);
    }
    getBoolProp(name) {
        return this._boolPropMap.get(name);
    }
    getNameProp(name) {
        return this._namePropMap.get(name);
    }
    getRefProp(name) {
        return this._refPropMap.get(name);
    }
    setIntProp(name, value) {
        return this._intPropMap.set(name, value);
    }
    setBoolProp(name, value) {
        return this._boolPropMap.set(name, value);
    }
    setNameProp(name, value) {
        return this._namePropMap.set(name, value);
    }
    setRefProp(name, value) {
        return this._refPropMap.set(name, value);
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        this._intPropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...encoder.encode(" " + v)));
        this._boolPropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...encoder.encode(" " + v)));
        this._namePropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...encoder.encode(v)));
        this._refPropMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...v.toArray(cryptInfo)));
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                const valueType = parser.getValueTypeAt(i);
                switch (valueType) {
                    case valueTypes.NUMBER:
                        const intValue = parser.parseNumberAt(i, false);
                        if (intValue) {
                            this._intPropMap.set(name, intValue.value);
                            i = intValue.end + 1;
                            continue;
                        }
                        break;
                    case valueTypes.BOOLEAN:
                        const boolValue = parser.parseBoolAt(i);
                        if (boolValue) {
                            this._boolPropMap.set(name, boolValue.value);
                            i = boolValue.end + 1;
                            continue;
                        }
                        break;
                    case valueTypes.NAME:
                        const nameValue = parser.parseNameAt(i);
                        if (nameValue) {
                            this._namePropMap.set(name, nameValue.value);
                            i = nameValue.end + 1;
                            continue;
                        }
                        break;
                    case valueTypes.REF:
                        const refValue = ObjectId.parseRef(parser, i);
                        if (refValue) {
                            this._refPropMap.set(name, refValue.value);
                            i = refValue.end + 1;
                            continue;
                        }
                        break;
                }
                i = parser.skipToNextName(i, end - 1);
            }
            else {
                break;
            }
        }
    }
}

class DecodedStream {
    constructor(encodedStream) {
        this._minBufferLength = 512;
        this._bufferLength = 0;
        this._current = 0;
        this._ended = false;
        this._sourceStream = encodedStream;
    }
    get length() {
        return this._buffer.length;
    }
    ensureBuffer(size) {
        const buffer = this._buffer;
        if (buffer && size <= buffer.byteLength) {
            return buffer;
        }
        let length = this._minBufferLength;
        while (length < size) {
            length *= 2;
        }
        const enlargedBuffer = new Uint8Array(length);
        if (buffer) {
            enlargedBuffer.set(buffer);
        }
        return (this._buffer = enlargedBuffer);
    }
    takeByte() {
        const current = this._current;
        while (this._bufferLength <= current) {
            if (this._ended) {
                return -1;
            }
            this._readBlock();
        }
        return this._buffer[this._current++];
    }
    takeBytes(length) {
        let end;
        const position = this._current;
        if (length) {
            this.ensureBuffer(position + length);
            end = position + length;
            while (!this._ended && this._bufferLength < end) {
                this._readBlock();
            }
            if (end > this._bufferLength) {
                end = this._bufferLength;
            }
        }
        else {
            while (!this._ended) {
                this._readBlock();
            }
            end = this._bufferLength;
        }
        this._current = end;
        const subarray = this._buffer.subarray(position, end);
        return subarray;
    }
    takeUint16() {
        const byte_0 = this.takeByte();
        const byte_1 = this.takeByte();
        if (byte_0 === -1 || byte_1 === -1) {
            return -1;
        }
        return (byte_0 << 8) + byte_1;
    }
    takeInt32() {
        const byte_0 = this.takeByte();
        const byte_1 = this.takeByte();
        const byte_2 = this.takeByte();
        const byte_3 = this.takeByte();
        return (byte_0 << 24) + (byte_1 << 16) + (byte_2 << 8) + byte_3;
    }
    peekByte() {
        const peekedByte = this.takeByte();
        if (peekedByte !== -1) {
            this._current--;
        }
        return peekedByte;
    }
    peekBytes(length) {
        const bytes = this.takeBytes(length);
        this._current -= bytes.length;
        return bytes;
    }
    skip(n) {
        this._current += n || 1;
    }
    reset() {
        this._current = 0;
    }
}

class FlateStream extends DecodedStream {
    constructor(encodedStream) {
        super(encodedStream);
        this._codeSize = 0;
        this._codeBuf = 0;
        const cmf = encodedStream.takeByte();
        const flg = encodedStream.takeByte();
        if (cmf === -1 || flg === -1) {
            throw new Error(`Invalid header in flate stream: ${cmf}, ${flg}`);
        }
        if ((cmf & 0x0f) !== 0x08) {
            throw new Error(`Unknown compression method in flate stream: ${cmf}, ${flg}`);
        }
        if (((cmf << 8) + flg) % 31 !== 0) {
            throw new Error(`Bad FCHECK in flate stream: ${cmf}, ${flg}`);
        }
        if (flg & 0x20) {
            throw new Error(`FDICT bit set in flate stream: ${cmf}, ${flg}`);
        }
        this._codeSize = 0;
        this._codeBuf = 0;
    }
    _readBlock() {
        let buffer;
        let len;
        const str = this._sourceStream;
        let header = this.getBits(3);
        if (header & 1) {
            this._ended = true;
        }
        header >>= 1;
        if (header === 0) {
            let b;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            let blockLen = b;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            blockLen |= b << 8;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            let check = b;
            if ((b = str.takeByte()) === -1) {
                throw new Error("Bad block header in flate stream");
            }
            check |= b << 8;
            if (check !== (~blockLen & 0xffff) && (blockLen !== 0 || check !== 0)) {
                throw new Error("Bad uncompressed block length in flate stream");
            }
            this._codeBuf = 0;
            this._codeSize = 0;
            const bufferLength = this._bufferLength, end = bufferLength + blockLen;
            buffer = this.ensureBuffer(end);
            this._bufferLength = end;
            if (blockLen === 0) {
                if (str.peekByte() === -1) {
                    this._ended = true;
                }
            }
            else {
                const block = str.takeBytes(blockLen);
                buffer.set(block, bufferLength);
                if (block.length < blockLen) {
                    this._ended = true;
                }
            }
            return;
        }
        let litCodeTable;
        let distCodeTable;
        if (header === 1) {
            litCodeTable = FlateStream.fixedLitCodeTab;
            distCodeTable = FlateStream.fixedDistCodeTab;
        }
        else if (header === 2) {
            const numLitCodes = this.getBits(5) + 257;
            const numDistCodes = this.getBits(5) + 1;
            const numCodeLenCodes = this.getBits(4) + 4;
            const codeLenCodeLengths = new Uint8Array(FlateStream.codeLenCodeMap.length);
            let i;
            for (i = 0; i < numCodeLenCodes; i++) {
                codeLenCodeLengths[FlateStream.codeLenCodeMap[i]] = this.getBits(3);
            }
            const codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            len = 0;
            i = 0;
            const codes = numLitCodes + numDistCodes;
            const codeLengths = new Uint8Array(codes);
            let bitsLength;
            let bitsOffset;
            let what;
            while (i < codes) {
                const code = this.getCode(codeLenCodeTab);
                if (code === 16) {
                    bitsLength = 2;
                    bitsOffset = 3;
                    what = len;
                }
                else if (code === 17) {
                    bitsLength = 3;
                    bitsOffset = 3;
                    what = len = 0;
                }
                else if (code === 18) {
                    bitsLength = 7;
                    bitsOffset = 11;
                    what = len = 0;
                }
                else {
                    codeLengths[i++] = len = code;
                    continue;
                }
                let repeatLength = this.getBits(bitsLength) + bitsOffset;
                while (repeatLength-- > 0) {
                    codeLengths[i++] = what;
                }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.subarray(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.subarray(numLitCodes, codes));
        }
        else {
            throw new Error("Unknown block type in flate stream");
        }
        buffer = this._buffer;
        let limit = buffer ? buffer.length : 0;
        let pos = this._bufferLength;
        while (true) {
            let code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
                if (pos + 1 >= limit) {
                    buffer = this.ensureBuffer(pos + 1);
                    limit = buffer.length;
                }
                buffer[pos++] = code1;
                continue;
            }
            if (code1 === 256) {
                this._bufferLength = pos;
                return;
            }
            code1 -= 257;
            code1 = FlateStream.lengthDecode[code1];
            let code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            len = (code1 & 0xffff) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = FlateStream.distDecode[code1];
            code2 = code1 >> 16;
            if (code2 > 0) {
                code2 = this.getBits(code2);
            }
            const dist = (code1 & 0xffff) + code2;
            if (pos + len >= limit) {
                buffer = this.ensureBuffer(pos + len);
                limit = buffer.length;
            }
            for (let k = 0; k < len; ++k, ++pos) {
                buffer[pos] = buffer[pos - dist];
            }
        }
    }
    ;
    getBits(n) {
        const stream = this._sourceStream;
        let size = this._codeSize;
        let buf = this._codeBuf;
        let value;
        while (size < n) {
            if ((value = stream.takeByte()) === -1) {
                throw new Error("Bad encoding in flate stream");
            }
            buf |= value << size;
            size += 8;
        }
        value = buf & ((1 << n) - 1);
        this._codeBuf = buf >> n;
        this._codeSize = size -= n;
        return value;
    }
    ;
    getCode(table) {
        const stream = this._sourceStream;
        const [codes, maxLength] = table;
        let size = this._codeSize;
        let buf = this._codeBuf;
        let value;
        while (size < maxLength) {
            if ((value = stream.takeByte()) === -1) {
                break;
            }
            buf |= value << size;
            size += 8;
        }
        const code = codes[buf & ((1 << maxLength) - 1)];
        const codeLen = code >> 16;
        const codeVal = code & 0xffff;
        if (codeLen < 1 || size < codeLen) {
            throw new Error("Bad encoding in flate stream");
        }
        this._codeBuf = buf >> codeLen;
        this._codeSize = size - codeLen;
        return codeVal;
    }
    ;
    generateHuffmanTable(lengths) {
        const n = lengths.length;
        let maxLength = 0;
        let i;
        for (i = 0; i < n; i++) {
            if (lengths[i] > maxLength) {
                maxLength = lengths[i];
            }
        }
        const size = 1 << maxLength;
        const codes = new Int32Array(size);
        for (let length = 1, code = 0, skip = 2; length <= maxLength; length++, code <<= 1, skip <<= 1) {
            for (let value = 0; value < n; value++) {
                if (lengths[value] === length) {
                    let code2 = 0;
                    let t = code;
                    for (i = 0; i < length; i++) {
                        code2 = (code2 << 1) | (t & 1);
                        t >>= 1;
                    }
                    for (i = code2; i < size; i += skip) {
                        codes[i] = (length << 16) | value;
                    }
                    code++;
                }
            }
        }
        return [codes, maxLength];
    }
    ;
}
FlateStream.codeLenCodeMap = new Int32Array([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
]);
FlateStream.lengthDecode = new Int32Array([
    0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
    0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
    0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
    0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
]);
FlateStream.distDecode = new Int32Array([
    0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
    0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
    0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
    0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
]);
FlateStream.fixedLitCodeTab = [new Int32Array([
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
        0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
        0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
        0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
        0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
        0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
        0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
        0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
        0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
        0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
        0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
        0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
        0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
        0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
        0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
        0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
        0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
        0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
        0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
        0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
        0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
        0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
        0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
        0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
        0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
        0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
        0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
        0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
        0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
        0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
        0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
        0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
        0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
        0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
        0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
        0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
        0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
        0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
        0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
        0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
        0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
        0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
        0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
        0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
        0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
        0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
        0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
        0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
        0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
        0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
        0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
        0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
        0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
        0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
        0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
        0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
        0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
    ]), 9];
FlateStream.fixedDistCodeTab = [new Int32Array([
        0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
        0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
        0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
        0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
    ]), 5];

class Stream {
    constructor(bytes, start = 0, length) {
        if (length && length < 0) {
            throw new Error("Stream length can't be negative");
        }
        this._bytes = bytes instanceof Uint8Array
            ? bytes
            : new Uint8Array(bytes);
        this._start = start;
        this._current = start;
        this._end = start + length || bytes.length;
    }
    get length() {
        return this._end - this._start;
    }
    takeByte() {
        if (this._current >= this._end) {
            return -1;
        }
        return this._bytes[this._current++];
    }
    takeBytes(length) {
        const bytes = this._bytes;
        const position = this._current;
        const bytesEnd = this._end;
        if (!length) {
            const subarray = bytes.subarray(position, bytesEnd);
            return subarray;
        }
        else {
            let end = position + length;
            if (end > bytesEnd) {
                end = bytesEnd;
            }
            this._current = end;
            const subarray = bytes.subarray(position, end);
            return subarray;
        }
    }
    takeUint16() {
        const b0 = this.takeByte();
        const b1 = this.takeByte();
        if (b0 === -1 || b1 === -1) {
            return -1;
        }
        return (b0 << 8) + b1;
    }
    takeInt32() {
        const b0 = this.takeByte();
        const b1 = this.takeByte();
        const b2 = this.takeByte();
        const b3 = this.takeByte();
        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    }
    peekByte() {
        const peekedByte = this.takeByte();
        if (peekedByte !== -1) {
            this._current--;
        }
        return peekedByte;
    }
    peekBytes(length) {
        const bytes = this.takeBytes(length);
        this._current -= bytes.length;
        return bytes;
    }
    getByte(index) {
        return this._bytes[index];
    }
    getByteRange(start, end) {
        return this._bytes.subarray(Math.max(start, 0), Math.min(end, this._end));
    }
    skip(n) {
        this._current += n || 1;
    }
    reset() {
        this._current = this._start;
    }
}

class FlateDecoder {
    static Decode(input, predictor = flatePredictors.NONE, columns = 1, components = 1, bpc = 8) {
        const stream = new Stream(input, 0, input.length);
        const flate = new FlateStream(stream);
        const inflated = flate.takeBytes(null);
        switch (predictor) {
            case (flatePredictors.NONE):
                return inflated;
            case (flatePredictors.PNG_NONE):
            case (flatePredictors.PNG_SUB):
            case (flatePredictors.PNG_UP):
            case (flatePredictors.PNG_AVERAGE):
            case (flatePredictors.PNG_PAETH):
            case (flatePredictors.PNG_OPTIMUM):
                const unfiltered = FlateDecoder.removePngFilter(inflated, columns, components, bpc);
                return unfiltered;
            case (flatePredictors.TIFF):
                throw new Error("Unsupported filter predictor");
        }
    }
    static Encode(input, predictor = flatePredictors.PNG_UP, columns = 5, components = 1, bpc = 8) {
        let filtered;
        switch (predictor) {
            case (flatePredictors.NONE):
                filtered = input;
                break;
            case (flatePredictors.PNG_NONE):
            case (flatePredictors.PNG_SUB):
            case (flatePredictors.PNG_UP):
            case (flatePredictors.PNG_AVERAGE):
            case (flatePredictors.PNG_PAETH):
            case (flatePredictors.PNG_OPTIMUM):
                filtered = FlateDecoder.applyPngFilter(input, predictor, columns, components, bpc);
                break;
            case (flatePredictors.TIFF):
                throw new Error("Unsupported filter predictor");
        }
        const deflated = Pako.deflate(filtered);
        return deflated;
    }
    static removePngFilter(input, columns, components, bpc) {
        const interval = Math.ceil(components * bpc / 8);
        const lineLen = columns * interval;
        const lineLen_filtered = lineLen + 1;
        if (!!(input.length % lineLen_filtered)) {
            throw new Error("Data length doesn't match filter columns");
        }
        const output = new Uint8Array(input.length / lineLen_filtered * lineLen);
        const previous = new Array(lineLen).fill(0);
        const current = new Array(lineLen).fill(0);
        const getLeft = (j) => j - interval < 0
            ? 0
            : current[j - interval];
        const getAbove = (j) => previous[j];
        const getUpperLeft = (j) => j - interval < 0
            ? 0
            : previous[j - interval];
        let x = 0;
        let y = 0;
        let k = 0;
        let rowStart = 0;
        let filterType = 0;
        let result = 0;
        for (let i = 0; i < input.length; i++) {
            if (i % lineLen_filtered === 0) {
                filterType = input[i];
                x = 0;
                if (i) {
                    for (k = 0; k < lineLen; k++) {
                        previous[k] = output[rowStart + k];
                    }
                }
                rowStart = y;
            }
            else {
                current[x] = input[i];
                switch (filterType) {
                    case 0:
                        result = current[x];
                        break;
                    case 1:
                        result = (current[x] + getLeft(x)) % 256;
                        break;
                    case 2:
                        result = (current[x] + getAbove(x)) % 256;
                        break;
                    case 3:
                        result = (current[x] + Math.floor((getAbove(x) + getLeft(x)) / 2)) % 256;
                        break;
                    case 4:
                        result = (current[x] + this.paethPredictor(getLeft(x), getAbove(x), getUpperLeft(x))) % 256;
                        break;
                }
                output[y++] = result;
                x++;
            }
        }
        return output;
    }
    static applyPngFilter(input, predictor = 12, columns = 5, components = 1, bpc = 8) {
        let filterType;
        switch (predictor) {
            case flatePredictors.PNG_NONE:
                filterType = 0;
                break;
            case flatePredictors.PNG_SUB:
                filterType = 1;
                break;
            case flatePredictors.PNG_UP:
                filterType = 2;
                break;
            case flatePredictors.PNG_AVERAGE:
                filterType = 3;
                break;
            case flatePredictors.PNG_PAETH:
                filterType = 4;
                break;
            default:
                throw new Error("Invalid PNG filter type");
        }
        const interval = Math.ceil(components * bpc / 8);
        const lineLen = columns * interval;
        const lineLen_filtered = lineLen + 1;
        const lineCount = Math.ceil(input.length / lineLen);
        const lenFiltered = lineCount * lineLen_filtered;
        const output = new Uint8Array(lenFiltered);
        const previous = new Array(lineLen).fill(0);
        const current = new Array(lineLen).fill(0);
        const getLeft = (j) => j - interval < 0
            ? 0
            : current[j - interval];
        const getAbove = (j) => previous[j];
        const getUpperLeft = (j) => j - interval < 0
            ? 0
            : previous[j - interval];
        let x = 0;
        let y = 0;
        let k = 0;
        let rowStart = 0;
        let result = 0;
        for (let i = 0; i < lenFiltered; i++) {
            if (i % lineLen_filtered === 0) {
                x = 0;
                if (i) {
                    for (k = 0; k < lineLen; k++) {
                        previous[k] = input[rowStart + k];
                    }
                }
                rowStart = y;
                output[i] = filterType;
            }
            else {
                current[x] = input[y++] || 0;
                switch (filterType) {
                    case 0:
                        result = current[x];
                        break;
                    case 1:
                        result = (current[x] - getLeft(x)) % 256;
                        break;
                    case 2:
                        result = (current[x] - getAbove(x)) % 256;
                        break;
                    case 3:
                        result = (current[x] - Math.floor((getAbove(x) + getLeft(x)) / 2)) % 256;
                        break;
                    case 4:
                        result = (current[x] - this.paethPredictor(getLeft(x), getAbove(x), getUpperLeft(x))) % 256;
                        break;
                }
                output[i] = result;
                x++;
            }
        }
        return output;
    }
    static paethPredictor(a, b, c) {
        const p = a + b - c;
        const pa = Math.abs(p - a);
        const pb = Math.abs(p - b);
        const pc = Math.abs(p - c);
        if (pa <= pb && pa <= pc) {
            return a;
        }
        else if (pb <= pc) {
            return b;
        }
        else {
            return c;
        }
    }
}

class PdfStream extends PdfObject {
    constructor(type) {
        super();
        this.Type = type;
    }
    get streamData() {
        return this._streamData;
    }
    set streamData(data) {
        this.setStreamData(data);
        this._edited = true;
    }
    get decodedStreamData() {
        if (!this._decodedStreamData) {
            this.decodeStreamData();
        }
        return this._decodedStreamData;
    }
    get decodedStreamDataChars() {
        const decoder = new TextDecoder();
        return decoder.decode(this._decodedStreamData);
    }
    toArray(cryptInfo) {
        const streamData = (cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.streamCryptor
            ? cryptInfo.streamCryptor.encrypt(this.streamData, cryptInfo.ref)
            : this.streamData;
        const encoder = new TextEncoder();
        const bytes = [...keywordCodes.DICT_START];
        bytes.push(...encoder.encode("/Length "), ...encoder.encode(" " + streamData.length));
        if (this.Type) {
            bytes.push(...keywordCodes.TYPE, ...encoder.encode(this.Type));
        }
        if (this.Filter) {
            bytes.push(...encoder.encode("/Filter "), ...encoder.encode(this.Filter));
        }
        if (this.DecodeParms) {
            bytes.push(...encoder.encode("/DecodeParms "), ...this.DecodeParms.toArray(cryptInfo));
        }
        bytes.push(...keywordCodes.DICT_END, ...keywordCodes.END_OF_LINE, ...keywordCodes.STREAM_START, ...keywordCodes.END_OF_LINE, ...streamData, ...keywordCodes.END_OF_LINE, ...keywordCodes.STREAM_END);
        return new Uint8Array(bytes);
    }
    setTextStreamData(text) {
        const encoder = new TextEncoder();
        const bytes = encoder.encode(text);
        this.streamData = bytes;
    }
    parseProps(parseInfo) {
        var _a, _b;
        if (!parseInfo) {
            throw new Error("Parse info is empty");
        }
        this._ref = (_a = parseInfo.cryptInfo) === null || _a === void 0 ? void 0 : _a.ref;
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        const streamEndIndex = parser.findSubarrayIndex(keywordCodes.STREAM_END, {
            direction: "reverse",
            minIndex: start,
            maxIndex: end,
            closedOnly: true
        });
        if (!streamEndIndex) {
            throw new Error("Object is not a stream");
        }
        const streamStartIndex = parser.findSubarrayIndex(keywordCodes.STREAM_START, {
            direction: "reverse",
            minIndex: start,
            maxIndex: streamEndIndex.start - 1,
            closedOnly: true
        });
        if (!streamStartIndex) {
            throw new Error("Stream start is out of the data bounds");
        }
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        if (i === -1) {
            throw new Error("Dict is empty (has no properties)");
        }
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Type":
                        const type = parser.parseNameAt(i);
                        if (type) {
                            if (this.Type && this.Type !== type.value) {
                                throw new Error(`Ivalid dict type: '${type.value}' instead of '${this.Type}'`);
                            }
                            i = type.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Type property value");
                        }
                        break;
                    case "/Length":
                    case "/DL":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Filter":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.NAME) {
                            const filter = parser.parseNameAt(i);
                            if (filter && supportedFilters.has(filter.value)) {
                                this.Filter = filter.value;
                                i = filter.end + 1;
                                break;
                            }
                            else {
                                throw new Error(`Unsupported /Filter property value: ${filter.value}`);
                            }
                        }
                        else if (entryType === valueTypes.ARRAY) {
                            const filterNames = parser.parseNameArrayAt(i);
                            if (filterNames) {
                                const filterArray = filterNames.value;
                                if (filterArray.length === 1 && supportedFilters.has(filterArray[0])) {
                                    this.Filter = filterArray[0];
                                    i = filterNames.end + 1;
                                    break;
                                }
                                else {
                                    throw new Error(`Unsupported /Filter property value: ${filterArray.toString()}`);
                                }
                            }
                        }
                        throw new Error(`Unsupported /Filter property value type: ${entryType}`);
                    case "/DecodeParms":
                        const paramsEntryType = parser.getValueTypeAt(i);
                        if (paramsEntryType === valueTypes.DICTIONARY) {
                            const decodeParamsBounds = parser.getDictBoundsAt(i);
                            if (decodeParamsBounds) {
                                const params = DecodeParamsDict.parse({ parser,
                                    bounds: decodeParamsBounds, cryptInfo: parseInfo.cryptInfo });
                                if (params) {
                                    this.DecodeParms = params.value;
                                    i = decodeParamsBounds.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /DecodeParms property value");
                        }
                        else if (paramsEntryType === valueTypes.ARRAY) {
                            const paramsDicts = DecodeParamsDict.parseArray(parser, i, parseInfo.cryptInfo);
                            if (paramsDicts) {
                                const paramsArray = paramsDicts.value;
                                if (paramsArray.length === 1) {
                                    this.DecodeParms = paramsArray[0];
                                    i = paramsDicts.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /DecodeParms property value");
                        }
                        throw new Error(`Unsupported /DecodeParms property value type: ${paramsEntryType}`);
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        const streamStart = parser.findNewLineIndex("straight", streamStartIndex.end + 1);
        const streamEnd = parser.findNewLineIndex("reverse", streamEndIndex.start - 1);
        const streamBytes = parser.sliceCharCodes(streamStart, streamEnd);
        const encodedData = ((_b = parseInfo.cryptInfo) === null || _b === void 0 ? void 0 : _b.ref) && parseInfo.cryptInfo.streamCryptor
            ? parseInfo.cryptInfo.streamCryptor.decrypt(streamBytes, parseInfo.cryptInfo.ref)
            : streamBytes;
        this._streamData = encodedData;
    }
    setStreamData(data) {
        if (!(data === null || data === void 0 ? void 0 : data.length)) {
            throw new Error("Can't set emprty stream data");
        }
        let params;
        if (this.DecodeParms) {
            params = this.DecodeParms;
        }
        else {
            let columns;
            let i = 10;
            while (true) {
                if (data.length % i === 0) {
                    columns = i;
                    break;
                }
                i--;
            }
            params = new DecodeParamsDict();
            params.setIntProp("/Predictor", flatePredictors.PNG_UP);
            params.setIntProp("/Columns", columns);
            this.DecodeParms = params;
        }
        const encodedData = FlateDecoder.Encode(data, (params === null || params === void 0 ? void 0 : params.getIntProp("/Predictor")) || flatePredictors.NONE, (params === null || params === void 0 ? void 0 : params.getIntProp("/Columns")) || 1, (params === null || params === void 0 ? void 0 : params.getIntProp("/Colors")) || 1, (params === null || params === void 0 ? void 0 : params.getIntProp("/BitsPerComponent")) || 8);
        this._streamData = encodedData;
        this.Length = encodedData.length;
        this.DL = data.length;
        this._decodedStreamData = data;
    }
    decodeStreamData() {
        let decodedData;
        switch (this.Filter) {
            case streamFilters.FLATE:
                if (this.DecodeParms) {
                    const params = this.DecodeParms;
                    decodedData = FlateDecoder.Decode(this._streamData, params.getIntProp("/Predictor") || flatePredictors.NONE, params.getIntProp("/Columns") || 1, params.getIntProp("/Colors") || 1, params.getIntProp("/BitsPerComponent") || 8);
                }
                else {
                    decodedData = FlateDecoder.Decode(this._streamData);
                }
                break;
            default:
                decodedData = new Uint8Array(this._streamData);
                break;
        }
        this._decodedStreamData = decodedData;
    }
}

class TextStream extends PdfStream {
    constructor(type = null) {
        super(type);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TextStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getText() {
        return null;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        return superBytes;
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
    }
}

class HexString {
    constructor(literal, hex, bytes) {
        this._literal = literal;
        this._hex = hex;
        this._bytes = bytes;
    }
    get literal() {
        return this._literal;
    }
    get hex() {
        return this._hex.slice();
    }
    get bytes() {
        return this._bytes.slice();
    }
    static parse(parser, start, cryptInfo = null, skipEmpty = true) {
        const bounds = parser.getHexBounds(start, skipEmpty);
        if (!bounds) {
            return null;
        }
        let bytes = parser.sliceCharCodes(bounds.start + 1, bounds.end - 1);
        if ((cryptInfo === null || cryptInfo === void 0 ? void 0 : cryptInfo.ref) && cryptInfo.stringCryptor) {
            bytes = cryptInfo.stringCryptor.decrypt(bytes, cryptInfo.ref);
        }
        const hex = HexString.fromBytes(bytes);
        return { value: hex, start: bounds.start, end: bounds.end };
    }
    static parseArray(parser, start, cryptInfo = null, skipEmpty = true) {
        const arrayBounds = parser.getArrayBoundsAt(start, skipEmpty);
        if (!arrayBounds) {
            return null;
        }
        const hexes = [];
        let current;
        let i = arrayBounds.start + 1;
        while (i < arrayBounds.end) {
            current = HexString.parse(parser, i, cryptInfo, skipEmpty);
            if (!current) {
                break;
            }
            hexes.push(current.value);
            i = current.end + 1;
        }
        return { value: hexes, start: arrayBounds.start, end: arrayBounds.end };
    }
    static fromBytes(bytes) {
        const literal = new TextDecoder().decode(bytes);
        const hex = hexStringToBytes(literal);
        return new HexString(literal, hex, bytes);
    }
    static fromHexBytes(hex) {
        let literal = "";
        hex.forEach(x => literal += x.toString(16).padStart(2, "0"));
        const bytes = new TextEncoder().encode(literal);
        return new HexString(literal, hex, bytes);
    }
    static fromLiteralString(literal) {
        const hex = hexStringToBytes(literal);
        const bytes = new TextEncoder().encode(literal);
        return new HexString(literal, hex, bytes);
    }
    ;
    toArray(cryptInfo) {
        return new Uint8Array([
            ...keywordCodes.STR_HEX_START,
            ...this._bytes,
            ...keywordCodes.STR_HEX_END,
        ]);
    }
}

class IndexedColorSpaceArray {
    constructor(baseColorSpace, highestValue, lookupArray) {
        switch (baseColorSpace) {
            case colorSpaces.GRAYSCALE:
                this.componentsNumber = 1;
                break;
            case colorSpaces.RGB:
                this.componentsNumber = 3;
                break;
            case colorSpaces.CMYK:
                this.componentsNumber = 4;
                break;
            default:
                throw new Error(`Unsupported base color space for indexed color space: ${baseColorSpace}`);
        }
        this.baseColorSpace = baseColorSpace;
        if (lookupArray.length !== this.componentsNumber * (highestValue + 1)) {
            throw new Error(`Invalid lookup array length: ${lookupArray.length}`);
        }
        this.highestValue = highestValue;
        this.lookupArray = lookupArray;
        console.log(this);
    }
    static parse(parseInfo, skipEmpty = true) {
        const { parser, bounds, cryptInfo } = parseInfo;
        let i;
        if (skipEmpty) {
            i = parser.findNonSpaceIndex("straight", bounds.start);
        }
        const start = i;
        if (i < 0 || i > parser.maxIndex
            || parser.getCharCode(i) !== codes.L_BRACKET) {
            console.log("Color space array start not found");
            return null;
        }
        i++;
        const type = parser.parseNameAt(i);
        if (!type || type.value !== "/Indexed") {
            console.log("Array is not representing an indexed color space");
            return null;
        }
        i = type.end + 1;
        const base = parser.parseNameAt(i);
        if (!base) {
            console.log("Can't parse base color space name of the indexed color space");
            return null;
        }
        i = base.end + 2;
        const highestValue = parser.parseNumberAt(i);
        if (!highestValue || isNaN(highestValue.value)) {
            console.log("Can't parse the highest value of the indexed color space");
            return null;
        }
        i = highestValue.end + 1;
        let lookupArray;
        const lookupEntryType = parser.getValueTypeAt(i);
        if (lookupEntryType === valueTypes.REF) {
            try {
                const lookupId = ObjectId.parseRef(parser, i);
                const lookupParseInfo = parseInfo.parseInfoGetter(lookupId.value.id);
                const lookupStream = TextStream.parse(lookupParseInfo);
                lookupArray = lookupStream.value.decodedStreamData;
                i = lookupId.end + 1;
            }
            catch (e) {
                throw new Error(`Can't parse indexed color array lookup ref: ${e.message}`);
            }
        }
        else if (lookupEntryType === valueTypes.STRING_HEX) {
            const lookupHex = HexString.parse(parser, i, cryptInfo);
            if (lookupHex) {
                lookupArray = lookupHex.value.hex;
                i = lookupHex.end + 1;
            }
            else {
                throw new Error("Can't parse indexed color array lookup hex string");
            }
        }
        try {
            const colorSpace = new IndexedColorSpaceArray(base.value, highestValue.value, lookupArray);
            return {
                value: colorSpace,
                start,
                end: i - 1,
            };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const encoder = new TextEncoder();
        const bytes = [];
        bytes.push(codes.L_BRACKET, ...encoder.encode("/Indexed "), ...encoder.encode(this.baseColorSpace + " "), ...encoder.encode(this.highestValue + " "), ...HexString.fromHexBytes(this.lookupArray).toArray(cryptInfo), codes.R_BRACKET);
        return new Uint8Array(bytes);
    }
    getColor(index) {
        switch (this.baseColorSpace) {
            case colorSpaces.GRAYSCALE:
                const gray = this.lookupArray[index];
                return [gray, gray, gray];
            case colorSpaces.RGB:
                return [
                    this.lookupArray[index * 3],
                    this.lookupArray[index * 3 + 1],
                    this.lookupArray[index * 3 + 2],
                ];
            case colorSpaces.CMYK:
                const c = this.lookupArray[index * 4] / 255;
                const m = this.lookupArray[index * 4 + 1] / 255;
                const y = this.lookupArray[index * 4 + 2] / 255;
                const k = this.lookupArray[index * 4 + 3] / 255;
                return [
                    255 * (1 - c) * (1 - k),
                    255 * (1 - m) * (1 - k),
                    255 * (1 - y) * (1 - k),
                ];
        }
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class ImageStream extends PdfStream {
    constructor() {
        super(streamTypes.FORM_XOBJECT);
        this.Subtype = "/Image";
        this.ImageMask = false;
        this.Interpolate = false;
        this.SMaskInData = 0;
    }
    get sMask() {
        return this._sMask;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ImageStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        if (this.Width) {
            bytes.push(...encoder.encode("/Width "), ...encoder.encode(" " + this.Width));
        }
        if (this.Height) {
            bytes.push(...encoder.encode("/Width "), ...encoder.encode(" " + this.Height));
        }
        if (this.ColorSpace) {
            if (this._indexedColorSpace) {
                bytes.push(...encoder.encode("/ColorSpace "), ...this._indexedColorSpace.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/ColorSpace "), ...encoder.encode(this.ColorSpace));
            }
        }
        if (this.BitsPerComponent) {
            bytes.push(...encoder.encode("/BitsPerComponent "), ...encoder.encode(" " + this.BitsPerComponent));
        }
        bytes.push(...encoder.encode("/ImageMask "), ...encoder.encode(" " + !!this.ImageMask));
        if (this.Mask) {
            bytes.push(...encoder.encode("/Mask "), codes.L_BRACKET);
            this.Mask.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.Decode) {
            bytes.push(...encoder.encode("/Decode "), codes.L_BRACKET);
            this.Decode.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        bytes.push(...encoder.encode("/Interpolate "), ...encoder.encode(" " + !!this.Interpolate));
        if (this.SMask) {
            bytes.push(...encoder.encode("/SMask "), ...this.SMask.toArray(cryptInfo));
        }
        if (this.SMaskInData) {
            bytes.push(...encoder.encode("/SMaskInData "), ...encoder.encode(" " + this.SMaskInData));
        }
        if (this.Matte) {
            bytes.push(...encoder.encode("/Matte "), codes.L_BRACKET);
            this.Matte.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.Metadata) {
            bytes.push(...encoder.encode("/Metadata "), codes.WHITESPACE, ...this.Metadata.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    getImageUrlAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._imageUrl) {
                URL.revokeObjectURL(this._imageUrl);
            }
            if (this.Filter === streamFilters.DCT
                || this.Filter === streamFilters.JBIG2
                || this.Filter === streamFilters.JPX) {
                const blob = new Blob([this.decodedStreamData], {
                    type: "application/octet-binary",
                });
                const imageUrl = URL.createObjectURL(blob);
                this._imageUrl = imageUrl;
                return imageUrl;
            }
            if (this.Filter === streamFilters.FLATE) {
                const length = this.Width * this.Height;
                let alpha;
                if (this.sMask) {
                    alpha = this.sMask.decodedStreamData;
                    if (alpha.length !== length) {
                        throw new Error(`Invalid alpha mask data length: ${alpha.length} (must be ${length})`);
                    }
                }
                else {
                    alpha = new Uint8Array(length).fill(255);
                }
                const data = new Uint8ClampedArray(length * 4);
                for (let i = 0; i < length; i++) {
                    const [r, g, b] = this.getColor(i);
                    data[i * 4] = r;
                    data[i * 4 + 1] = g;
                    data[i * 4 + 2] = b;
                    data[i * 4 + 3] = alpha[i];
                }
                const imageData = new ImageData(data, this.Width, this.Height);
                const urlPromise = new Promise((resolve, reject) => {
                    const canvas = document.createElement("canvas");
                    canvas.width = this.Width;
                    canvas.height = this.Height;
                    canvas.getContext("2d").putImageData(imageData, 0, 0);
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        resolve(url);
                    });
                });
                const imageUrl = yield urlPromise;
                this._imageUrl = imageUrl;
                return imageUrl;
            }
            throw new Error(`Unsupported image filter type: ${this.Filter}`);
        });
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    case "/Width":
                    case "/Height":
                    case "/BitsPerComponent":
                    case "/SMaskInData":
                    case "/StructParent":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Decode":
                        i = this.parseNumberArrayProp(name, parser, i, false);
                        break;
                    case "/Matte":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/Interpolate":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/SMask":
                    case "/Metadata":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/ColorSpace":
                        const colorSpaceEntryType = parser.getValueTypeAt(i);
                        if (colorSpaceEntryType === valueTypes.NAME) {
                            const colorSpaceName = parser.parseNameAt(i);
                            if (colorSpaceName) {
                                this.ColorSpace = colorSpaceName.value;
                                i = colorSpaceName.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /ColorSpace name");
                        }
                        else if (colorSpaceEntryType === valueTypes.ARRAY) {
                            const colorSpaceArrayBounds = parser.getArrayBoundsAt(i);
                            if (colorSpaceArrayBounds) {
                                const indexedColorSpace = IndexedColorSpaceArray.parse({
                                    parser,
                                    bounds: colorSpaceArrayBounds,
                                    cryptInfo: parseInfo.cryptInfo,
                                    parseInfoGetter: parseInfo.parseInfoGetter,
                                });
                                if (indexedColorSpace) {
                                    this.ColorSpace = colorSpaces.SPECIAL_INDEXED;
                                    this._indexedColorSpace = indexedColorSpace.value;
                                    i = colorSpaceArrayBounds.end + 1;
                                    break;
                                }
                                throw new Error("Can't parse /ColorSpace object:" +
                                    parser.sliceChars(colorSpaceArrayBounds.start, colorSpaceArrayBounds.end));
                            }
                            throw new Error("Can't parse /ColorSpace value array");
                        }
                        else if (colorSpaceEntryType === valueTypes.REF) {
                            const colorSpaceRef = ObjectId.parseRef(parser, i);
                            if (colorSpaceRef) {
                                const colorSpaceParseInfo = parseInfo.parseInfoGetter(colorSpaceRef.value.id);
                                if (colorSpaceParseInfo) {
                                    const indexedColorSpace = IndexedColorSpaceArray.parse(colorSpaceParseInfo);
                                    if (indexedColorSpace) {
                                        this.ColorSpace = colorSpaces.SPECIAL_INDEXED;
                                        this._indexedColorSpace = indexedColorSpace.value;
                                        i = colorSpaceRef.end + 1;
                                        break;
                                    }
                                    throw new Error("Can't parse /ColorSpace object:" +
                                        colorSpaceParseInfo.parser.sliceChars(colorSpaceParseInfo.bounds.start, colorSpaceParseInfo.bounds.end));
                                }
                            }
                            throw new Error("Can't parse /ColorSpace ref");
                        }
                        throw new Error(`Unsupported /ColorSpace property value type: ${colorSpaceEntryType}`);
                    case "/ImageMask":
                        const imageMask = parser.parseBoolAt(i, false);
                        if (imageMask) {
                            this.ImageMask = imageMask.value;
                            i = imageMask.end + 1;
                            if (this.ImageMask) {
                                this.BitsPerComponent = 1;
                            }
                        }
                        else {
                            throw new Error("Can't parse /ImageMask property value");
                        }
                        break;
                    case "/Mask":
                        const maskEntryType = parser.getValueTypeAt(i);
                        if (maskEntryType === valueTypes.REF) {
                            const maskStreamId = ObjectId.parseRef(parser, i);
                            if (!maskStreamId) {
                                throw new Error("Can't parse /Mask value reference: failed to parse ref");
                            }
                            const maskParseInfo = parseInfo.parseInfoGetter(maskStreamId.value.id);
                            if (!maskParseInfo) {
                                throw new Error("Can't parse /Mask value reference: failed to get image parse info");
                            }
                            const maskStream = ImageStream.parse(maskParseInfo);
                            if (!maskStream) {
                                throw new Error("Can't parse /Mask value reference: failed to parse image stream");
                            }
                            const maskStreamParser = new DataParser(new Uint8Array([
                                codes.L_BRACKET,
                                ...maskStream.value.decodedStreamData,
                                codes.R_BRACKET,
                            ]));
                            if (!maskStreamParser) {
                                throw new Error("Can't parse /Mask value reference: failed to get decoded image data");
                            }
                            const maskArray = maskStreamParser.parseNumberArrayAt(0, false);
                            if (!maskArray) {
                                throw new Error("Can't parse /Mask value reference: failed to parse decoded image data");
                            }
                            this.Mask = maskArray.value;
                            i = maskStreamId.end + 1;
                            break;
                        }
                        else if (maskEntryType === valueTypes.ARRAY) {
                            const maskArray = parser.parseNumberArrayAt(i, false);
                            if (maskArray) {
                                this.Mask = maskArray.value;
                                i = maskArray.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /Mask property value");
                        }
                        throw new Error(`Unsupported /Mask property value type: ${maskEntryType}`);
                    case "/OC":
                    case "/Intent":
                    case "/Alternates":
                    case "/ID":
                    case "/OPI":
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Width && !this.Height) {
            throw new Error("Not all required properties parsed");
        }
        if (this.ImageMask && (this.BitsPerComponent !== 1 || this.ColorSpace)) {
            throw new Error("Mutually exclusive properties found");
        }
        if (!this.Decode && !(this.Filter === streamFilters.JPX && !this.ImageMask)) {
            switch (this.ColorSpace) {
                case colorSpaces.GRAYSCALE:
                    this.Decode = [0, 1];
                    break;
                case colorSpaces.RGB:
                    this.Decode = [0, 1, 0, 1, 0, 1];
                    break;
                case colorSpaces.CMYK:
                    this.Decode = [0, 1, 0, 1, 0, 1, 0, 1];
                    break;
                case colorSpaces.SPECIAL_INDEXED:
                    this.Decode = [0, Math.pow(2, this.BitsPerComponent || 1) - 1];
                    break;
                default:
                    this.Decode = [0, 1];
                    break;
            }
        }
        if (!this.DecodeParms) {
            this.DecodeParms = new DecodeParamsDict();
        }
        if (!this.DecodeParms.getIntProp("/BitsPerComponent")) {
            this.DecodeParms.setIntProp("/BitsPerComponent", this.BitsPerComponent);
        }
        if (!this.DecodeParms.getIntProp("/Columns")) {
            this.DecodeParms.setIntProp("/Columns", this.Width);
        }
        if (!this.DecodeParms.getIntProp("/Colors")) {
            switch (this.ColorSpace) {
                case colorSpaces.GRAYSCALE:
                case colorSpaces.SPECIAL_INDEXED:
                    this.DecodeParms.setIntProp("/Colors", 1);
                    break;
                case colorSpaces.RGB:
                    this.DecodeParms.setIntProp("/Colors", 3);
                    break;
                case colorSpaces.CMYK:
                    this.DecodeParms.setIntProp("/Colors", 4);
                    break;
                default:
                    this.DecodeParms.setIntProp("/Colors", 1);
                    break;
            }
        }
        if (this.SMask) {
            const sMaskParseInfo = parseInfo.parseInfoGetter(this.SMask.id);
            if (!sMaskParseInfo) {
                throw new Error(`Can't get parse info for ref: ${this.SMask.id} ${this.sMask.generation} R`);
            }
            const sMask = ImageStream.parse(sMaskParseInfo);
            if (!sMask) {
                throw new Error(`Can't parse SMask: ${this.SMask.id} ${this.sMask.generation} R`);
            }
            this._sMask = sMask.value;
        }
    }
    getColor(index) {
        var _a;
        const data = this.decodedStreamData;
        switch (this.ColorSpace) {
            case colorSpaces.GRAYSCALE:
                const gray = data[index];
                return [gray, gray, gray];
            case colorSpaces.RGB:
                return [
                    data[index * 3],
                    data[index * 3 + 1],
                    data[index * 3 + 2],
                ];
            case colorSpaces.CMYK:
                const c = data[index * 4] / 255;
                const m = data[index * 4 + 1] / 255;
                const y = data[index * 4 + 2] / 255;
                const k = data[index * 4 + 3] / 255;
                return [
                    255 * (1 - c) * (1 - k),
                    255 * (1 - m) * (1 - k),
                    255 * (1 - y) * (1 - k),
                ];
            case colorSpaces.SPECIAL_INDEXED:
                return ((_a = this._indexedColorSpace) === null || _a === void 0 ? void 0 : _a.getColor(index)) || [0, 0, 0];
        }
    }
}

const borderStyles = {
    SOLID: "/S",
    DASHED: "/D",
    BEVELED: "/B",
    INSET: "/I",
    UNDERLINE: "/U",
};
class BorderStyleDict extends PdfDict {
    constructor() {
        super(dictTypes.BORDER_STYLE);
        this.W = 1;
        this.S = borderStyles.SOLID;
        this.D = [3, 0];
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new BorderStyleDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.W) {
            bytes.push(...encoder.encode("/W "), ...encoder.encode(" " + this.W));
        }
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        if (this.D) {
            bytes.push(...encoder.encode("/D "), codes.L_BRACKET, ...encoder.encode(this.D[0] + ""), codes.WHITESPACE, ...encoder.encode(this.D[1] + ""), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        var _a, _b;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/W":
                        i = this.parseNumberProp(name, parser, i, true);
                        break;
                    case "/S":
                        const style = parser.parseNameAt(i, true);
                        if (style && Object.values(borderStyles).includes(style.value)) {
                            this.S = style.value;
                            i = style.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    case "/D":
                        const dashGap = parser.parseNumberArrayAt(i, true);
                        if (dashGap) {
                            this.D = [
                                (_a = dashGap.value[0]) !== null && _a !== void 0 ? _a : 3,
                                (_b = dashGap.value[1]) !== null && _b !== void 0 ? _b : 0,
                            ];
                            i = dashGap.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /D property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class ObjectMapDict extends PdfDict {
    constructor() {
        super(null);
        this._objectIdMap = new Map();
        this._dictParserMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ObjectMapDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getObjectId(name) {
        return this._objectIdMap.get(name);
    }
    *getObjectIds() {
        for (const pair of this._objectIdMap) {
            yield pair;
        }
        return;
    }
    getDictParser(name) {
        return this._dictParserMap.get(name);
    }
    *getDictParsers() {
        for (const pair of this._dictParserMap) {
            yield pair;
        }
        return;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        this._objectIdMap.forEach((v, k) => {
            bytes.push(...encoder.encode(k), codes.WHITESPACE, ...v.toArray(cryptInfo));
        });
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    default:
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.REF) {
                            const id = ObjectId.parseRef(parser, i);
                            if (id) {
                                this._objectIdMap.set(name, id.value);
                                i = id.end + 1;
                                break;
                            }
                        }
                        else if (entryType === valueTypes.DICTIONARY) {
                            const dictBounds = parser.getDictBoundsAt(i);
                            if (dictBounds) {
                                const dictParseInfo = {
                                    parser: new DataParser(parser.sliceCharCodes(dictBounds.start, dictBounds.end)),
                                    bounds: {
                                        start: 0,
                                        end: dictBounds.end - dictBounds.start,
                                        contentStart: dictBounds.contentStart - dictBounds.start,
                                        contentEnd: dictBounds.contentEnd - dictBounds.start,
                                    },
                                    cryptInfo: parseInfo.cryptInfo,
                                };
                                this._dictParserMap.set(name, dictParseInfo);
                                i = dictBounds.end + 1;
                                break;
                            }
                        }
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class FontDict extends PdfDict {
    constructor() {
        super(dictTypes.FONT);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new FontDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(" " + this.Subtype));
        }
        if (this.BaseFont) {
            bytes.push(...encoder.encode("/BaseFont "), ...encoder.encode(" " + this.BaseFont));
        }
        if (this.Encoding) {
            bytes.push(...encoder.encode("/Encoding "), ...encoder.encode(" " + this.Encoding));
        }
        if (this.ToUnicode) {
            bytes.push(...encoder.encode("/G "), codes.WHITESPACE, ...this.ToUnicode.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i, true);
                        if (subtype) {
                            if (subtype.value === "/Type1" || subtype.value === "/TrueType") {
                                this.Subtype = subtype.value;
                                i = subtype.end + 1;
                                break;
                            }
                            throw new Error(`Font type is not supported: ${subtype.value}`);
                        }
                        throw new Error("Can't parse /Subtype property value");
                    case "/BaseFont":
                    case "/Encoding":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/ToUnicode":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class SoftMaskDict extends PdfDict {
    constructor() {
        super(dictTypes.SOFT_MASK);
        this.TR = "/Identity";
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new SoftMaskDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        if (this.G) {
            bytes.push(...encoder.encode("/G "), codes.WHITESPACE, ...this.G.toArray(cryptInfo));
        }
        if (this.BC) {
            bytes.push(...encoder.encode("/BC "), codes.L_BRACKET);
            this.BC.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.TR) {
            bytes.push(...encoder.encode("/TR "), ...encoder.encode(" " + this.TR));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/S":
                        const softMaskType = parser.parseNameAt(i, true);
                        if (softMaskType && Object.values(softMaskTypes)
                            .includes(softMaskType.value)) {
                            this.S = softMaskType.value;
                            i = softMaskType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    case "/G":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/BC":
                        i = this.parseNumberArrayProp(name, parser, i);
                        break;
                    case "/TR":
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class GraphicsStateDict extends PdfDict {
    constructor() {
        super(dictTypes.GRAPHICS_STATE);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new GraphicsStateDict();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.LW) {
            bytes.push(...encoder.encode("/LW "), ...encoder.encode(" " + this.LW));
        }
        if (this.LC) {
            bytes.push(...encoder.encode("/LC "), ...encoder.encode(" " + this.LC));
        }
        if (this.LJ) {
            bytes.push(...encoder.encode("/LJ "), ...encoder.encode(" " + this.LJ));
        }
        if (this.ML) {
            bytes.push(...encoder.encode("/ML "), ...encoder.encode(" " + this.ML));
        }
        if (this.D) {
            bytes.push(...encoder.encode("/D "), codes.L_BRACKET, codes.L_BRACKET, ...encoder.encode("" + this.D[0][0]), ...encoder.encode(" " + this.D[0][1]), codes.R_BRACKET, ...encoder.encode(" " + this.D[1]), codes.R_BRACKET);
        }
        if (this.RI) {
            bytes.push(...encoder.encode("/RI "), ...encoder.encode(this.RI));
        }
        if (this.OP) {
            bytes.push(...encoder.encode("/OP "), ...encoder.encode(" " + this.OP));
        }
        if (this.op) {
            bytes.push(...encoder.encode("/op "), ...encoder.encode(" " + this.op));
        }
        if (this.OPM) {
            bytes.push(...encoder.encode("/OPM "), ...encoder.encode(" " + this.OPM));
        }
        if (this.Font) {
            bytes.push(...encoder.encode("/Font "), codes.L_BRACKET, ...this.Font[0].toArray(cryptInfo), ...encoder.encode(" " + this.Font[1]), codes.R_BRACKET);
        }
        if (this.FL) {
            bytes.push(...encoder.encode("/FL "), ...encoder.encode(" " + this.FL));
        }
        if (this.SM) {
            bytes.push(...encoder.encode("/SM "), ...encoder.encode(" " + this.SM));
        }
        if (this.SA) {
            bytes.push(...encoder.encode("/SA "), ...encoder.encode(" " + this.SA));
        }
        if (this.BM) {
            bytes.push(...encoder.encode("/BM "), ...encoder.encode(this.BM));
        }
        if (this.SMask) {
            if (this.SMask instanceof SoftMaskDict) {
                bytes.push(...encoder.encode("/SMask "), ...this.SMask.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/SMask "), ...encoder.encode(this.SMask));
            }
        }
        if (this.CA) {
            bytes.push(...encoder.encode("/CA "), ...encoder.encode(" " + this.CA));
        }
        if (this.ca) {
            bytes.push(...encoder.encode("/ca "), ...encoder.encode(" " + this.ca));
        }
        if (this.AIS) {
            bytes.push(...encoder.encode("/AIS "), ...encoder.encode(" " + this.AIS));
        }
        if (this.TK) {
            bytes.push(...encoder.encode("/AIS "), ...encoder.encode(" " + this.TK));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toParams() {
        const params = {};
        if (!isNaN(this.LW)) {
            params.strokeWidth = this.LW;
        }
        if (!isNaN(this.LC)) {
            switch (this.LC) {
                case lineCapStyles.BUTT:
                    params.strokeLineCap = "butt";
                    break;
                case lineCapStyles.ROUND:
                    params.strokeLineCap = "round";
                    break;
                case lineCapStyles.SQUARE:
                    params.strokeLineCap = "square";
                    break;
            }
        }
        if (!isNaN(this.LJ)) {
            switch (this.LJ) {
                case lineJoinStyles.BEVEL:
                    params.strokeLineJoin = "bevel";
                    break;
                case lineJoinStyles.ROUND:
                    params.strokeLineJoin = "round";
                    break;
                case lineJoinStyles.MITER:
                    params.strokeLineJoin = "miter";
                    break;
            }
        }
        if (this.ML) {
            params.strokeMiterLimit = this.ML;
        }
        if (this.D) {
            params.strokeDashArray = `${this.D[0][0]} ${this.D[0][1]}`;
            params.strokeDashOffset = this.D[1];
        }
        if (this.Font) ;
        if (this.BM) {
            params.strokeMiterLimit = this.ML;
        }
        if (this.SMask) ;
        if (this.CA) {
            params.strokeAlpha = this.CA;
        }
        if (this.ca) {
            params.fillAlpha = this.ca;
        }
        if (this.AIS) ;
        return params;
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/LC":
                        const lineCap = parser.parseNumberAt(i, true);
                        if (lineCap && Object.values(lineCapStyles)
                            .includes(lineCap.value)) {
                            this.LC = lineCap.value;
                            i = lineCap.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /LC property value");
                        }
                        break;
                    case "/OPM":
                        const overprintMode = parser.parseNumberAt(i, true);
                        if (overprintMode && ([0, 1].includes(overprintMode.value))) {
                            this.OPM = overprintMode.value;
                            i = overprintMode.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /OPM property value");
                        }
                        break;
                    case "/LJ":
                        const lineJoin = parser.parseNumberAt(i, true);
                        if (lineJoin && Object.values(lineJoinStyles)
                            .includes(lineJoin.value)) {
                            this.LJ = lineJoin.value;
                            i = lineJoin.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /LJ property value");
                        }
                        break;
                    case "/RI":
                        const intent = parser.parseNameAt(i, true);
                        if (intent && Object.values(renderingIntents)
                            .includes(intent.value)) {
                            this.RI = intent.value;
                            i = intent.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /RI property value");
                        }
                        break;
                    case "/BM":
                        const blendMode = parser.parseNameAt(i, true);
                        if (blendMode && Object.values(blendModes)
                            .includes(blendMode.value)) {
                            this.BM = blendMode.value;
                            i = blendMode.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /BM property value");
                        }
                        break;
                    case "/SMask":
                        const sMaskEntryType = parser.getValueTypeAt(i);
                        if (sMaskEntryType === valueTypes.NAME) {
                            const sMaskName = parser.parseNameAt(i);
                            if (sMaskName) {
                                this.SMask = sMaskName.value;
                                i = sMaskName.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /SMask property name");
                        }
                        else if (sMaskEntryType === valueTypes.DICTIONARY) {
                            const sMaskDictBounds = parser.getDictBoundsAt(i);
                            if (sMaskDictBounds) {
                                const sMaskDict = SoftMaskDict.parse({ parser, bounds: sMaskDictBounds });
                                if (sMaskDict) {
                                    this.SMask = sMaskDict.value;
                                    i = sMaskDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /SMask value dictionary");
                        }
                        throw new Error(`Unsupported /SMask property value type: ${sMaskEntryType}`);
                    case "/Font":
                        const fontEntryType = parser.getValueTypeAt(i);
                        if (fontEntryType === valueTypes.ARRAY) {
                            const fontArrayBounds = parser.getArrayBoundsAt(i);
                            if (fontArrayBounds) {
                                const fontRef = ObjectId.parse(parser, fontArrayBounds.start + 1);
                                if (fontRef) {
                                    const fontSize = parser.parseNumberAt(fontRef.end + 1);
                                    if (fontSize) {
                                        this.Font = [fontRef.value, fontSize.value];
                                        i = fontArrayBounds.end + 1;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /Font property value type: ${fontEntryType}`);
                        }
                        throw new Error("Can't parse /Font property value");
                    case "/D":
                        const dashEntryType = parser.getValueTypeAt(i);
                        if (dashEntryType === valueTypes.ARRAY) {
                            const dashArrayBounds = parser.getArrayBoundsAt(i);
                            if (dashArrayBounds) {
                                const dashArray = parser.parseNumberArrayAt(dashArrayBounds.start + 1);
                                if (dashArray) {
                                    const dashPhase = parser.parseNumberAt(dashArray.end + 1);
                                    if (dashPhase) {
                                        this.D = [[dashArray.value[0], dashArray.value[1]], dashPhase.value];
                                        i = dashArrayBounds.end + 1;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /D property value type: ${dashEntryType}`);
                        }
                        throw new Error("Can't parse /D property value");
                    case "/OP":
                    case "/op":
                    case "/SA":
                    case "/AIS":
                    case "/TK":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/LW":
                    case "/ML":
                    case "/FL":
                    case "/SM":
                    case "/CA":
                    case "/ca":
                        i = this.parseNumberProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class ResourceDict extends PdfDict {
    constructor() {
        super(null);
        this._gsMap = new Map();
        this._fontsMap = new Map();
        this._xObjectsMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ResourceDict();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this._gsMap.size) {
            bytes.push(...encoder.encode("/ExtGState "));
            bytes.push(...keywordCodes.DICT_START);
            for (const [name, gsDict] of this._gsMap) {
                bytes.push(...encoder.encode(name.slice(10)), codes.WHITESPACE);
                if (gsDict.ref) {
                    bytes.push(...ObjectId.fromRef(gsDict.ref).toArray(cryptInfo));
                }
                else {
                    bytes.push(...gsDict.toArray(cryptInfo));
                }
            }
            bytes.push(...keywordCodes.DICT_END);
        }
        if (this._xObjectsMap.size) {
            bytes.push(...encoder.encode("/XObject "), ...keywordCodes.DICT_START);
            for (const [name, xObject] of this._xObjectsMap) {
                const ref = xObject.ref;
                if (!ref) {
                    throw new Error("XObject has no reference");
                }
                bytes.push(...encoder.encode(name.slice(8)), codes.WHITESPACE);
                bytes.push(...ObjectId.fromRef(ref).toArray(cryptInfo));
            }
            bytes.push(...keywordCodes.DICT_END);
        }
        if (this.ColorSpace) {
            bytes.push(...encoder.encode("/ColorSpace "), ...this.ColorSpace.toArray(cryptInfo));
        }
        if (this.Pattern) {
            bytes.push(...encoder.encode("/Pattern "), ...this.Pattern.toArray(cryptInfo));
        }
        if (this.Shading) {
            bytes.push(...encoder.encode("/Shading "), ...this.Shading.toArray(cryptInfo));
        }
        if (this.Font) {
            bytes.push(...encoder.encode("/Font "), ...this.Font.toArray(cryptInfo));
        }
        if (this.Properties) {
            bytes.push(...encoder.encode("/Properties "), ...this.Properties.toArray(cryptInfo));
        }
        if (this.ProcSet) {
            bytes.push(...encoder.encode("/ProcSet "), codes.L_BRACKET);
            this.ProcSet.forEach(x => bytes.push(codes.WHITESPACE, ...encoder.encode(x)));
            bytes.push(codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    getGraphicsState(name) {
        return this._gsMap.get(name);
    }
    *getGraphicsStates() {
        for (const pair of this._gsMap) {
            yield pair;
        }
        return;
    }
    setGraphicsState(name, state) {
        this._gsMap.set(`/ExtGState${name}`, state);
        this._edited = true;
    }
    getFont(name) {
        return this._fontsMap.get(name);
    }
    *getFonts() {
        for (const pair of this._fontsMap) {
            yield pair;
        }
        return;
    }
    getXObject(name) {
        return this._xObjectsMap.get(name);
    }
    *getXObjects() {
        for (const pair of this._xObjectsMap) {
            yield pair;
        }
        return;
    }
    setXObject(name, xObject) {
        this._xObjectsMap.set(`/XObject${name}`, xObject);
        this._edited = true;
    }
    fillMaps(parseInfoGetter, cryptInfo) {
        this._gsMap.clear();
        this._fontsMap.clear();
        this._xObjectsMap.clear();
        if (this.ExtGState) {
            for (const [name, objectId] of this.ExtGState.getObjectIds()) {
                const streamParseInfo = parseInfoGetter(objectId.id);
                if (!streamParseInfo) {
                    continue;
                }
                const stream = GraphicsStateDict.parse(streamParseInfo);
                if (stream) {
                    this._gsMap.set(`/ExtGState${name}`, stream.value);
                }
            }
            for (const [name, parseInfo] of this.ExtGState.getDictParsers()) {
                const dict = GraphicsStateDict.parse(parseInfo);
                if (dict) {
                    this._gsMap.set(`/ExtGState${name}`, dict.value);
                }
            }
        }
        if (this.XObject) {
            for (const [name, objectId] of this.XObject.getObjectIds()) {
                const streamParseInfo = parseInfoGetter(objectId.id);
                if (!streamParseInfo) {
                    continue;
                }
                const stream = streamParseInfo.parser
                    .findSubarrayIndex(keywordCodes.FORM, {
                    direction: "straight",
                    minIndex: streamParseInfo.bounds.start,
                    maxIndex: streamParseInfo.bounds.end,
                })
                    ? XFormStream.parse(streamParseInfo)
                    : ImageStream.parse(streamParseInfo);
                if (stream) {
                    this._xObjectsMap.set(`/XObject${name}`, stream.value);
                }
            }
        }
        if (this.Font) {
            for (const [name, objectId] of this.Font.getObjectIds()) {
                const dictParseInfo = parseInfoGetter(objectId.id);
                if (!dictParseInfo) {
                    continue;
                }
                const dict = FontDict.parse(dictParseInfo);
                if (dict) {
                    this._fontsMap.set(`/Font${name}`, dict.value);
                }
            }
        }
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/ExtGState":
                    case "/ColorSpace":
                    case "/Pattern":
                    case "/Shading":
                    case "/XObject":
                    case "/Font":
                    case "/Properties":
                        const mapBounds = parser.getDictBoundsAt(i);
                        if (mapBounds) {
                            const map = ObjectMapDict.parse({ parser, bounds: mapBounds });
                            if (map) {
                                this[name.slice(1)] = map.value;
                                i = mapBounds.end + 1;
                                break;
                            }
                        }
                        throw new Error(`Can't parse ${name} property value`);
                    case "/ProcSet":
                        i = this.parseNameArrayProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (parseInfo.parseInfoGetter) {
            this.fillMaps(parseInfo.parseInfoGetter, parseInfo.cryptInfo);
        }
    }
}

class MeasureDict extends PdfDict {
    constructor() {
        super(dictTypes.MEASURE);
        this.Subtype = "/RL";
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new MeasureDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class GroupDict extends PdfDict {
    constructor() {
        super(dictTypes.GROUP);
        this.S = "/Transparency";
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/S":
                        const intent = parser.parseNameAt(i, true);
                        if (intent) {
                            if (Object.values(groupDictTypes).includes(intent.value)) {
                                this.S = intent.value;
                                i = intent.end + 1;
                            }
                            else {
                                throw new Error(`Ivalid dict subtype: '${intent.value}'`);
                            }
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class TransparencyGroupDict extends GroupDict {
    constructor() {
        super();
        this.I = false;
        this.K = false;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TransparencyGroupDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.CS) {
            bytes.push(...encoder.encode("/CS "), ...encoder.encode(this.CS));
        }
        if (this.I) {
            bytes.push(...encoder.encode("/I "), ...encoder.encode(" " + this.I));
        }
        if (this.K) {
            bytes.push(...encoder.encode("/K "), ...encoder.encode(" " + this.K));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        if (this.S !== "/Transparency") {
            throw new Error("Not a transparency dict");
        }
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/CS":
                        const colorSpaceEntryType = parser.getValueTypeAt(i);
                        if (colorSpaceEntryType === valueTypes.NAME) {
                            const colorSpaceName = parser.parseNameAt(i);
                            if (colorSpaceName) {
                                this.CS = colorSpaceName.value;
                                i = colorSpaceName.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /CS property name");
                        }
                        else if (colorSpaceEntryType === valueTypes.ARRAY) {
                            const colorSpaceArrayBounds = parser.getArrayBoundsAt(i);
                            if (colorSpaceArrayBounds) {
                                i = colorSpaceArrayBounds.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /CS value dictionary");
                        }
                        throw new Error(`Unsupported /CS property value type: ${colorSpaceEntryType}`);
                    case "/I":
                    case "/K":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class XFormStream extends PdfStream {
    constructor() {
        super(streamTypes.FORM_XOBJECT);
        this.Subtype = "/Form";
        this.FormType = 1;
        this.Matrix = [1, 0, 0, 1, 0, 0];
    }
    get matrix() {
        const apMatrix = new Mat3();
        if (this.Matrix) {
            const [m0, m1, m3, m4, m6, m7] = this.Matrix;
            apMatrix.set(m0, m1, 0, m3, m4, 0, m6, m7, 1);
        }
        return apMatrix;
    }
    set matrix(matrix) {
        if (!matrix) {
            return;
        }
        this.Matrix = [...matrix.toFloatShortArray()];
    }
    get bBox() {
        return {
            ll: new Vec2(this.BBox[0], this.BBox[1]),
            lr: new Vec2(this.BBox[2], this.BBox[1]),
            ur: new Vec2(this.BBox[2], this.BBox[3]),
            ul: new Vec2(this.BBox[0], this.BBox[3]),
        };
    }
    get transformedBBox() {
        const matrix = new Mat3();
        if (this.Matrix) {
            const [m0, m1, m3, m4, m6, m7] = this.Matrix;
            matrix.set(m0, m1, 0, m3, m4, 0, m6, m7, 1);
        }
        const bBoxLL = new Vec2(this.BBox[0], this.BBox[1]);
        const bBoxLR = new Vec2(this.BBox[2], this.BBox[1]);
        const bBoxUR = new Vec2(this.BBox[2], this.BBox[3]);
        const bBoxUL = new Vec2(this.BBox[0], this.BBox[3]);
        return {
            ll: Vec2.applyMat3(bBoxLL, matrix),
            lr: Vec2.applyMat3(bBoxLR, matrix),
            ur: Vec2.applyMat3(bBoxUR, matrix),
            ul: Vec2.applyMat3(bBoxUL, matrix),
        };
    }
    get edited() {
        return this._edited || this.Resources.edited;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new XFormStream();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        if (this.FormType) {
            bytes.push(...encoder.encode("/FormType "), ...encoder.encode(" " + this.FormType));
        }
        if (this.BBox) {
            bytes.push(...encoder.encode("/BBox "), codes.L_BRACKET, ...encoder.encode(this.BBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.BBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.BBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.BBox[3] + ""), codes.R_BRACKET);
        }
        if (this.Matrix) {
            bytes.push(...encoder.encode("/Matrix "), codes.L_BRACKET, ...encoder.encode(this.Matrix[0] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[1] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[2] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[3] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[4] + ""), codes.WHITESPACE, ...encoder.encode(this.Matrix[5] + ""), codes.R_BRACKET);
        }
        if (this.Resources) {
            bytes.push(...encoder.encode("/Resources "), ...this.Resources.toArray(cryptInfo));
        }
        if (this.Metadata) {
            bytes.push(...encoder.encode("/Metadata "), codes.WHITESPACE, ...this.Metadata.toArray(cryptInfo));
        }
        if (this.LastModified) {
            bytes.push(...encoder.encode("/LastModified "), ...this.LastModified.toArray(cryptInfo));
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.StructParents) {
            bytes.push(...encoder.encode("/StructParents "), ...encoder.encode(" " + this.StructParents));
        }
        if (this.Measure) {
            bytes.push(...encoder.encode("/Measure "), ...this.Measure.toArray(cryptInfo));
        }
        if (this.Group) {
            bytes.push(...encoder.encode("/Group "), ...this.Group.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    case "/FormType":
                        const formType = parser.parseNumberAt(i, false);
                        if (formType) {
                            if (formType.value !== 1) {
                                throw new Error(`Ivalid form type: '${formType.value}' instead of '1'`);
                            }
                            i = formType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /FormType property value");
                        }
                        break;
                    case "/BBox":
                    case "/Matrix":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/LastModified":
                        i = this.parseDateProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/Metadata":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/StructParent":
                    case "/StructParents":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Resources":
                        const resEntryType = parser.getValueTypeAt(i);
                        if (resEntryType === valueTypes.REF) {
                            const resDictId = ObjectId.parseRef(parser, i);
                            if (resDictId && parseInfo.parseInfoGetter) {
                                const resParseInfo = parseInfo.parseInfoGetter(resDictId.value.id);
                                if (resParseInfo) {
                                    const resDict = ResourceDict.parse(resParseInfo);
                                    if (resDict) {
                                        this.Resources = resDict.value;
                                        i = resDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Resources value reference");
                        }
                        else if (resEntryType === valueTypes.DICTIONARY) {
                            const resDictBounds = parser.getDictBoundsAt(i);
                            if (resDictBounds) {
                                if (resDictBounds.contentStart) {
                                    const resDict = ResourceDict.parse({
                                        parser,
                                        bounds: resDictBounds,
                                        parseInfoGetter: parseInfo.parseInfoGetter,
                                    });
                                    if (resDict) {
                                        this.Resources = resDict.value;
                                    }
                                    else {
                                        throw new Error("Can't parse /Resources value dictionary");
                                    }
                                }
                                i = resDictBounds.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /Resources dictionary bounds");
                        }
                        throw new Error(`Unsupported /Resources property value type: ${resEntryType}`);
                    case "/Measure":
                        const measureEntryType = parser.getValueTypeAt(i);
                        if (measureEntryType === valueTypes.REF) {
                            const measureDictId = ObjectId.parseRef(parser, i);
                            if (measureDictId && parseInfo.parseInfoGetter) {
                                const measureParseInfo = parseInfo.parseInfoGetter(measureDictId.value.id);
                                if (measureParseInfo) {
                                    const measureDict = MeasureDict.parse(measureParseInfo);
                                    if (measureDict) {
                                        this.Measure = measureDict.value;
                                        i = measureDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Measure value reference");
                        }
                        else if (measureEntryType === valueTypes.DICTIONARY) {
                            const measureDictBounds = parser.getDictBoundsAt(i);
                            if (measureDictBounds) {
                                const measureDict = MeasureDict
                                    .parse({ parser, bounds: measureDictBounds, cryptInfo: parseInfo.cryptInfo });
                                if (measureDict) {
                                    this.Measure = measureDict.value;
                                    i = measureDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /Measure value dictionary");
                        }
                        throw new Error(`Unsupported /Measure property value type: ${measureEntryType}`);
                    case "/Group":
                        const groupEntryType = parser.getValueTypeAt(i);
                        if (groupEntryType === valueTypes.REF) {
                            const groupDictId = ObjectId.parseRef(parser, i);
                            if (groupDictId && parseInfo.parseInfoGetter) {
                                const groupParseInfo = parseInfo.parseInfoGetter(groupDictId.value.id);
                                if (groupParseInfo) {
                                    const groupDict = TransparencyGroupDict.parse(groupParseInfo);
                                    if (groupDict) {
                                        this.Group = groupDict.value;
                                        i = groupDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Group value reference");
                        }
                        else if (groupEntryType === valueTypes.DICTIONARY) {
                            const groupDictBounds = parser.getDictBoundsAt(i);
                            if (groupDictBounds) {
                                const groupDict = TransparencyGroupDict
                                    .parse({ parser, bounds: groupDictBounds, cryptInfo: parseInfo.cryptInfo });
                                if (groupDict) {
                                    this.Group = groupDict.value;
                                    i = groupDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /Group value dictionary");
                        }
                        throw new Error(`Unsupported /Group property value type: ${groupEntryType}`);
                    case "/OC":
                    case "/OPI":
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.BBox) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class AppearanceDict extends PdfDict {
    constructor() {
        super(null);
        this._streamsMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new AppearanceDict();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getStream(key) {
        return this._streamsMap.get(key);
    }
    *getStreams() {
        for (const pair of this._streamsMap) {
            yield pair[1];
        }
        return;
    }
    setStream(key, stream) {
        this._streamsMap.set(key, stream);
        this._edited = true;
    }
    clearStreams() {
        this._streamsMap.clear();
        this._edited = true;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        const nStream = this._streamsMap.get("/N");
        if (nStream) {
            bytes.push(...encoder.encode("/N "));
            bytes.push(...ObjectId.fromRef(nStream.ref).toArray(cryptInfo));
        }
        else if (this.N) {
            bytes.push(...encoder.encode("/N "));
            if (this.N instanceof ObjectMapDict) {
                bytes.push(...this.N.toArray(cryptInfo));
            }
            else {
                bytes.push(...this.N.toArray(cryptInfo));
            }
        }
        const rStream = this._streamsMap.get("/R");
        if (rStream) {
            bytes.push(...encoder.encode("/R "));
            bytes.push(...ObjectId.fromRef(rStream.ref).toArray(cryptInfo));
        }
        else if (this.R) {
            bytes.push(...encoder.encode("/R "));
            if (this.R instanceof ObjectMapDict) {
                bytes.push(...this.R.toArray(cryptInfo));
            }
            else {
                bytes.push(...this.R.toArray(cryptInfo));
            }
        }
        const dStream = this._streamsMap.get("/D");
        if (dStream) {
            bytes.push(...encoder.encode("/D "));
            bytes.push(...ObjectId.fromRef(dStream.ref).toArray(cryptInfo));
        }
        else if (this.D) {
            bytes.push(...encoder.encode("/D "));
            if (this.D instanceof ObjectMapDict) {
                bytes.push(...this.D.toArray(cryptInfo));
            }
            else {
                bytes.push(...this.D.toArray(cryptInfo));
            }
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    fillStreamsMap(parseInfoGetter) {
        this._streamsMap.clear();
        for (const prop of ["N", "R", "D"]) {
            if (this[prop]) {
                if (this[prop] instanceof ObjectId) {
                    const streamParseInfo = parseInfoGetter(this[prop].id);
                    if (!streamParseInfo) {
                        continue;
                    }
                    const stream = XFormStream.parse(streamParseInfo);
                    if (!stream) {
                        continue;
                    }
                    if (stream) {
                        this._streamsMap.set(`/${prop}`, stream.value);
                    }
                }
                else {
                    for (const [name, objectId] of this[prop].getProps()) {
                        const streamParseInfo = parseInfoGetter(objectId.id);
                        if (!streamParseInfo) {
                            continue;
                        }
                        const stream = XFormStream.parse(streamParseInfo);
                        if (stream) {
                            this._streamsMap.set(`/${prop}${name}`, stream.value);
                        }
                    }
                }
            }
        }
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/N":
                        const nEntryType = parser.getValueTypeAt(i);
                        if (nEntryType === valueTypes.REF) {
                            const nRefId = ObjectId.parseRef(parser, i);
                            if (nRefId) {
                                this.N = nRefId.value;
                                i = nRefId.end + 1;
                                break;
                            }
                        }
                        else if (nEntryType === valueTypes.DICTIONARY) {
                            const nDictBounds = parser.getDictBoundsAt(i);
                            if (nDictBounds) {
                                const nSubDict = ObjectMapDict.parse({ parser, bounds: nDictBounds });
                                if (nSubDict) {
                                    this.N = nSubDict.value;
                                    i = nSubDict.end + 1;
                                    break;
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /N property value type: ${nEntryType}`);
                        }
                        throw new Error("Can't parse /N property value");
                    case "/R":
                        const rEntryType = parser.getValueTypeAt(i);
                        if (rEntryType === valueTypes.REF) {
                            const rRefId = ObjectId.parseRef(parser, i);
                            if (rRefId) {
                                this.R = rRefId.value;
                                i = rRefId.end + 1;
                                break;
                            }
                        }
                        else if (rEntryType === valueTypes.DICTIONARY) {
                            const rDictBounds = parser.getDictBoundsAt(i);
                            if (rDictBounds) {
                                const rSubDict = ObjectMapDict.parse({ parser, bounds: rDictBounds });
                                if (rSubDict) {
                                    this.R = rSubDict.value;
                                    i = rSubDict.end + 1;
                                    break;
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /R property value type: ${rEntryType}`);
                        }
                        throw new Error("Can't parse /R property value");
                    case "/D":
                        const dEntryType = parser.getValueTypeAt(i);
                        if (dEntryType === valueTypes.REF) {
                            const dRefId = ObjectId.parseRef(parser, i);
                            if (dRefId) {
                                this.D = dRefId.value;
                                i = dRefId.end + 1;
                                break;
                            }
                        }
                        else if (dEntryType === valueTypes.DICTIONARY) {
                            const dDictBounds = parser.getDictBoundsAt(i);
                            if (dDictBounds) {
                                const dSubDict = ObjectMapDict.parse({ parser, bounds: dDictBounds });
                                if (dSubDict) {
                                    this.D = dSubDict.value;
                                    i = dSubDict.end + 1;
                                    break;
                                }
                            }
                        }
                        else {
                            throw new Error(`Unsupported /D property value type: ${dEntryType}`);
                        }
                        throw new Error("Can't parse /D property value");
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.N) {
            throw new Error("Not all required properties parsed");
        }
        if (parseInfo.parseInfoGetter) {
            this.fillStreamsMap(parseInfo.parseInfoGetter);
        }
    }
}

const borderEffects = {
    NONE: "/S",
    CLOUDY: "/C",
};
class BorderEffectDict extends PdfDict {
    constructor() {
        super(null);
        this.S = borderEffects.NONE;
        this.L = 0;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new BorderEffectDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.S) {
            bytes.push(...encoder.encode("/S "), ...encoder.encode(this.S));
        }
        if (this.L) {
            bytes.push(...encoder.encode("/L "), ...encoder.encode(" " + this.L));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/S":
                        const style = parser.parseNameAt(i, true);
                        if (style && Object.values(borderEffects).includes(style.value)) {
                            this.S = style.value;
                            i = style.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /S property value");
                        }
                        break;
                    case "/L":
                        i = this.parseNumberProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class BorderArray {
    constructor(hCornerR, vCornerR, width, dash, gap) {
        this.hCornerR = hCornerR !== null && hCornerR !== void 0 ? hCornerR : 0;
        this.vCornerR = vCornerR !== null && vCornerR !== void 0 ? vCornerR : 0;
        this.width = width !== null && width !== void 0 ? width : 1;
        this.dash = dash !== null && dash !== void 0 ? dash : 3;
        this.gap = gap !== null && gap !== void 0 ? gap : 0;
    }
    static parse(parser, start, skipEmpty = true) {
        if (skipEmpty) {
            start = parser.findNonSpaceIndex("straight", start);
        }
        if (start < 0 || start > parser.maxIndex
            || parser.getCharCode(start) !== codes.L_BRACKET) {
            return null;
        }
        const hCornerR = parser.parseNumberAt(start + 1);
        if (!hCornerR || isNaN(hCornerR.value)) {
            return null;
        }
        const vCornerR = parser.parseNumberAt(hCornerR.end + 2);
        if (!vCornerR || isNaN(vCornerR.value)) {
            return null;
        }
        const width = parser.parseNumberAt(vCornerR.end + 2);
        if (!width || isNaN(width.value)) {
            return null;
        }
        const next = parser.findNonSpaceIndex("straight", width.end + 1);
        if (!next) {
            return null;
        }
        else if (parser.getCharCode(next) === codes.R_BRACKET) {
            return {
                value: new BorderArray(hCornerR.value, vCornerR.value, width.value),
                start,
                end: next,
            };
        }
        else if (parser.getCharCode(next) === codes.L_BRACKET) {
            const dash = parser.parseNumberAt(next + 1);
            if (!dash || isNaN(dash.value)) {
                return null;
            }
            const gap = parser.parseNumberAt(dash.end + 2);
            if (!gap || isNaN(gap.value)) {
                return null;
            }
            const dashEnd = parser.findNonSpaceIndex("straight", gap.end + 1);
            if (!dashEnd || parser.getCharCode(dashEnd) !== codes.R_BRACKET) {
                return null;
            }
            const arrayEnd = parser.findNonSpaceIndex("straight", dashEnd + 1);
            if (!arrayEnd || parser.getCharCode(arrayEnd) !== codes.R_BRACKET) {
                return null;
            }
            return {
                value: new BorderArray(hCornerR.value, vCornerR.value, width.value, dash.value, gap.value),
                start,
                end: arrayEnd,
            };
        }
        return null;
    }
    toArray(cryptInfo) {
        const source = this.dash && this.gap
            ? `[${this.hCornerR} ${this.vCornerR} ${this.width}]`
            : `[${this.hCornerR} ${this.vCornerR} ${this.width} [${this.dash} ${this.gap}]]`;
        return new TextEncoder().encode(source);
    }
}

class TextState {
    constructor(params) {
        Object.assign(this, TextState.defaultParams, params);
    }
    clone(params) {
        const copy = new TextState(this);
        if (params) {
            return Object.assign(copy, params);
        }
        return copy;
    }
}
TextState.defaultParams = {
    fontFamily: "helvetica, sans-serif",
    fontSize: "12px",
    lineHeight: "1",
    letterSpacing: "normal",
    wordSpacing: "normal",
    textHorScale: 1,
    textRenderMode: textRenderModes.FILL,
    textVertAlign: "0",
    textKnockOut: true,
};

class GraphicsState {
    constructor(params) {
        var _a, _b, _c, _d;
        Object.assign(this, GraphicsState.defaultParams, params);
        this.matrix = (_a = this.matrix) === null || _a === void 0 ? void 0 : _a.clone();
        this.textState = (_b = this.textState) === null || _b === void 0 ? void 0 : _b.clone();
        this.strokeColor = (_c = this.strokeColor) === null || _c === void 0 ? void 0 : _c.clone();
        this.fillColor = (_d = this.fillColor) === null || _d === void 0 ? void 0 : _d.clone();
    }
    get stroke() {
        const { x: r, y: g, z: b } = this.strokeColor;
        const a = this.strokeAlpha;
        return `rgba(${r},${g},${b},${a})`;
    }
    get fill() {
        const { x: r, y: g, z: b } = this.fillColor;
        const a = this.fillAlpha;
        return `rgba(${r},${g},${b},${a})`;
    }
    clone(params) {
        const copy = new GraphicsState(this);
        if (params) {
            return Object.assign(copy, params);
        }
        return copy;
    }
    setColor(type, ...params) {
        let r, g, b;
        switch (params.length) {
            case 1:
                r = g = b = params[0] * 255;
                break;
            case 3:
                r = params[0] * 255;
                g = params[1] * 255;
                b = params[2] * 255;
                break;
            case 4:
                const [c, m, y, k] = params;
                r = 255 * (1 - c) * (1 - k);
                g = 255 * (1 - m) * (1 - k);
                b = 255 * (1 - y) * (1 - k);
                break;
        }
        if (type === "stroke") {
            this.strokeColor.set(r, g, b);
        }
        else {
            this.fillColor.set(r, g, b);
        }
    }
}
GraphicsState.defaultParams = {
    matrix: new Mat3(),
    textState: new TextState(),
    strokeColorSpace: "rgb",
    strokeAlpha: 1,
    strokeColor: new Vec3(),
    fillColorSpace: "rgb",
    fillAlpha: 1,
    fillColor: new Vec3(),
    strokeWidth: 1,
    strokeMiterLimit: 10,
    strokeLineCap: "square",
    strokeLineJoin: "miter",
};

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AppearanceStreamRenderer {
    constructor(stream, rect, objectName) {
        this._clipPaths = [];
        this._graphicsStates = [];
        if (!stream) {
            throw new Error("Stream is not defined");
        }
        this._stream = stream;
        this._parser = new DataParser(stream.decodedStreamData);
        this._rect = rect;
        this._objectName = objectName;
        const matAA = AppearanceStreamRenderer.calcBBoxToRectMatrix(stream, rect);
        const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
        clipPath.id = `clip0_${objectName}`;
        clipPath.innerHTML = `<rect x="${rect[0]}" y="${rect[1]}" width="${rect[2] - rect[0]}" height="${rect[3] - rect[1]}" />`;
        this._clipPaths.push(clipPath);
        this._graphicsStates.push(new GraphicsState({ matrix: matAA }));
    }
    get state() {
        return this._graphicsStates[this._graphicsStates.length - 1];
    }
    static calcBBoxToRectMatrix(stream, rect) {
        const matrix = stream.matrix;
        const { ll: bBoxLL, lr: bBoxLR, ur: bBoxUR, ul: bBoxUL } = stream.bBox;
        const { min: appBoxMin, max: appBoxMax } = vecMinMax(Vec2.applyMat3(bBoxLL, matrix), Vec2.applyMat3(bBoxLR, matrix), Vec2.applyMat3(bBoxUR, matrix), Vec2.applyMat3(bBoxUL, matrix));
        const rectMin = new Vec2(rect[0], rect[1]);
        const rectMax = new Vec2(rect[2], rect[3]);
        const matA = mat3From4Vec2(appBoxMin, appBoxMax, rectMin, rectMax);
        const matAA = Mat3.fromMat3(matrix).multiply(matA);
        return matAA;
    }
    static parseNextCommand(parser, i) {
        const parameters = [];
        let operator;
        command: while (!operator) {
            const nextValueType = parser.getValueTypeAt(i, true);
            switch (nextValueType) {
                case valueTypes.NUMBER:
                    const numberResult = parser.parseNumberAt(i, true);
                    parameters.push(numberResult.value);
                    i = numberResult.end + 1;
                    break;
                case valueTypes.NAME:
                    const nameResult = parser.parseNameAt(i, true);
                    parameters.push(nameResult.value);
                    i = nameResult.end + 1;
                    break;
                case valueTypes.ARRAY:
                    const arrayBounds = parser.getArrayBoundsAt(i);
                    const numberArrayResult = parser.parseNumberArrayAt(i, true);
                    if (numberArrayResult) {
                        const dashArray = numberArrayResult.value;
                        if (dashArray.length === 2) {
                            parameters.push(...dashArray);
                        }
                        else if (dashArray.length === 1) {
                            parameters.push(dashArray[0], 0);
                        }
                        else {
                            parameters.push(3, 0);
                        }
                    }
                    else {
                        throw new Error(`Invalid appearance stream array: 
            ${parser.sliceChars(arrayBounds.start, arrayBounds.end)}`);
                    }
                    i = arrayBounds.end + 1;
                    break;
                case valueTypes.STRING_LITERAL:
                    const literalResult = LiteralString.parse(parser, i);
                    parameters.push(literalResult.value.literal);
                    i = literalResult.end + 1;
                    break;
                case valueTypes.STRING_HEX:
                    const hexResult = HexString.parse(parser, i);
                    parameters.push(hexResult.value.hex);
                    i = hexResult.end + 1;
                    break;
                case valueTypes.UNKNOWN:
                    const operatorResult = parser.parseStringAt(i);
                    operator = operatorResult.value;
                    i = operatorResult.end + 1;
                    break command;
                default:
                    throw new Error(`Invalid appearance stream value type: ${nextValueType}`);
            }
        }
        return { endIndex: i, parameters, operator };
    }
    renderAsync() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const g = yield this.drawGroupAsync(this._parser);
            return {
                svg: g,
                clipPaths: this._clipPaths,
            };
        });
    }
    pushState(params) {
        const lastState = this._graphicsStates[this._graphicsStates.length - 1];
        const newState = lastState.clone(params);
        this._graphicsStates.push(newState);
    }
    popState() {
        if (this._graphicsStates.length === 1) {
            return null;
        }
        return this._graphicsStates.pop();
    }
    drawPath(d, stroke, fill, close = false, evenOdd = false) {
        if (close && d[d.length - 1] !== "Z") {
            d += " Z";
        }
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("transform", `matrix(${this.state.matrix.toFloatShortArray().join(" ")})`);
        path.setAttribute("clipPath", `url(#${this._clipPaths[this._clipPaths.length - 1].id})`);
        path.setAttribute("d", d);
        if (this.state.mixBlendMode) {
            path.setAttribute("mix-blend-mode", this.state.mixBlendMode);
        }
        if (fill) {
            path.setAttribute("fill", this.state.fill);
            path.setAttribute("fill-rule", evenOdd ? "evenodd" : "nonzero");
        }
        else {
            path.setAttribute("fill", "none");
        }
        if (stroke) {
            path.setAttribute("stroke", this.state.stroke);
            path.setAttribute("stroke-width", this.state.strokeWidth + "");
            path.setAttribute("stroke-miterlimit", this.state.strokeMiterLimit + "");
            path.setAttribute("stroke-linecap", this.state.strokeLineCap);
            path.setAttribute("stroke-linejoin", this.state.strokeLineJoin);
            if (this.state.strokeDashArray) {
                path.setAttribute("stroke-dasharray", this.state.strokeDashArray);
            }
            if (this.state.strokeDashOffset) {
                path.setAttribute("stroke-dashoffset", this.state.strokeDashOffset + "");
            }
        }
        else {
            path.setAttribute("stroke", "none");
        }
        return path;
    }
    drawText(value) {
        throw new Error("Method is not implemented");
    }
    drawTextGroup(parser) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        let i = 0;
        while (i !== -1) {
            const { endIndex, parameters, operator } = AppearanceStreamRenderer.parseNextCommand(parser, i);
            i = parser.skipEmpty(endIndex + 1);
        }
        return g;
    }
    drawGroupAsync(parser) {
        return __awaiter$1(this, void 0, void 0, function* () {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            const lastCoord = new Vec2();
            let lastOperator;
            let d = "";
            const addPath = (path) => {
                g.append(path);
                d = "";
            };
            let i = 0;
            while (i !== -1) {
                const { endIndex, parameters, operator } = AppearanceStreamRenderer.parseNextCommand(parser, i);
                i = parser.skipEmpty(endIndex + 1);
                switch (operator) {
                    case "q":
                        this.pushState();
                        break;
                    case "Q":
                        this.popState();
                        break;
                    case "gs":
                        const externalState = this._stream.Resources.getGraphicsState(`/ExtGState${parameters[0]}`);
                        if (!externalState) {
                            throw new Error("External state specified in appearance stream not found");
                        }
                        const params = externalState.toParams();
                        Object.assign(this.state, params);
                        break;
                    case "cm":
                        const [m0, m1, m3, m4, m6, m7] = parameters;
                        const matrix = new Mat3().set(m0, m1, 0, m3, m4, 0, m6, m7, 1);
                        this.state.matrix = matrix.multiply(this.state.matrix);
                        break;
                    case "w":
                        this.state.strokeWidth = +parameters[0] || 1;
                        break;
                    case "J":
                        switch (parameters[0]) {
                            case lineCapStyles.ROUND:
                                this.state.strokeLineCap = "round";
                                break;
                            case lineCapStyles.SQUARE:
                                this.state.strokeLineCap = "square";
                                break;
                            case lineCapStyles.BUTT:
                            default:
                                this.state.strokeLineCap = "butt";
                                break;
                        }
                        break;
                    case "j":
                        switch (parameters[0]) {
                            case lineJoinStyles.BEVEL:
                                this.state.strokeLineJoin = "bevel";
                                break;
                            case lineJoinStyles.ROUND:
                                this.state.strokeLineJoin = "round";
                                break;
                            case lineJoinStyles.MITER:
                            default:
                                this.state.strokeLineJoin = "miter";
                                break;
                        }
                        break;
                    case "M":
                        this.state.strokeMiterLimit = +parameters[0] || 10;
                        break;
                    case "d":
                        this.state.strokeDashArray = `${parameters[0]} ${parameters[1]}`;
                        this.state.strokeDashOffset = +parameters[2];
                        break;
                    case "CS":
                        switch (parameters[0]) {
                            case colorSpaces.GRAYSCALE:
                                this.state.strokeColorSpace = "grayscale";
                                break;
                            case colorSpaces.RGB:
                                this.state.strokeColorSpace = "rgb";
                                break;
                            case colorSpaces.CMYK:
                                this.state.strokeColorSpace = "cmyk";
                                break;
                            default:
                                throw new Error("Unsupported color space in appearance stream");
                        }
                        break;
                    case "cs":
                        switch (parameters[0]) {
                            case colorSpaces.GRAYSCALE:
                                this.state.fillColorSpace = "grayscale";
                                break;
                            case colorSpaces.RGB:
                                this.state.fillColorSpace = "rgb";
                                break;
                            case colorSpaces.CMYK:
                                this.state.fillColorSpace = "cmyk";
                                break;
                            default:
                                throw new Error("Unsupported color space in appearance stream");
                        }
                        break;
                    case "G":
                        this.state.strokeColorSpace = "grayscale";
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "g":
                        this.state.fillColorSpace = "grayscale";
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "RG":
                        this.state.strokeColorSpace = "rgb";
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "rg":
                        this.state.fillColorSpace = "rgb";
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "K":
                        this.state.strokeColorSpace = "cmyk";
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "k":
                        this.state.fillColorSpace = "cmyk";
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "SC":
                        this.state.setColor("stroke", ...parameters);
                        break;
                    case "cs":
                        this.state.setColor("fill", ...parameters);
                        break;
                    case "ri":
                    case "i":
                        break;
                    case "m":
                        const move = new Vec2(+parameters[0], +parameters[1]);
                        d += ` M ${move.x} ${move.y}`;
                        lastCoord.setFromVec2(move);
                        break;
                    case "l":
                        const line = new Vec2(+parameters[0], +parameters[1]);
                        d += ` L ${line.x} ${line.y}`;
                        lastCoord.setFromVec2(line);
                        break;
                    case "re":
                        const rMin = new Vec2(+parameters[0], +parameters[1]);
                        const rMax = new Vec2(+parameters[2], +parameters[3]).add(rMin);
                        d += ` M ${rMin.x} ${rMin.y} L ${rMax.x} ${rMin.y} L ${rMax.x} ${rMax.y} L ${rMin.x} ${rMax.y} L ${rMin.x} ${rMin.y}`;
                        lastCoord.setFromVec2(rMin);
                        break;
                    case "c":
                        const cControl1 = new Vec2(+parameters[0], +parameters[1]);
                        const cControl2 = new Vec2(+parameters[2], +parameters[3]);
                        const cEnd = new Vec2(+parameters[4], +parameters[5]);
                        d += ` C ${cControl1.x} ${cControl1.y}, ${cControl2.x} ${cControl2.y}, ${cEnd.x} ${cEnd.y}`;
                        lastCoord.setFromVec2(cEnd);
                        break;
                    case "v":
                        const vControl2 = new Vec2(+parameters[0], +parameters[1]);
                        const vEnd = new Vec2(+parameters[2], +parameters[3]);
                        d += ` C ${lastCoord.x} ${lastCoord.y}, ${vControl2.x} ${vControl2.y}, ${vEnd.x} ${vEnd.y}`;
                        lastCoord.setFromVec2(vEnd);
                        break;
                    case "y":
                        const yControl1 = new Vec2(+parameters[0], +parameters[1]);
                        const yEnd = new Vec2(+parameters[2], +parameters[3]);
                        d += ` C ${yControl1.x} ${yControl1.y}, ${yEnd.x} ${yEnd.y}, ${yEnd.x} ${yEnd.y}`;
                        lastCoord.setFromVec2(yEnd);
                        break;
                    case "h":
                        d += " Z";
                        break;
                    case "S":
                        addPath(this.drawPath(d, true, false));
                        break;
                    case "s":
                        addPath(this.drawPath(d, true, false, true));
                        break;
                    case "F":
                    case "f":
                        addPath(this.drawPath(d, false, true, true));
                        break;
                    case "F*":
                    case "f*":
                        addPath(this.drawPath(d, false, true, true, true));
                        break;
                    case "B":
                        addPath(this.drawPath(d, true, true, false, false));
                        break;
                    case "B*":
                        addPath(this.drawPath(d, true, true, false, true));
                        break;
                    case "b":
                        addPath(this.drawPath(d, true, true, true, false));
                        break;
                    case "b*":
                        addPath(this.drawPath(d, true, true, true, true));
                        break;
                    case "n":
                        if (lastOperator === "W" || lastOperator === "W*") {
                            if (d[d.length - 1] !== "Z") {
                                d += " Z";
                            }
                            const clippingPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                            clippingPath.setAttribute("d", d);
                            const lastCpIndex = this._clipPaths.length - 1;
                            const clipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
                            clipPath.setAttribute("clip-rule", lastOperator === "W" ? "nonzero" : "evenodd");
                            clipPath.setAttribute("clip-path", `url(#${this._clipPaths[lastCpIndex]})`);
                            clipPath.id = `clip${lastCpIndex + 1}_${this._objectName}`;
                            clipPath.append(clippingPath);
                            this._clipPaths.push(clipPath);
                            this.state.clipPath = clipPath;
                        }
                        d = "";
                        break;
                    case "W":
                        break;
                    case "W*":
                        break;
                    case "BT":
                        const textObjectEnd = parser.findSubarrayIndex([codes.E, codes.T], {
                            closedOnly: true,
                            minIndex: i,
                        });
                        if (textObjectEnd) {
                            const textGroup = this.drawTextGroup(new DataParser(parser.sliceCharCodes(i, textObjectEnd.start - 1)));
                            g.append(textGroup);
                            i = parser.skipEmpty(textObjectEnd.end + 1);
                            break;
                        }
                        throw new Error("Can't find the appearance stream text object end");
                    case "Do":
                        const stream = this._stream.Resources.getXObject((`/XObject${parameters[0]}`));
                        if (!stream) {
                            throw new Error(`External object not found in the appearance stream resources: ${parameters[0]}`);
                        }
                        if (stream instanceof XFormStream) {
                            const subGroup = yield this.drawGroupAsync(new DataParser(stream.decodedStreamData));
                            g.append(subGroup);
                        }
                        else if (stream instanceof ImageStream) {
                            const url = yield stream.getImageUrlAsync();
                            if (!url) {
                                throw new Error("Can't get image url from external image stream");
                            }
                            const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
                            image.onerror = e => {
                                console.log(`Loading external image stream failed: ${e}`);
                            };
                            image.setAttribute("href", url);
                            image.setAttribute("width", stream.Width + "");
                            image.setAttribute("height", stream.Height + "");
                            const imageMatrix = new Mat3()
                                .applyTranslation(-stream.Width / 2, -stream.Height / 2)
                                .applyScaling(1, -1)
                                .applyTranslation(stream.Width / 2, stream.Height / 2)
                                .applyScaling(1 / stream.Width, 1 / stream.Height)
                                .multiply(this.state.matrix);
                            image.setAttribute("transform", `matrix(${imageMatrix.toFloatShortArray().join(" ")})`);
                            image.setAttribute("clipPath", `url(#${this._clipPaths[this._clipPaths.length - 1].id})`);
                            g.append(image);
                        }
                        else {
                            throw new Error(`Unsupported appearance stream external object: ${parameters[0]}`);
                        }
                        break;
                    default:
                        throw new Error(`Unsupported appearance stream operator: ${operator}`);
                }
                lastOperator = operator;
            }
            return g;
        });
    }
}

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AnnotationDict extends PdfDict {
    constructor(subType) {
        super(dictTypes.ANNOTATION);
        this.F = 0;
        this.Border = new BorderArray(0, 0, 1);
        this._transformationMatrix = new Mat3();
        this._transformationPoint = new Vec2();
        this._currentAngle = 0;
        this._boxX = new Vec2();
        this._boxY = new Vec2();
        this._svgId = getRandomUuid();
        this.onRectPointerDown = (e) => {
            document.addEventListener("pointerup", this.onRectPointerUp);
            document.addEventListener("pointerout", this.onRectPointerUp);
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                this._transformationPoint.setFromVec2(this.convertClientCoordsToPage(e.clientX, e.clientY));
                document.addEventListener("pointermove", this.onRectPointerMove);
            }, 200);
        };
        this.onRectPointerMove = (e) => {
            const current = this.convertClientCoordsToPage(e.clientX, e.clientY);
            this._transformationMatrix.reset()
                .applyTranslation(current.x - this._transformationPoint.x, current.y - this._transformationPoint.y);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._transformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onRectPointerUp = () => {
            document.removeEventListener("pointermove", this.onRectPointerMove);
            document.removeEventListener("pointerup", this.onRectPointerUp);
            document.removeEventListener("pointerout", this.onRectPointerUp);
            if (this._transformationTimer) {
                clearTimeout(this._transformationTimer);
                this._transformationTimer = null;
                return;
            }
            this._svgContentCopy.remove();
            this._svgContentCopyUse.setAttribute("transform", "matrix(1 0 0 1 0 0)");
            this.applyRectTransform(this._transformationMatrix);
            this._transformationMatrix.reset();
            this.updateRenderAsync();
        };
        this.onRotationHandlePointerDown = (e) => {
            document.addEventListener("pointerup", this.onRotationHandlePointerUp);
            document.addEventListener("pointerout", this.onRotationHandlePointerUp);
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                document.addEventListener("pointermove", this.onRotationHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onRotationHandlePointerMove = (e) => {
            const centerX = (this.Rect[0] + this.Rect[2]) / 2;
            const centerY = (this.Rect[1] + this.Rect[3]) / 2;
            const clientCenter = this.convertPageCoordsToClient(centerX, centerY);
            const currentRotation = this.getCurrentRotation();
            const angle = Math.atan2(e.clientY - clientCenter.y, e.clientX - clientCenter.x) + Math.PI / 2 - currentRotation;
            this._currentAngle = angle;
            this._transformationMatrix.reset()
                .applyTranslation(-centerX, -centerY)
                .applyRotation(angle)
                .applyTranslation(centerX, centerY);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._transformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onRotationHandlePointerUp = (e) => {
            document.removeEventListener("pointermove", this.onRotationHandlePointerMove);
            document.removeEventListener("pointerup", this.onRotationHandlePointerUp);
            document.removeEventListener("pointerout", this.onRotationHandlePointerUp);
            if (this._transformationTimer) {
                clearTimeout(this._transformationTimer);
                this._transformationTimer = null;
                return;
            }
            this._svgContentCopy.remove();
            this._svgContentCopyUse.setAttribute("transform", "matrix(1 0 0 1 0 0)");
            this.applyRectTransform(this._transformationMatrix);
            this._transformationMatrix.reset();
            this.updateRenderAsync();
        };
        this.onScaleHandlePointerDown = (e) => {
            document.addEventListener("pointerup", this.onScaleHandlePointerUp);
            document.addEventListener("pointerout", this.onScaleHandlePointerUp);
            const target = e.target;
            const { ll, lr, ur, ul } = this.getLocalBB();
            const handleName = target.dataset["handleName"];
            switch (handleName) {
                case "ll":
                    this._transformationPoint.setFromVec2(ur);
                    this._boxX.setFromVec2(ul).substract(ur);
                    this._boxY.setFromVec2(lr).substract(ur);
                    break;
                case "lr":
                    this._transformationPoint.setFromVec2(ul);
                    this._boxX.setFromVec2(ur).substract(ul);
                    this._boxY.setFromVec2(ll).substract(ul);
                    break;
                case "ur":
                    this._transformationPoint.setFromVec2(ll);
                    this._boxX.setFromVec2(lr).substract(ll);
                    this._boxY.setFromVec2(ul).substract(ll);
                    break;
                case "ul":
                    this._transformationPoint.setFromVec2(lr);
                    this._boxX.setFromVec2(ll).substract(lr);
                    this._boxY.setFromVec2(ur).substract(lr);
                    break;
                default:
                    throw new Error(`Invalid handle name: ${handleName}`);
            }
            this._boxXLength = this._boxX.getMagnitude();
            this._boxYLength = this._boxY.getMagnitude();
            this._transformationTimer = setTimeout(() => {
                this._transformationTimer = null;
                this._svg.after(this._svgContentCopy);
                document.addEventListener("pointermove", this.onScaleHandlePointerMove);
            }, 200);
            e.stopPropagation();
        };
        this.onScaleHandlePointerMove = (e) => {
            const current = this.convertClientCoordsToPage(e.clientX, e.clientY)
                .substract(this._transformationPoint);
            const currentLength = current.getMagnitude();
            const cos = Math.abs(current.dotProduct(this._boxX)) / currentLength / this._boxXLength;
            const pXLength = cos * currentLength;
            const pYLength = Math.sqrt(currentLength * currentLength - pXLength * pXLength);
            const scaleX = pXLength / this._boxXLength;
            const scaleY = pYLength / this._boxYLength;
            const centerX = (this.Rect[0] + this.Rect[2]) / 2;
            const centerY = (this.Rect[1] + this.Rect[3]) / 2;
            const currentRotation = this.getCurrentRotation();
            this._transformationMatrix.reset()
                .applyTranslation(-centerX, -centerY)
                .applyRotation(-currentRotation)
                .applyScaling(scaleX, scaleY)
                .applyRotation(currentRotation)
                .applyTranslation(centerX, centerY);
            const translation = this._transformationPoint.clone().substract(this._transformationPoint.clone().applyMat3(this._transformationMatrix));
            this._transformationMatrix.applyTranslation(translation.x, translation.y);
            this._svgContentCopyUse.setAttribute("transform", `matrix(${this._transformationMatrix.toFloatShortArray().join(" ")})`);
        };
        this.onScaleHandlePointerUp = (e) => {
            document.removeEventListener("pointermove", this.onScaleHandlePointerMove);
            document.removeEventListener("pointerup", this.onScaleHandlePointerUp);
            document.removeEventListener("pointerout", this.onScaleHandlePointerUp);
            if (this._transformationTimer) {
                clearTimeout(this._transformationTimer);
                this._transformationTimer = null;
                return;
            }
            this._svgContentCopy.remove();
            this._svgContentCopyUse.setAttribute("transform", "matrix(1 0 0 1 0 0)");
            this.applyRectTransform(this._transformationMatrix);
            this._transformationMatrix.reset();
            this.updateRenderAsync();
        };
        this.Subtype = subType;
    }
    get apStream() {
        var _a;
        if (!this._apStream) {
            this._apStream = [...(_a = this.AP) === null || _a === void 0 ? void 0 : _a.getStreams()][0];
        }
        return this._apStream;
    }
    set apStream(value) {
        this._apStream = value;
        this._edited = true;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Subtype) {
            bytes.push(...encoder.encode("/Subtype "), ...encoder.encode(this.Subtype));
        }
        if (this.Rect) {
            bytes.push(...encoder.encode("/Rect "), codes.L_BRACKET, ...encoder.encode(this.Rect[0] + ""), codes.WHITESPACE, ...encoder.encode(this.Rect[1] + ""), codes.WHITESPACE, ...encoder.encode(this.Rect[2] + ""), codes.WHITESPACE, ...encoder.encode(this.Rect[3] + ""), codes.R_BRACKET);
        }
        if (this.Contents) {
            bytes.push(...encoder.encode("/Contents "), ...this.Contents.toArray(cryptInfo));
        }
        if (this.P) {
            bytes.push(...encoder.encode("/P "), codes.WHITESPACE, ...this.P.toArray(cryptInfo));
        }
        if (this.NM) {
            bytes.push(...encoder.encode("/NM "), ...this.NM.toArray(cryptInfo));
        }
        if (this.M) {
            bytes.push(...encoder.encode("/M "), ...this.M.toArray(cryptInfo));
        }
        if (this.F) {
            bytes.push(...encoder.encode("/F "), ...encoder.encode(" " + this.F));
        }
        if (this.AS) {
            bytes.push(...encoder.encode("/AS "), ...encoder.encode(this.AS));
        }
        if (this.Border) {
            bytes.push(...encoder.encode("/Border "), ...this.Border.toArray(cryptInfo));
        }
        if (this.BS) {
            bytes.push(...encoder.encode("/BS "), ...this.BS.toArray(cryptInfo));
        }
        if (this.BE) {
            bytes.push(...encoder.encode("/BE "), ...this.BE.toArray(cryptInfo));
        }
        if (this.C) {
            bytes.push(...encoder.encode("/C "), codes.L_BRACKET);
            this.C.forEach(x => bytes.push(...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.apStream) {
            if (!this.AP) {
                this.AP = new AppearanceDict();
            }
            const apStreamRef = this.apStream.ref;
            if (!apStreamRef) {
                throw new Error("Appearance stream has no reference");
            }
            this.AP.N = ObjectId.fromRef(apStreamRef);
            this.AP.R = null;
            this.AP.D = null;
            this.AP.clearStreams();
            this.AP.setStream("/N", this.apStream);
            bytes.push(...encoder.encode("/AP "), ...this.AP.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    renderAsync() {
        return __awaiter$2(this, void 0, void 0, function* () {
            if (!this._svg) {
                this._svg = this.renderMainElement();
            }
            yield this.updateRenderAsync();
            return {
                svg: this._svg,
                clipPaths: this._svgClipPaths,
                tempCopy: this._svgContentCopy,
                tempCopyUse: this._svgContentCopyUse,
            };
        });
    }
    applyRectTransform(matrix) {
        const dict = this._proxy || this;
        const bBox = dict.getLocalBB();
        bBox.ll.applyMat3(matrix);
        bBox.lr.applyMat3(matrix);
        bBox.ur.applyMat3(matrix);
        bBox.ul.applyMat3(matrix);
        const { min: newRectMin, max: newRectMax } = vecMinMax(bBox.ll, bBox.lr, bBox.ur, bBox.ul);
        dict.Rect = [newRectMin.x, newRectMin.y, newRectMax.x, newRectMax.y];
        const stream = dict.apStream;
        if (stream) {
            const newApMatrix = stream.matrix.multiply(matrix);
            dict.apStream.matrix = newApMatrix;
        }
        dict.M = DateString.fromDate(new Date());
    }
    moveTo(pageX, pageY) {
        const width = this.Rect[2] - this.Rect[0];
        const height = this.Rect[3] - this.Rect[1];
        const x = pageX - width / 2;
        const y = pageY - height / 2;
        const mat = Mat3.buildTranslate(x, y);
        this.applyRectTransform(mat);
    }
    parseProps(parseInfo) {
        var _a;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Subtype":
                        const subtype = parser.parseNameAt(i);
                        if (subtype) {
                            if (this.Subtype && this.Subtype !== subtype.value) {
                                throw new Error(`Ivalid dict subtype: '${subtype.value}' instead of '${this.Subtype}'`);
                            }
                            i = subtype.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Subtype property value");
                        }
                        break;
                    case "/Rect":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/P":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Contents":
                    case "/NM":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/M":
                        const date = DateString.parse(parser, i, parseInfo.cryptInfo);
                        if (date) {
                            this.M = date.value;
                            i = date.end + 1;
                            break;
                        }
                        else {
                            const dateLiteral = LiteralString.parse(parser, i, parseInfo.cryptInfo);
                            if (dateLiteral) {
                                this.M = dateLiteral.value;
                                i = dateLiteral.end + 1;
                                break;
                            }
                        }
                        throw new Error("Can't parse /M property value");
                    case "/C":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/F":
                    case "/StructParent":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Border":
                        const borderArray = BorderArray.parse(parser, i);
                        if (borderArray) {
                            this.Border = borderArray.value;
                            i = borderArray.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /Border property value");
                        }
                        break;
                    case "/BS":
                        const bsEntryType = parser.getValueTypeAt(i);
                        if (bsEntryType === valueTypes.REF) {
                            const bsDictId = ObjectId.parseRef(parser, i);
                            if (bsDictId && parseInfo.parseInfoGetter) {
                                const bsParseInfo = parseInfo.parseInfoGetter(bsDictId.value.id);
                                if (bsParseInfo) {
                                    const bsDict = BorderStyleDict.parse(bsParseInfo);
                                    if (bsDict) {
                                        this.BS = bsDict.value;
                                        i = bsDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /BS value reference");
                        }
                        else if (bsEntryType === valueTypes.DICTIONARY) {
                            const bsDictBounds = parser.getDictBoundsAt(i);
                            if (bsDictBounds) {
                                const bsDict = BorderStyleDict.parse({ parser, bounds: bsDictBounds });
                                if (bsDict) {
                                    this.BS = bsDict.value;
                                    i = bsDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /BS value dictionary");
                        }
                        throw new Error(`Unsupported /BS property value type: ${bsEntryType}`);
                    case "/BE":
                        const beEntryType = parser.getValueTypeAt(i);
                        if (beEntryType === valueTypes.REF) {
                            const bsDictId = ObjectId.parseRef(parser, i);
                            if (bsDictId && parseInfo.parseInfoGetter) {
                                const bsParseInfo = parseInfo.parseInfoGetter(bsDictId.value.id);
                                if (bsParseInfo) {
                                    const bsDict = BorderEffectDict.parse(bsParseInfo);
                                    if (bsDict) {
                                        this.BE = bsDict.value;
                                        i = bsDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /BE value reference");
                        }
                        else if (beEntryType === valueTypes.DICTIONARY) {
                            const bsDictBounds = parser.getDictBoundsAt(i);
                            if (bsDictBounds) {
                                const bsDict = BorderEffectDict.parse({ parser, bounds: bsDictBounds });
                                if (bsDict) {
                                    this.BE = bsDict.value;
                                    i = bsDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /BE value dictionary");
                        }
                        throw new Error(`Unsupported /BE property value type: ${beEntryType}`);
                    case "/AP":
                        const apEntryType = parser.getValueTypeAt(i);
                        if (apEntryType === valueTypes.REF) {
                            const apDictId = ObjectId.parseRef(parser, i);
                            if (apDictId && parseInfo.parseInfoGetter) {
                                const apParseInfo = parseInfo.parseInfoGetter(apDictId.value.id);
                                if (apParseInfo) {
                                    const apDict = AppearanceDict.parse(apParseInfo);
                                    if (apDict) {
                                        this.AP = apDict.value;
                                        i = apDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /AP value reference");
                        }
                        else if (apEntryType === valueTypes.DICTIONARY) {
                            const apDictBounds = parser.getDictBoundsAt(i);
                            if (apDictBounds) {
                                const apDict = AppearanceDict.parse({
                                    parser,
                                    bounds: apDictBounds,
                                    parseInfoGetter: parseInfo.parseInfoGetter,
                                });
                                if (apDict) {
                                    this.AP = apDict.value;
                                    i = apDict.end + 1;
                                    break;
                                }
                            }
                            throw new Error("Can't parse /AP value dictionary");
                        }
                        throw new Error(`Unsupported /AP property value type: ${apEntryType}`);
                    case "/AS":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/OC":
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Subtype || !this.Rect) {
            throw new Error("Not all required properties parsed");
        }
        this.name = ((_a = this.NM) === null || _a === void 0 ? void 0 : _a.literal) || getRandomUuid();
        this.pageRect = parseInfo.rect;
    }
    getCurrentRotation() {
        var _a;
        const matrix = (_a = this.apStream) === null || _a === void 0 ? void 0 : _a.matrix;
        if (!matrix) {
            return 0;
        }
        const { r } = matrix.getTRS();
        return r;
    }
    getLocalBB() {
        let bBoxLL;
        let bBoxLR;
        let bBoxUR;
        let bBoxUL;
        if (this._bBox) {
            bBoxLL = this._bBox.ll;
            bBoxLR = this._bBox.lr;
            bBoxUR = this._bBox.ur;
            bBoxUL = this._bBox.ul;
        }
        else if (this.apStream) {
            const { ll: apTrBoxLL, lr: apTrBoxLR, ur: apTrBoxUR, ul: apTrBoxUL } = this.apStream.transformedBBox;
            const { min: boxMin, max: boxMax } = vecMinMax(apTrBoxLL, apTrBoxLR, apTrBoxUR, apTrBoxUL);
            const rectMin = new Vec2(this.Rect[0], this.Rect[1]);
            const rectMax = new Vec2(this.Rect[2], this.Rect[3]);
            const mat = mat3From4Vec2(boxMin, boxMax, rectMin, rectMax, true);
            bBoxLL = apTrBoxLL.applyMat3(mat);
            bBoxLR = apTrBoxLR.applyMat3(mat);
            bBoxUR = apTrBoxUR.applyMat3(mat);
            bBoxUL = apTrBoxUL.applyMat3(mat);
        }
        else {
            bBoxLL = new Vec2(this.Rect[0], this.Rect[1]);
            bBoxLR = new Vec2(this.Rect[2], this.Rect[1]);
            bBoxUR = new Vec2(this.Rect[2], this.Rect[3]);
            bBoxUL = new Vec2(this.Rect[0], this.Rect[3]);
        }
        this._bBox = {
            ll: bBoxLL,
            lr: bBoxLR,
            ur: bBoxUR,
            ul: bBoxUL,
        };
        return this._bBox;
    }
    convertClientCoordsToPage(clientX, clientY) {
        const { x, y, width, height } = this._svgBox.getBoundingClientRect();
        const rectMinScaled = new Vec2(x, y);
        const rectMaxScaled = new Vec2(x + width, y + height);
        const pageScale = (rectMaxScaled.x - rectMinScaled.x) / (this.Rect[2] - this.Rect[0]);
        const pageLowerLeft = new Vec2(x - this.Rect[0] * pageScale, y + height + (this.Rect[1] * pageScale));
        const position = new Vec2((clientX - pageLowerLeft.x) / pageScale, (pageLowerLeft.y - clientY) / pageScale);
        return position;
    }
    convertPageCoordsToClient(pageX, pageY) {
        const { x, y, width, height } = this._svgBox.getBoundingClientRect();
        const rectMinScaled = new Vec2(x, y);
        const rectMaxScaled = new Vec2(x + width, y + height);
        const pageScale = (rectMaxScaled.x - rectMinScaled.x) / (this.Rect[2] - this.Rect[0]);
        const pageLowerLeft = new Vec2(x - this.Rect[0] * pageScale, y + height + (this.Rect[1] * pageScale));
        const position = new Vec2(pageLowerLeft.x + (pageX * pageScale), pageLowerLeft.y - (pageY * pageScale));
        return position;
    }
    renderRect() {
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.classList.add("svg-annot-rect");
        rect.setAttribute("data-annotation-name", this.name);
        rect.setAttribute("x", this.Rect[0] + "");
        rect.setAttribute("y", this.Rect[1] + "");
        rect.setAttribute("width", this.Rect[2] - this.Rect[0] + "");
        rect.setAttribute("height", this.Rect[3] - this.Rect[1] + "");
        return rect;
    }
    renderBox() {
        const { ll, lr, ur, ul } = this.getLocalBB();
        const boxPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        boxPath.classList.add("svg-annot-box");
        boxPath.setAttribute("data-annotation-name", this.name);
        boxPath.setAttribute("d", `M ${ll.x} ${ll.y} L ${lr.x} ${lr.y} L ${ur.x} ${ur.y} L ${ul.x} ${ul.y} Z`);
        return boxPath;
    }
    renderMainElement() {
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "g");
        rect.classList.add("svg-annotation");
        rect.setAttribute("data-annotation-name", this.name);
        rect.addEventListener("pointerdown", this.onRectPointerDown);
        return rect;
    }
    renderApAsync() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const stream = this.apStream;
            if (stream) {
                try {
                    const renderer = new AppearanceStreamRenderer(stream, this.Rect, this.name);
                    return yield renderer.renderAsync();
                }
                catch (e) {
                    console.log(`Annotation stream render error: ${e.message}`);
                }
            }
            return null;
        });
    }
    renderContent() {
        return null;
    }
    renderContentCopy() {
        const copy = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        const copyDefs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const copySymbol = document.createElementNS("http://www.w3.org/2000/svg", "symbol");
        copySymbol.id = this._svgId + "_symbol";
        const copySymbolUse = document.createElementNS("http://www.w3.org/2000/svg", "use");
        copySymbolUse.setAttribute("href", `#${this._svgId}`);
        if (this.pageRect) {
            copySymbolUse.setAttribute("viewBox", `${this.pageRect[0]} ${this.pageRect[1]} ${this.pageRect[2]} ${this.pageRect[3]}`);
        }
        copySymbol.append(copySymbolUse);
        copyDefs.append(copySymbol);
        const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
        use.setAttribute("href", `#${this._svgId}_symbol`);
        use.setAttribute("opacity", "0.2");
        copy.append(copyDefs, use);
        return { copy, use };
    }
    renderScaleHandles() {
        const bBox = this.getLocalBB();
        const handles = [];
        ["ll", "lr", "ur", "ul"].forEach(x => {
            const handle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            handle.classList.add("svg-annot-handle-scale");
            handle.setAttribute("data-handle-name", x);
            handle.setAttribute("cx", bBox[x].x + "");
            handle.setAttribute("cy", bBox[x].y + "");
            handle.addEventListener("pointerdown", this.onScaleHandlePointerDown);
            handles.push(handle);
        });
        return handles;
    }
    renderRotationHandle() {
        const centerX = (this.Rect[0] + this.Rect[2]) / 2;
        const centerY = (this.Rect[1] + this.Rect[3]) / 2;
        const currentRotation = this.getCurrentRotation();
        const rotationGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
        rotationGroup.classList.add("svg-annot-rotation");
        rotationGroup.setAttribute("data-handle-name", "center");
        const rotationGroupCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        rotationGroupCircle.classList.add("circle", "dashed");
        rotationGroupCircle.setAttribute("cx", centerX + "");
        rotationGroupCircle.setAttribute("cy", centerY + "");
        const handleMatrix = new Mat3()
            .applyTranslation(-centerX, -centerY + 35)
            .applyRotation(currentRotation)
            .applyTranslation(centerX, centerY);
        const handleCenter = new Vec2(centerX, centerY).applyMat3(handleMatrix);
        const rotationGroupLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        rotationGroupLine.classList.add("dashed");
        rotationGroupLine.setAttribute("x1", centerX + "");
        rotationGroupLine.setAttribute("y1", centerY + "");
        rotationGroupLine.setAttribute("x2", handleCenter.x + "");
        rotationGroupLine.setAttribute("y2", handleCenter.y + "");
        const centerRectHandle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        centerRectHandle.classList.add("svg-annot-handle-rotation");
        centerRectHandle.setAttribute("data-handle-name", "center");
        centerRectHandle.setAttribute("cx", handleCenter.x + "");
        centerRectHandle.setAttribute("cy", handleCenter.y + "");
        centerRectHandle.addEventListener("pointerdown", this.onRotationHandlePointerDown);
        rotationGroup.append(rotationGroupCircle, rotationGroupLine, centerRectHandle);
        return rotationGroup;
    }
    renderHandles() {
        return [...this.renderScaleHandles(), this.renderRotationHandle()];
    }
    updateRenderAsync() {
        return __awaiter$2(this, void 0, void 0, function* () {
            this._svg.innerHTML = "";
            const contentResult = this.renderContent() || (yield this.renderApAsync());
            if (!contentResult) {
                this._svgBox = null;
                this._svgContent = null;
                this._svgContentCopy = null;
                this._svgContentCopyUse = null;
                this._svgClipPaths = null;
                return;
            }
            const content = contentResult.svg;
            content.id = this._svgId;
            content.classList.add("svg-annotation-content");
            content.setAttribute("data-annotation-name", this.name);
            const { copy, use } = this.renderContentCopy();
            const rect = this.renderRect();
            const box = this.renderBox();
            const handles = this.renderHandles();
            this._svg.append(rect, box, contentResult.svg, ...handles);
            this._svgBox = box;
            this._svgContent = content;
            this._svgContentCopy = copy;
            this._svgContentCopyUse = use;
            this._svgClipPaths = contentResult.clipPaths;
        });
    }
}

const markupAnnotationReplyTypes = {
    REPLY: "/R",
    GROUP: "/Group",
};
class MarkupAnnotation extends AnnotationDict {
    constructor(subType) {
        super(subType);
        this.RT = markupAnnotationReplyTypes.REPLY;
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.T) {
            bytes.push(...encoder.encode("/T "), ...this.T.toArray(cryptInfo));
        }
        if (this.Popup) {
            bytes.push(...encoder.encode("/Popup "), codes.WHITESPACE, ...this.Popup.toArray(cryptInfo));
        }
        if (this.RC) {
            bytes.push(...encoder.encode("/RC "), ...this.RC.toArray(cryptInfo));
        }
        if (this.CA) {
            bytes.push(...encoder.encode("/CA "), ...encoder.encode(" " + this.CA));
        }
        if (this.CreationDate) {
            bytes.push(...encoder.encode("/CreationDate "), ...this.CreationDate.toArray(cryptInfo));
        }
        if (this.Subj) {
            bytes.push(...encoder.encode("/Subj "), ...this.Subj.toArray(cryptInfo));
        }
        if (this.IRT) {
            bytes.push(...encoder.encode("/IRT "), codes.WHITESPACE, ...this.IRT.toArray(cryptInfo));
        }
        if (this.RT) {
            bytes.push(...encoder.encode("/RT "), ...encoder.encode(this.RT));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/T":
                    case "/Subj":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/Popup":
                    case "/IRT":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/RC":
                        const rcEntryType = parser.getValueTypeAt(i);
                        if (rcEntryType === valueTypes.REF) {
                            const rsObjectId = ObjectId.parseRef(parser, i);
                            if (rsObjectId && parseInfo.parseInfoGetter) {
                                const rcParseInfo = parseInfo.parseInfoGetter(rsObjectId.value.id);
                                if (rcParseInfo) {
                                    const rcObjectType = rcParseInfo.type
                                        || rcParseInfo.parser.getValueTypeAt(rcParseInfo.bounds.contentStart);
                                    if (rcObjectType === valueTypes.STRING_LITERAL) {
                                        const popupTextFromIndirectLiteral = LiteralString
                                            .parse(rcParseInfo.parser, rcParseInfo.bounds.contentStart);
                                        if (popupTextFromIndirectLiteral) {
                                            this.RC = popupTextFromIndirectLiteral.value;
                                            i = rsObjectId.end + 1;
                                            break;
                                        }
                                    }
                                    else if (rcObjectType === valueTypes.DICTIONARY) {
                                        const popupTextStream = TextStream.parse(rcParseInfo);
                                        if (popupTextStream) {
                                            const popupTextFromStream = popupTextStream.value.getText();
                                            this.RC = LiteralString.fromString(popupTextFromStream);
                                            i = rsObjectId.end + 1;
                                            break;
                                        }
                                    }
                                    else {
                                        throw new Error(`Unsupported /RC property value type: ${rcObjectType}`);
                                    }
                                }
                            }
                            throw new Error("Can't parse /RC value reference");
                        }
                        else if (rcEntryType === valueTypes.STRING_LITERAL) {
                            const popupTextFromLiteral = LiteralString.parse(parser, i, parseInfo.cryptInfo);
                            if (popupTextFromLiteral) {
                                this.RC = popupTextFromLiteral.value;
                                i = popupTextFromLiteral.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /RC property value");
                        }
                        throw new Error(`Unsupported /RC property value type: ${rcEntryType}`);
                    case "/CA":
                        i = this.parseNumberProp(name, parser, i, true);
                        break;
                    case "/CreationDate":
                        i = this.parseDateProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/RT":
                        const replyType = parser.parseNameAt(i, true);
                        if (replyType && Object.values(markupAnnotationReplyTypes)
                            .includes(replyType.value)) {
                            this.RT = replyType.value;
                            i = replyType.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /RT property value");
                        }
                        break;
                    case "/ExData":
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Subtype || !this.Rect) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class DocumentDataUpdater {
    constructor(sourceBytes, lastXref, referenceData, authResult) {
        this.writeImageXObject = (obj) => {
            const sMask = obj.sMask;
            if (this.isNew(sMask)) {
                const newMaskRef = this.writeIndirectObject(sMask);
                obj.SMask = ObjectId.fromRef(newMaskRef);
            }
            else if (sMask.edited) {
                this.writeUpdatedIndirectObject(sMask);
            }
            if (this.isNew(obj)) {
                return this.writeIndirectObject(obj);
            }
            else if (obj.edited) {
                return this.writeUpdatedIndirectObject(obj);
            }
            else {
                return {
                    id: obj.id,
                    generation: obj.generation,
                    byteOffset: this._refData.getOffset(obj.id)
                };
            }
        };
        this._lastXref = lastXref;
        this._refData = referenceData;
        this._changeData = new ReferenceDataChange(referenceData);
        this._writer = new DataWriter(sourceBytes);
        this._stringCryptor = authResult === null || authResult === void 0 ? void 0 : authResult.stringCryptor;
        this._streamCryptor = authResult === null || authResult === void 0 ? void 0 : authResult.streamCryptor;
    }
    getDataWithUpdatedAnnotations(data) {
        for (const { page, supportedAnnotations: annotations, allAnnotationIds: refArray } of data) {
            if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
                continue;
            }
            for (const annotation of annotations) {
                if (annotation.deleted) {
                    if (!annotation.ref) {
                        continue;
                    }
                    const refIndex = refArray.findIndex(x => x.id === annotation.id);
                    refArray.splice(refIndex, 1);
                    this._changeData.setRefFree(annotation.id);
                    if (annotation instanceof MarkupAnnotation && annotation.Popup) {
                        this._changeData.setRefFree(annotation.Popup.id);
                    }
                }
                else if (!annotation.ref || annotation.edited) {
                    const apStream = annotation.apStream;
                    if (apStream) {
                        this.writeFormXObject(apStream);
                    }
                    if (this.isNew(annotation)) {
                        const newAnnotRef = this.writeIndirectObject(annotation);
                        refArray.push(ObjectId.fromRef(newAnnotRef));
                    }
                    else {
                        this.writeUpdatedIndirectObject(annotation);
                    }
                }
            }
            if (page.Annots instanceof ObjectId
                && this._changeData.isUsedInSource(page.Annots.id)) {
                const annotsRef = {
                    id: page.Annots.id,
                    generation: page.Annots.generation,
                    byteOffset: this._writer.offset
                };
                const annotsCryptInfo = {
                    ref: annotsRef,
                    streamCryptor: this._streamCryptor,
                    stringCryptor: this._stringCryptor,
                };
                this._changeData.updateUsedRef(annotsRef);
                this._writer.writeIndirectArray(annotsCryptInfo, refArray);
            }
            else {
                const newAnnotsRef = this._changeData.takeFreeRef(this._writer.offset, true);
                const annotsCryptInfo = {
                    ref: newAnnotsRef,
                    streamCryptor: this._streamCryptor,
                    stringCryptor: this._stringCryptor,
                };
                this._writer.writeIndirectArray(annotsCryptInfo, refArray);
                page.Annots = ObjectId.fromRef(newAnnotsRef);
            }
            this.writeUpdatedIndirectObject(page);
        }
        this.writeXref();
        const bytes = this._writer.getCurrentData();
        return bytes;
    }
    isNew(obj) {
        return !obj.ref || !this._changeData.isUsedInSource(obj.id);
    }
    writeIndirectObject(obj) {
        const newRef = this._changeData.takeFreeRef(this._writer.offset, true);
        const newObjCryptInfo = {
            ref: newRef,
            streamCryptor: this._streamCryptor,
            stringCryptor: this._stringCryptor,
        };
        this._writer.writeIndirectObject(newObjCryptInfo, obj);
        obj.ref = newRef;
        return newRef;
    }
    writeUpdatedIndirectObject(obj) {
        const objRef = {
            id: obj.id,
            generation: obj.generation,
            byteOffset: this._writer.offset
        };
        const objCryptInfo = {
            ref: objRef,
            streamCryptor: this._streamCryptor,
            stringCryptor: this._stringCryptor,
        };
        this._changeData.updateUsedRef(objRef);
        this._writer.writeIndirectObject(objCryptInfo, obj);
        return objRef;
    }
    writeFormXObject(obj) {
        const resources = obj.Resources;
        if (resources && resources.edited) {
            [...resources.getXObjects()].forEach(([name, xObj]) => {
                if (xObj instanceof ImageStream) {
                    this.writeImageXObject(xObj);
                }
                else {
                    this.writeFormXObject(xObj);
                }
            });
        }
        if (this.isNew(obj)) {
            return this.writeIndirectObject(obj);
        }
        else if (obj.edited) {
            return this.writeUpdatedIndirectObject(obj);
        }
        else {
            return {
                id: obj.id,
                generation: obj.generation,
                byteOffset: this._refData.getOffset(obj.id)
            };
        }
    }
    writeXref() {
        const newXrefOffset = this._writer.offset;
        const newXrefRef = this._changeData.takeFreeRef(newXrefOffset, true);
        const newXrefEntries = this._changeData.exportEntries();
        const newXref = this._lastXref.createUpdate(newXrefEntries, newXrefOffset);
        this._writer.writeIndirectObject({ ref: newXrefRef }, newXref);
        this._writer.writeEof(newXrefOffset);
        return newXrefOffset;
    }
}

class TrailerStream extends PdfStream {
    constructor() {
        super(streamTypes.XREF);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TrailerStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Size) {
            bytes.push(...encoder.encode("/Size "), ...encoder.encode(" " + this.Size));
        }
        if (this.Prev) {
            bytes.push(...encoder.encode("/Prev "), ...encoder.encode(" " + this.Prev));
        }
        if (this.Root) {
            bytes.push(...encoder.encode("/Root "), codes.WHITESPACE, ...this.Root.toArray(cryptInfo));
        }
        if (this.Encrypt) {
            bytes.push(...encoder.encode("/Encrypt "), codes.WHITESPACE, ...this.Encrypt.toArray(cryptInfo));
        }
        if (this.Info) {
            bytes.push(...encoder.encode("/Info "), codes.WHITESPACE, ...this.Info.toArray(cryptInfo));
        }
        if (this.ID) {
            bytes.push(...encoder.encode("/ID "), codes.L_BRACKET, ...this.ID[0].toArray(cryptInfo), ...this.ID[1].toArray(cryptInfo), codes.R_BRACKET);
        }
        if (this.Index) {
            bytes.push(...encoder.encode("/Index "), codes.L_BRACKET);
            this.Index.forEach(x => bytes.push(...encoder.encode(" " + x)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.W) {
            bytes.push(...encoder.encode("/W "), codes.L_BRACKET, ...encoder.encode(this.W[0] + ""), codes.WHITESPACE, ...encoder.encode(this.W[1] + ""), codes.WHITESPACE, ...encoder.encode(this.W[2] + ""), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        var _a;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Size":
                    case "/Prev":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Root":
                    case "/Info":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Encrypt":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.REF) {
                            const encryptId = ObjectId.parseRef(parser, i);
                            if (encryptId) {
                                this.Encrypt = encryptId.value;
                                i = encryptId.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Encrypt property value");
                            }
                        }
                        throw new Error(`Unsupported /Encrypt property value type: ${entryType}`);
                    case "/ID":
                        const ids = HexString.parseArray(parser, i);
                        if (ids) {
                            this.ID = [ids.value[0], ids.value[1]];
                            i = ids.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /ID property value");
                        }
                        break;
                    case "/Index":
                    case "/W":
                        i = this.parseNumberArrayProp(name, parser, i, false);
                        break;
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.W || !this.Size || !this.Root || (this.Encrypt && !this.ID)) {
            throw new Error("Not all required properties parsed");
        }
        if (!((_a = this.Index) === null || _a === void 0 ? void 0 : _a.length)) {
            this.Index = [0, this.Size];
        }
    }
}

class XRef {
    constructor(type) {
        this._type = type;
    }
    get type() {
        return this._type;
    }
    get offset() {
        return this._offset;
    }
}

class XRefStream extends XRef {
    constructor(trailer, offset) {
        super(xRefTypes.STREAM);
        this._trailerStream = trailer;
        this._offset = offset;
    }
    get prev() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Prev;
    }
    get size() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Size;
    }
    get root() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get info() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get encrypt() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.Encrypt;
    }
    get id() {
        var _a;
        return (_a = this._trailerStream) === null || _a === void 0 ? void 0 : _a.ID;
    }
    static createFrom(base, entries, offset) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !base) {
            return null;
        }
        const entriesSize = Math.max(...entries.map(x => x.id)) + 1;
        const size = Math.max(entriesSize, base.size);
        return XRefStream.create(entries, size, offset, base.root, base.offset, base.info, base.encrypt, base.id);
    }
    static create(entries, size, offset, root, prev, info, encrypt, id) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !size || !offset || !root) {
            return null;
        }
        const trailer = new TrailerStream();
        trailer.Size = size;
        trailer.Root = root;
        trailer.Prev = prev;
        trailer.Info = info;
        trailer.Encrypt = encrypt;
        trailer.ID = id;
        const w = [1, 4, 2];
        const wSum = w[0] + w[1] + w[2];
        const params = new DecodeParamsDict();
        params.setIntProp("/Predictor", flatePredictors.PNG_UP);
        params.setIntProp("/Columns", wSum);
        params.setIntProp("/Colors", 1);
        params.setIntProp("/BitsPerComponent", 8);
        const data = XRefEntry.toStreamBytes(entries, w);
        const stream = new XRefStream(trailer, offset);
        stream._trailerStream.Filter = streamFilters.FLATE;
        stream._trailerStream.DecodeParms = params;
        stream._trailerStream.W = w;
        stream._trailerStream.Index = data.index;
        stream._trailerStream.streamData = data.bytes;
        return stream;
    }
    static parse(parseInfo, offset) {
        if (!parseInfo) {
            return null;
        }
        const trailerStream = TrailerStream.parse(parseInfo);
        if (!trailerStream) {
            return null;
        }
        const xrefStream = new XRefStream(trailerStream.value, offset);
        return {
            value: xrefStream,
            start: null,
            end: null,
        };
    }
    createUpdate(entries, offset) {
        return XRefStream.createFrom(this, entries, offset);
    }
    getEntries() {
        if (!this._trailerStream) {
            return [];
        }
        const entries = XRefEntry.fromStreamBytes(this._trailerStream.decodedStreamData, this._trailerStream.W, this._trailerStream.Index);
        return entries;
    }
    toArray(cryptInfo) {
        return this._trailerStream.toArray(cryptInfo);
    }
}

class TrailerDict extends PdfDict {
    constructor() {
        super(dictTypes.EMPTY);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new TrailerDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Size) {
            bytes.push(...encoder.encode("/Size "), ...encoder.encode(" " + this.Size));
        }
        if (this.Prev) {
            bytes.push(...encoder.encode("/Prev "), ...encoder.encode(" " + this.Prev));
        }
        if (this.Root) {
            bytes.push(...encoder.encode("/Root "), codes.WHITESPACE, ...this.Root.toArray(cryptInfo));
        }
        if (this.Encrypt) {
            bytes.push(...encoder.encode("/Encrypt "), codes.WHITESPACE, ...this.Encrypt.toArray(cryptInfo));
        }
        if (this.Info) {
            bytes.push(...encoder.encode("/Info "), codes.WHITESPACE, ...this.Info.toArray(cryptInfo));
        }
        if (this.ID) {
            bytes.push(...encoder.encode("/ID "), codes.L_BRACKET, ...this.ID[0].toArray(cryptInfo), ...this.ID[1].toArray(cryptInfo), codes.R_BRACKET);
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Size":
                    case "/Prev":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Root":
                    case "/Info":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Encrypt":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.REF) {
                            const encryptId = ObjectId.parseRef(parser, i);
                            if (encryptId) {
                                this.Encrypt = encryptId.value;
                                i = encryptId.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Encrypt property value");
                            }
                        }
                        throw new Error(`Unsupported /Encrypt property value type: ${entryType}`);
                    case "/ID":
                        const ids = HexString.parseArray(parser, i);
                        if (ids) {
                            this.ID = [ids.value[0], ids.value[1]];
                            i = ids.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /ID property value");
                        }
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Size || !this.Root || (this.Encrypt && !this.ID)) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class XRefTable extends XRef {
    constructor(table, trailer, offset) {
        super(xRefTypes.TABLE);
        this._table = table;
        this._trailerDict = trailer;
        this._offset = offset;
    }
    get prev() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Prev;
    }
    get size() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Size;
    }
    get root() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get info() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Root;
    }
    get encrypt() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.Encrypt;
    }
    get id() {
        var _a;
        return (_a = this._trailerDict) === null || _a === void 0 ? void 0 : _a.ID;
    }
    static createFrom(base, entries, offset) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !base) {
            return null;
        }
        const entriesSize = Math.max(...entries.map(x => x.id)) + 1;
        const size = Math.max(entriesSize, base.size);
        return XRefTable.create(entries, size, offset, base.root, base.offset, base.info, base.encrypt, base.id);
    }
    static create(entries, size, offset, root, prev, info, encrypt, id) {
        if (!(entries === null || entries === void 0 ? void 0 : entries.length) || !size || !offset || !root) {
            return null;
        }
        const trailer = new TrailerDict();
        trailer.Size = size;
        trailer.Prev = prev;
        trailer.Root = root;
        trailer.Info = info;
        trailer.Encrypt = encrypt;
        trailer.ID = id;
        const data = XRefEntry.toTableBytes(entries);
        const table = new XRefTable(data, trailer, offset);
        return table;
    }
    static parse(parser, start, offset) {
        if (!parser || isNaN(start)) {
            return null;
        }
        const xrefTableBounds = parser.getXrefTableBoundsAt(start);
        if (!xrefTableBounds) {
            return null;
        }
        const trailerDictBounds = parser.getDictBoundsAt(xrefTableBounds.end + 1);
        if (!trailerDictBounds) {
            return null;
        }
        const table = parser.sliceCharCodes(xrefTableBounds.contentStart, xrefTableBounds.contentEnd);
        const trailerDict = TrailerDict.parse({ parser, bounds: trailerDictBounds });
        if (!trailerDict) {
            return null;
        }
        const xrefTable = new XRefTable(table, trailerDict.value, offset);
        return {
            value: xrefTable,
            start: null,
            end: null,
        };
    }
    createUpdate(entries, offset) {
        return XRefTable.createFrom(this, entries, offset);
    }
    getEntries() {
        if (!this._table.length) {
            return [];
        }
        const entries = XRefEntry.fromTableBytes(this._table);
        return entries;
    }
    toArray(cryptInfo) {
        const trailerBytes = this._trailerDict.toArray(cryptInfo);
        const bytes = [
            ...keywordCodes.XREF_TABLE, ...keywordCodes.END_OF_LINE,
            ...this._table,
            ...keywordCodes.TRAILER, ...keywordCodes.END_OF_LINE,
            ...trailerBytes, ...keywordCodes.END_OF_LINE,
        ];
        return new Uint8Array(bytes);
    }
}

class CatalogDict extends PdfDict {
    constructor() {
        super(dictTypes.CATALOG);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new CatalogDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Version) {
            bytes.push(...encoder.encode("/Version "), ...encoder.encode(this.Version));
        }
        if (this.Pages) {
            bytes.push(...encoder.encode("/Pages "), codes.WHITESPACE, ...this.Pages.toArray(cryptInfo));
        }
        if (this.Lang) {
            bytes.push(...encoder.encode("/Lang "), ...this.Lang.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Version":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/Pages":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Lang":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Pages) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class PageDict extends PdfDict {
    constructor() {
        super(dictTypes.PAGE);
        this.Rotate = 0;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new PageDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Parent) {
            bytes.push(...encoder.encode("/Parent "), codes.WHITESPACE, ...this.Parent.toArray(cryptInfo));
        }
        if (this.LastModified) {
            bytes.push(...encoder.encode("/LastModified "), ...this.LastModified.toArray(cryptInfo));
        }
        if (this.Resources) {
            bytes.push(...encoder.encode("/Resources "), ...this.Resources.toArray(cryptInfo));
        }
        if (this.MediaBox) {
            bytes.push(...encoder.encode("/MediaBox "), codes.L_BRACKET, ...encoder.encode(this.MediaBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[3] + ""), codes.R_BRACKET);
        }
        if (this.CropBox) {
            bytes.push(...encoder.encode("/CropBox "), codes.L_BRACKET, ...encoder.encode(this.CropBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.CropBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.CropBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.CropBox[3] + ""), codes.R_BRACKET);
        }
        if (this.BleedBox) {
            bytes.push(...encoder.encode("/BleedBox "), codes.L_BRACKET, ...encoder.encode(this.BleedBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.BleedBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.BleedBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.BleedBox[3] + ""), codes.R_BRACKET);
        }
        if (this.TrimBox) {
            bytes.push(...encoder.encode("/TrimBox "), codes.L_BRACKET, ...encoder.encode(this.TrimBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.TrimBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.TrimBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.TrimBox[3] + ""), codes.R_BRACKET);
        }
        if (this.ArtBox) {
            bytes.push(...encoder.encode("/ArtBox "), codes.L_BRACKET, ...encoder.encode(this.ArtBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.ArtBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.ArtBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.ArtBox[3] + ""), codes.R_BRACKET);
        }
        if (this.Contents) {
            if (this.Contents instanceof ObjectId) {
                bytes.push(...encoder.encode("/Contents "), codes.WHITESPACE, ...this.Contents.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/Contents "), codes.L_BRACKET);
                this.Contents.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        if (this.Rotate) {
            bytes.push(...encoder.encode("/Rotate "), ...encoder.encode(" " + this.Rotate));
        }
        if (this.Thumb) {
            bytes.push(...encoder.encode("/Thumb "), codes.WHITESPACE, ...this.Thumb.toArray(cryptInfo));
        }
        if (this.B) {
            if (this.B instanceof ObjectId) {
                bytes.push(...encoder.encode("/B "), codes.WHITESPACE, ...this.B.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/B "), codes.L_BRACKET);
                this.B.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        if (this.Dur) {
            bytes.push(...encoder.encode("/Dur "), ...encoder.encode(" " + this.Dur));
        }
        if (this.Annots) {
            if (this.Annots instanceof ObjectId) {
                bytes.push(...encoder.encode("/Annots "), codes.WHITESPACE, ...this.Annots.toArray(cryptInfo));
            }
            else {
                bytes.push(...encoder.encode("/Annots "), codes.L_BRACKET);
                this.Annots.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        if (this.Metadata) {
            bytes.push(...encoder.encode("/Metadata "), codes.WHITESPACE, ...this.Metadata.toArray(cryptInfo));
        }
        if (this.StructParent) {
            bytes.push(...encoder.encode("/StructParent "), ...encoder.encode(" " + this.StructParent));
        }
        if (this.ID) {
            bytes.push(...encoder.encode("/ID "), codes.WHITESPACE, ...this.ID.toArray(cryptInfo));
        }
        if (this.PZ) {
            bytes.push(...encoder.encode("/PZ "), ...encoder.encode(" " + this.PZ));
        }
        if (this.Tabs) {
            bytes.push(...encoder.encode("/Tabs "), ...encoder.encode(this.Tabs));
        }
        if (this.TemplateInstantiated) {
            bytes.push(...encoder.encode("/TemplateInstantiated "), ...encoder.encode(this.TemplateInstantiated));
        }
        if (this.UserUnit) {
            bytes.push(...encoder.encode("/UserUnit "), ...encoder.encode(" " + this.UserUnit));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Parent":
                    case "/Thumb":
                    case "/Metadata":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/LastModified":
                        i = this.parseDateProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/Resources":
                        const resEntryType = parser.getValueTypeAt(i);
                        if (resEntryType === valueTypes.REF) {
                            const resDictId = ObjectId.parseRef(parser, i);
                            if (resDictId && parseInfo.parseInfoGetter) {
                                const resParseInfo = parseInfo.parseInfoGetter(resDictId.value.id);
                                if (resParseInfo) {
                                    const resDict = ResourceDict.parse(resParseInfo);
                                    if (resDict) {
                                        this.Resources = resDict.value;
                                        i = resDict.end + 1;
                                        break;
                                    }
                                }
                            }
                            throw new Error("Can't parse /Resources value reference");
                        }
                        else if (resEntryType === valueTypes.DICTIONARY) {
                            const resDictBounds = parser.getDictBoundsAt(i);
                            if (resDictBounds) {
                                if (resDictBounds.contentStart) {
                                    const resDict = ResourceDict.parse({
                                        parser,
                                        bounds: resDictBounds,
                                        parseInfoGetter: parseInfo.parseInfoGetter,
                                    });
                                    if (resDict) {
                                        this.Resources = resDict.value;
                                    }
                                    else {
                                        throw new Error("Can't parse /Resources value dictionary");
                                    }
                                }
                                i = resDictBounds.end + 1;
                                break;
                            }
                            throw new Error("Can't parse /Resources dictionary bounds");
                        }
                        throw new Error(`Unsupported /Resources property value type: ${resEntryType}`);
                    case "/MediaBox":
                    case "/CropBox":
                    case "/BleedBox":
                    case "/TrimBox":
                    case "/ArtBox":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    case "/Contents":
                    case "/B":
                    case "/Annots":
                        const refEntryType = parser.getValueTypeAt(i);
                        if (refEntryType === valueTypes.REF) {
                            const refArrayId = ObjectId.parseRef(parser, i);
                            if (refArrayId) {
                                this[name.slice(1)] = refArrayId.value;
                                i = refArrayId.end + 1;
                                break;
                            }
                        }
                        else if (refEntryType === valueTypes.ARRAY) {
                            const refIds = ObjectId.parseRefArray(parser, i);
                            if (refIds) {
                                this[name.slice(1)] = refIds.value;
                                i = refIds.end + 1;
                                break;
                            }
                        }
                        throw new Error(`Unsupported ${name} property value type: ${refEntryType}`);
                    case "/Rotate":
                    case "/Dur":
                    case "/StructParent":
                    case "/PZ":
                    case "/UserUnit":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/ID":
                        const webCaptureIdEntryType = parser.getValueTypeAt(i);
                        if (webCaptureIdEntryType === valueTypes.REF) {
                            const webCaptureRefId = ObjectId.parseRef(parser, i);
                            if (webCaptureRefId) {
                                if (webCaptureRefId && parseInfo.parseInfoGetter) {
                                    const webCaptureIdParseInfo = parseInfo.parseInfoGetter(webCaptureRefId.value.id);
                                    if (webCaptureIdParseInfo) {
                                        const webCaptureId = HexString.parse(webCaptureIdParseInfo.parser, webCaptureIdParseInfo.bounds.start, webCaptureIdParseInfo.cryptInfo);
                                        if (webCaptureId) {
                                            this.ID = webCaptureId.value;
                                            i = webCaptureRefId.end + 1;
                                            break;
                                        }
                                    }
                                }
                            }
                            throw new Error("Can't parse /ID property value");
                        }
                        else if (webCaptureIdEntryType === valueTypes.STRING_HEX) {
                            const webCaptureId = HexString.parse(parser, i, parseInfo.cryptInfo);
                            if (webCaptureId) {
                                this.ID = webCaptureId.value;
                                i = webCaptureId.end + 1;
                                break;
                            }
                        }
                        throw new Error(`Unsupported /ID property value type: ${webCaptureIdEntryType}`);
                    case "/Tabs":
                    case "/TemplateInstantiated":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Parent) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class PageTreeDict extends PdfDict {
    constructor() {
        super(dictTypes.PAGE_TREE);
        this.Rotate = 0;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new PageTreeDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Parent) {
            bytes.push(...encoder.encode("/Parent "), codes.WHITESPACE, ...this.Parent.toArray(cryptInfo));
        }
        if (this.Kids) {
            bytes.push(...encoder.encode("/Kids "), codes.L_BRACKET);
            this.Kids.forEach(x => bytes.push(codes.WHITESPACE, ...x.toArray(cryptInfo)));
            bytes.push(codes.R_BRACKET);
        }
        if (this.Count) {
            bytes.push(...encoder.encode("/Count "), ...encoder.encode(" " + this.Count));
        }
        if (this.MediaBox) {
            bytes.push(...encoder.encode("/MediaBox "), codes.L_BRACKET, ...encoder.encode(this.MediaBox[0] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[1] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[2] + ""), codes.WHITESPACE, ...encoder.encode(this.MediaBox[3] + ""), codes.R_BRACKET);
        }
        if (this.Rotate) {
            bytes.push(...encoder.encode("/Rotate "), ...encoder.encode(" " + this.Rotate));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Parent":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    case "/Kids":
                        i = this.parseRefArrayProp(name, parser, i);
                        break;
                    case "/Count":
                    case "/Rotate":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/MediaBox":
                        i = this.parseNumberArrayProp(name, parser, i, true);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Kids || isNaN(this.Count)) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class CryptFilterDict extends PdfDict {
    constructor() {
        super(dictTypes.CRYPT_FILTER);
        this.CFM = cryptMethods.NONE;
        this.AuthEvent = authEvents.DOC_OPEN;
        this.Length = 40;
        this.EncryptMetadata = true;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new CryptFilterDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.CFM) {
            bytes.push(...encoder.encode("/CFM "), ...encoder.encode(this.CFM));
        }
        if (this.AuthEvent) {
            bytes.push(...encoder.encode("/AuthEvent "), ...encoder.encode(this.AuthEvent));
        }
        if (this.Length) {
            bytes.push(...encoder.encode("/Length "), ...encoder.encode(" " + this.Length));
        }
        if (this.EncryptMetadata) {
            bytes.push(...encoder.encode("/EncryptMetadata "), ...encoder.encode(" " + this.EncryptMetadata));
        }
        if (this.Recipients) {
            if (this.Recipients instanceof HexString) {
                bytes.push(...encoder.encode("/Recipients "), ...this.Recipients.toArray(cryptInfo));
            }
            else {
                bytes.push(codes.L_BRACKET);
                this.Recipients.forEach(x => bytes.push(...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/CFM":
                        const method = parser.parseNameAt(i, true);
                        if (method && Object.values(cryptMethods)
                            .includes(method.value)) {
                            this.CFM = method.value;
                            i = method.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /CFM property value");
                        }
                        break;
                    case "/AuthEvent":
                        const authEvent = parser.parseNameAt(i, true);
                        if (authEvent && Object.values(authEvents)
                            .includes(authEvent.value)) {
                            this.AuthEvent = authEvent.value;
                            i = authEvent.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /AuthEvent property value");
                        }
                        break;
                    case "/Length":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/EncryptMetadata":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/Recipients":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.STRING_HEX) {
                            const recipient = HexString.parse(parser, i, parseInfo.cryptInfo);
                            if (recipient) {
                                this.Recipients = recipient.value;
                                i = recipient.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        else if (entryType === valueTypes.ARRAY) {
                            const recipients = HexString.parseArray(parser, i);
                            if (recipients) {
                                this.Recipients = recipients.value;
                                i = recipients.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        throw new Error(`Unsupported /Filter property value type: ${entryType}`);
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class CryptMapDict extends PdfDict {
    constructor() {
        super(null);
        this._filtersMap = new Map();
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new CryptMapDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getProp(name) {
        return this._filtersMap.get(name);
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this._filtersMap.size) {
            this._filtersMap.forEach((v, k) => bytes.push(...encoder.encode(k), ...v.toArray(cryptInfo)));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    default:
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.DICTIONARY) {
                            const dictBounds = parser.getDictBoundsAt(i);
                            if (dictBounds) {
                                const filter = CryptFilterDict.parse({ parser, bounds: dictBounds });
                                if (filter) {
                                    this._filtersMap.set(name, filter.value);
                                    i = filter.end + 1;
                                    break;
                                }
                            }
                        }
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

class EncryptionDict extends PdfDict {
    constructor() {
        super(dictTypes.EMPTY);
        this.Filter = "/Standard";
        this.Length = 40;
        this.StmF = "/Identity";
        this.StrF = "/Identity";
        this.EncryptMetadata = true;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new EncryptionDict();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Filter) {
            bytes.push(...encoder.encode("/Filter "), ...encoder.encode(this.Filter));
        }
        if (this.SubFilter) {
            bytes.push(...encoder.encode("/SubFilter "), ...encoder.encode(this.SubFilter));
        }
        if (this.V) {
            bytes.push(...encoder.encode("/V "), ...encoder.encode(" " + this.V));
        }
        if (this.Length) {
            bytes.push(...encoder.encode("/Length "), ...encoder.encode(" " + this.Length));
        }
        if (this.CF) {
            bytes.push(...encoder.encode("/CF "), ...this.CF.toArray(cryptInfo));
        }
        if (this.StmF) {
            bytes.push(...encoder.encode("/StmF "), ...encoder.encode(this.StmF));
        }
        if (this.StrF) {
            bytes.push(...encoder.encode("/StrF "), ...encoder.encode(this.StrF));
        }
        if (this.EFF) {
            bytes.push(...encoder.encode("/EFF "), ...encoder.encode(this.EFF));
        }
        if (this.R) {
            bytes.push(...encoder.encode("/R "), ...encoder.encode(" " + this.R));
        }
        if (this.O) {
            bytes.push(...encoder.encode("/O "), ...this.O.toArray(cryptInfo));
        }
        if (this.U) {
            bytes.push(...encoder.encode("/U "), ...this.U.toArray(cryptInfo));
        }
        if (this.OE) {
            bytes.push(...encoder.encode("/OE "), ...this.OE.toArray(cryptInfo));
        }
        if (this.UE) {
            bytes.push(...encoder.encode("/UE "), ...this.UE.toArray(cryptInfo));
        }
        if (this.P) {
            bytes.push(...encoder.encode("/P "), ...encoder.encode(" " + this.P));
        }
        if (this.Perms) {
            bytes.push(...encoder.encode("/Perms "), ...this.Perms.toArray(cryptInfo));
        }
        if (this.U) {
            bytes.push(...encoder.encode("/U "), ...this.U.toArray(cryptInfo));
        }
        if (this.EncryptMetadata) {
            bytes.push(...encoder.encode("/EncryptMetadata "), ...encoder.encode(" " + this.EncryptMetadata));
        }
        if (this.Recipients) {
            if (this.Recipients instanceof HexString) {
                bytes.push(...encoder.encode("/Recipients "), ...this.Recipients.toArray(cryptInfo));
            }
            else {
                bytes.push(codes.L_BRACKET);
                this.Recipients.forEach(x => bytes.push(...x.toArray(cryptInfo)));
                bytes.push(codes.R_BRACKET);
            }
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    toCryptOptions() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!this.V) {
            return null;
        }
        return {
            filter: this.Filter,
            version: this.V,
            revision: this.R,
            permissions: this.P,
            keyLength: this.Length,
            encryptMetadata: this.EncryptMetadata,
            stringKeyLength: (_a = this.stringFilter) === null || _a === void 0 ? void 0 : _a.Length,
            streamKeyLength: (_b = this.streamFilter) === null || _b === void 0 ? void 0 : _b.Length,
            stringMethod: (_c = this.stringFilter) === null || _c === void 0 ? void 0 : _c.CFM,
            streamMethod: (_d = this.streamFilter) === null || _d === void 0 ? void 0 : _d.CFM,
            oPasswordHash: (_e = this.O) === null || _e === void 0 ? void 0 : _e.bytes,
            uPasswordHash: (_f = this.U) === null || _f === void 0 ? void 0 : _f.bytes,
            oEncPasswordHash: (_g = this.OE) === null || _g === void 0 ? void 0 : _g.bytes,
            uEncPasswordHash: (_h = this.UE) === null || _h === void 0 ? void 0 : _h.bytes,
            perms: (_j = this.Perms) === null || _j === void 0 ? void 0 : _j.bytes,
        };
    }
    parseProps(parseInfo) {
        var _a, _b;
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Filter":
                    case "/SubFilter":
                    case "/StmF":
                    case "/StrF":
                    case "/EFF":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    case "/V":
                        const algorithm = parser.parseNumberAt(i, false);
                        if (algorithm && Object.values(cryptVersions)
                            .includes(algorithm.value)) {
                            this.V = algorithm.value;
                            i = algorithm.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /V property value");
                        }
                        break;
                    case "/R":
                        const revision = parser.parseNumberAt(i, false);
                        if (revision && Object.values(cryptRevisions)
                            .includes(revision.value)) {
                            this.R = revision.value;
                            i = revision.end + 1;
                        }
                        else {
                            throw new Error("Can't parse /R property value");
                        }
                        break;
                    case "/Length":
                    case "/P":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/O":
                    case "/U":
                    case "/OE":
                    case "/UE":
                    case "/Perms":
                        i = this.parseLiteralProp(name, parser, i, parseInfo.cryptInfo);
                        break;
                    case "/EncryptMetadata":
                        i = this.parseBoolProp(name, parser, i);
                        break;
                    case "/CF":
                        const dictBounds = parser.getDictBoundsAt(i);
                        if (bounds) {
                            const cryptMap = CryptMapDict.parse({ parser, bounds: dictBounds });
                            if (cryptMap) {
                                this.CF = cryptMap.value;
                                i = cryptMap.end + 1;
                            }
                        }
                        else {
                            throw new Error("Can't parse /CF property value");
                        }
                        break;
                    case "/Recipients":
                        const entryType = parser.getValueTypeAt(i);
                        if (entryType === valueTypes.STRING_HEX) {
                            const recipient = HexString.parse(parser, i, parseInfo.cryptInfo);
                            if (recipient) {
                                this.Recipients = recipient.value;
                                i = recipient.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        else if (entryType === valueTypes.ARRAY) {
                            const recipients = HexString.parseArray(parser, i);
                            if (recipients) {
                                this.Recipients = recipients.value;
                                i = recipients.end + 1;
                                break;
                            }
                            else {
                                throw new Error("Can't parse /Recipients property value");
                            }
                        }
                        throw new Error(`Unsupported /Filter property value type: ${entryType}`);
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Filter) {
            throw new Error("Not all required properties parsed");
        }
        if (this.Filter === "/Standard"
            && (!this.R
                || !this.O
                || !this.U
                || isNaN(this.P)
                || (this.V === 5 && (this.R < 5 || !this.OE || !this.UE || !this.Perms)))) {
            throw new Error("Not all required properties parsed");
        }
        if ((this.SubFilter === "adbe.pkcs7.s3" || this.SubFilter === "adbe.pkcs7.s4")
            && !this.Recipients) {
            throw new Error("Not all required properties parsed");
        }
        if (this.StrF !== "/Identity") {
            this.stringFilter = (_a = this.CF) === null || _a === void 0 ? void 0 : _a.getProp(this.StrF);
        }
        if (this.StmF !== "/Identity") {
            this.streamFilter = (_b = this.CF) === null || _b === void 0 ? void 0 : _b.getProp(this.StmF);
        }
    }
}

class ObjectStream extends PdfStream {
    constructor() {
        super(streamTypes.OBJECT_STREAM);
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new ObjectStream();
            pdfObject.parseProps(parseInfo);
            return { value: pdfObject, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    getObjectData(id) {
        if (!this._streamData || !this.N || !this.First) {
            return null;
        }
        const parser = new DataParser(this.decodedStreamData);
        const offsetMap = new Map();
        let temp;
        let objectId;
        let byteOffset;
        let position = 0;
        for (let n = 0; n < this.N; n++) {
            temp = parser.parseNumberAt(position, false, false);
            objectId = temp.value;
            position = temp.end + 2;
            temp = parser.parseNumberAt(position, false, false);
            byteOffset = temp.value;
            position = temp.end + 2;
            offsetMap.set(objectId, byteOffset);
        }
        if (!offsetMap.has(id)) {
            return null;
        }
        const objectStart = this.First + offsetMap.get(id);
        const objectType = parser.getValueTypeAt(objectStart);
        if (objectType === null) {
            return;
        }
        let bounds;
        let value;
        switch (objectType) {
            case objectTypes.DICTIONARY:
                bounds = parser.getDictBoundsAt(objectStart, false);
                break;
            case objectTypes.ARRAY:
                bounds = parser.getArrayBoundsAt(objectStart, false);
                break;
            case objectTypes.STRING_LITERAL:
                const literalValue = LiteralString.parse(parser, objectStart);
                if (literalValue) {
                    bounds = { start: literalValue.start, end: literalValue.end };
                    value = literalValue;
                }
                break;
            case objectTypes.STRING_HEX:
                const hexValue = HexString.parse(parser, objectStart);
                if (hexValue) {
                    bounds = { start: hexValue.start, end: hexValue.end };
                    value = hexValue;
                }
                break;
            case objectTypes.NUMBER:
                const numValue = parser.parseNumberAt(objectStart);
                if (numValue) {
                    bounds = { start: numValue.start, end: numValue.end };
                    value = numValue;
                }
                break;
        }
        if (!bounds) {
            return null;
        }
        const bytes = parser.sliceCharCodes(bounds.start, bounds.end);
        if (!bytes.length) {
            throw new Error("Object byte array is empty");
        }
        return {
            parser: new DataParser(bytes),
            bounds: {
                start: 0,
                end: bytes.length - 1,
                contentStart: bounds.contentStart
                    ? bounds.contentStart - bounds.start
                    : undefined,
                contentEnd: bounds.contentEnd
                    ? bytes.length - 1 - (bounds.end - bounds.contentEnd)
                    : undefined,
            },
            type: objectType,
            value,
            cryptInfo: { ref: { id, generation: 0 } },
            streamId: this.id,
        };
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.N) {
            bytes.push(...encoder.encode("/N "), ...encoder.encode(" " + this.N));
        }
        if (this.First) {
            bytes.push(...encoder.encode("/First "), ...encoder.encode(" " + this.First));
        }
        if (this.Extends) {
            bytes.push(...encoder.encode("/Extends "), codes.WHITESPACE, ...this.Extends.toArray(cryptInfo));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const dictBounds = parser.getDictBoundsAt(start);
        let i = parser.skipToNextName(dictBounds.contentStart, dictBounds.contentEnd);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/N":
                    case "/First":
                        i = this.parseNumberProp(name, parser, i, false);
                        break;
                    case "/Extends":
                        i = this.parseRefProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, dictBounds.contentEnd);
                        break;
                }
            }
            else {
                break;
            }
        }
    }
}

const stampTypes = {
    DRAFT: "/Draft",
    NOT_APPROVED: "/NotApproved",
    APPROVED: "/Approved",
    AS_IS: "/AsIs",
    FOR_COMMENT: "/ForComment",
    EXPERIMENTAL: "/Experimental",
    FINAL: "/Final",
    SOLD: "/Sold",
    EXPIRED: "/Expired",
    PUBLIC: "/ForPublicRelease",
    NOT_PUBLIC: "/NotForPublicRelease",
    DEPARTMENTAL: "/Departmental",
    CONFIDENTIAL: "/Confidential",
    SECRET: "/TopSecret",
};
const stampBBox = [0, 0, 440, 120];
const halfStampBBox = [0, 0, 220, 60];
const draftStampForm = `33.5 13.4 m
404.5 6.92 l
419.6 6.657 431.9 18.52 432.1 33.62 c
432.89 78.92 l
433.153 94.02 421.29 106.32 406.19 106.52 c
35.19 113 l
20.09 113.263 7.79 101.4 7.59 86.3 c
6.8 41 l
6.537 25.9 18.4 13.6 33.5 13.4 c
s
150 61 m
150.047 65.947 149.114 70.413 147.2 74.4 c
145.287 78.333 142.853 81.373 139.9 83.52 c
137.68 85.127 135.24 86.263 132.58 86.93 c
129.92 87.593 126.763 87.957 123.11 88.02 c
106.91 88.29 l
106.401 35.19 l
123.001 34.912 l
126.734 34.85 129.961 35.165 132.681 35.857 c
135.394 36.524 137.681 37.507 139.541 38.807 c
142.721 40.994 145.234 43.974 147.081 47.747 c
148.941 51.5 149.898 55.934 149.951 61.047 c
h
137.8 61.097 m
137.767 57.597 137.183 54.621 136.05 52.167 c
134.937 49.687 133.183 47.764 130.79 46.397 c
129.57 45.731 128.323 45.287 127.05 45.067 c
125.797 44.827 123.897 44.728 121.35 44.77 c
118.36 44.82 l
118.678 78.12 l
121.668 78.07 l
124.481 78.023 126.541 77.846 127.848 77.538 c
129.161 77.207 130.438 76.637 131.678 75.828 c
133.818 74.362 135.381 72.432 136.368 70.038 c
137.348 67.618 137.821 64.648 137.788 61.128 c
f
185 50 m
184.987 48.667 184.74 47.53 184.259 46.59 c
183.778 45.643 182.961 44.907 181.809 44.38 c
181.002 44.013 180.066 43.802 178.999 43.749 c
177.932 43.672 176.689 43.645 175.269 43.669 c
170.989 43.74 l
171.126 58.04 l
174.756 57.979 l
176.643 57.948 178.223 57.814 179.496 57.579 c
180.769 57.344 181.833 56.837 182.686 56.059 c
183.499 55.306 184.086 54.486 184.446 53.599 c
184.827 52.686 185.011 51.483 184.996 49.989 c
h
203.8 86.6 m
189.4 86.841 l
176.7 67.541 l
171.25 67.632 l
171.437 87.132 l
159.637 87.329 l
159.128 34.229 l
178.928 33.897 l
181.635 33.852 183.965 33.991 185.918 34.315 c
187.871 34.639 189.705 35.382 191.418 36.545 c
193.151 37.705 194.531 39.228 195.558 41.115 c
196.605 42.975 197.141 45.335 197.168 48.195 c
197.206 52.122 196.446 55.335 194.888 57.835 c
193.355 60.335 191.138 62.432 188.238 64.125 c
f
251 85.8 m
238.8 86.004 l
235.53 75.304 l
218.53 75.588 l
215.46 86.388 l
203.56 86.587 l
219.96 33.187 l
233.56 32.959 l
h
232.6 65.6 m
226.78 46.6 l
221.33 65.8 l
f
290 42.3 m
268.9 42.653 l
268.995 52.543 l
288.495 52.216 l
288.593 62.516 l
269.093 62.843 l
269.31 85.543 l
257.51 85.74 l
257.001 32.64 l
289.801 32.091 l
f
334 41.5 m
319.7 41.739 l
320.11 84.639 l
308.31 84.837 l
307.9 41.937 l
293.6 42.176 l
293.502 31.876 l
333.902 31.199 l
f
`;
class StampAnnotation extends MarkupAnnotation {
    constructor() {
        super(annotationTypes.STAMP);
        this.Name = stampTypes.DRAFT;
    }
    static createStandard(type) {
        const now = DateString.fromDate(new Date());
        const stampForm = new XFormStream();
        stampForm.LastModified = now;
        stampForm.BBox = stampBBox;
        stampForm.Filter = "/FlateDecode";
        switch (type) {
            case "/Draft":
                stampForm.setTextStreamData(draftStampForm);
                break;
            default:
                throw new Error(`Stamp type '${type}' is not supported`);
        }
        const stampApStream = new XFormStream();
        stampApStream.LastModified = now;
        stampApStream.BBox = stampBBox;
        stampApStream.Resources = new ResourceDict();
        stampApStream.Resources.setXObject("/Fm", stampForm);
        stampApStream.Filter = "/FlateDecode";
        stampApStream.setTextStreamData(`q 1 0 0 -1 0 ${stampBBox[3]} cm .804 0 0 rg .804 0 0 RG 1 j 8.58 w /Fm Do Q`);
        const stampUuid = getRandomUuid();
        const stampAnnotation = new StampAnnotation();
        stampAnnotation.Name = type;
        stampAnnotation.Rect = halfStampBBox;
        stampAnnotation.Contents = LiteralString.fromString(type.slice(1));
        stampAnnotation.Subj = LiteralString.fromString(type.slice(1));
        stampAnnotation.CreationDate = now;
        stampAnnotation.NM = LiteralString.fromString(stampUuid);
        stampAnnotation.name = stampUuid;
        stampAnnotation.apStream = stampApStream;
        return stampAnnotation;
    }
    static parse(parseInfo) {
        if (!parseInfo) {
            throw new Error("Parsing information not passed");
        }
        try {
            const pdfObject = new StampAnnotation();
            pdfObject.parseProps(parseInfo);
            const proxy = new Proxy(pdfObject, pdfObject.onChange);
            pdfObject._proxy = proxy;
            return { value: proxy, start: parseInfo.bounds.start, end: parseInfo.bounds.end };
        }
        catch (e) {
            console.log(e.message);
            return null;
        }
    }
    toArray(cryptInfo) {
        const superBytes = super.toArray(cryptInfo);
        const encoder = new TextEncoder();
        const bytes = [];
        if (this.Name) {
            bytes.push(...encoder.encode("/Name "), ...encoder.encode(this.Name));
        }
        const totalBytes = [
            ...superBytes.subarray(0, 2),
            ...bytes,
            ...superBytes.subarray(2, superBytes.length)
        ];
        return new Uint8Array(totalBytes);
    }
    parseProps(parseInfo) {
        super.parseProps(parseInfo);
        const { parser, bounds } = parseInfo;
        const start = bounds.contentStart || bounds.start;
        const end = bounds.contentEnd || bounds.end;
        parser.sliceChars(start, end);
        let i = parser.skipToNextName(start, end - 1);
        let name;
        let parseResult;
        while (true) {
            parseResult = parser.parseNameAt(i);
            if (parseResult) {
                i = parseResult.end + 1;
                name = parseResult.value;
                switch (name) {
                    case "/Name":
                        i = this.parseNameProp(name, parser, i);
                        break;
                    default:
                        i = parser.skipToNextName(i, end - 1);
                        break;
                }
            }
            else {
                break;
            }
        }
        if (!this.Name) {
            throw new Error("Not all required properties parsed");
        }
    }
}

class DocumentData {
    constructor(data) {
        this._pageById = new Map();
        this._annotIdsByPageId = new Map();
        this.getObjectParseInfo = (id) => {
            var _a, _b, _c;
            if (!id) {
                return null;
            }
            const offset = (_a = this._referenceData) === null || _a === void 0 ? void 0 : _a.getOffset(id);
            if (isNaN(offset)) {
                return null;
            }
            const objectId = ObjectId.parse(this._docParser, offset);
            if (!objectId) {
                return null;
            }
            const bounds = this._docParser.getIndirectObjectBoundsAt(objectId.end + 1, true);
            if (!bounds) {
                return null;
            }
            const parseInfoGetter = this.getObjectParseInfo;
            const info = {
                parser: this._docParser,
                bounds,
                parseInfoGetter,
                cryptInfo: {
                    ref: { id: objectId.value.id, generation: objectId.value.generation },
                    stringCryptor: (_b = this._authResult) === null || _b === void 0 ? void 0 : _b.stringCryptor,
                    streamCryptor: (_c = this._authResult) === null || _c === void 0 ? void 0 : _c.streamCryptor,
                },
            };
            if (objectId.value.id === id) {
                return info;
            }
            const stream = ObjectStream.parse(info);
            if (!stream) {
                return;
            }
            const objectParseInfo = stream.value.getObjectData(id);
            if (objectParseInfo) {
                objectParseInfo.parseInfoGetter = parseInfoGetter;
                return objectParseInfo;
            }
            return null;
        };
        this._data = data;
        this._docParser = new DataParser(data);
        this._version = this._docParser.getPdfVersion();
        const lastXrefIndex = this._docParser.getLastXrefIndex();
        if (!lastXrefIndex) {
            {
                throw new Error("File doesn't contain update section");
            }
        }
        const xrefs = DocumentData.parseAllXrefs(this._docParser, lastXrefIndex.value);
        if (!xrefs.length) {
            {
                throw new Error("Failed to parse cross-reference sections");
            }
        }
        this._xrefs = xrefs;
        this._referenceData = new ReferenceData(xrefs);
        this.parseEncryption();
    }
    get size() {
        var _a;
        if ((_a = this._xrefs) === null || _a === void 0 ? void 0 : _a.length) {
            return this._xrefs[0].size;
        }
        else {
            return 0;
        }
    }
    get encrypted() {
        return !!this._encryption;
    }
    get authenticated() {
        return !this._encryption || !!this._authResult;
    }
    static parseXref(parser, start, max) {
        if (!parser || !start) {
            return null;
        }
        const offset = start;
        const xrefTableIndex = parser.findSubarrayIndex(keywordCodes.XREF_TABLE, { minIndex: start, closedOnly: true });
        if (xrefTableIndex && xrefTableIndex.start === start) {
            const xrefStmIndexProp = parser.findSubarrayIndex(keywordCodes.XREF_HYBRID, { minIndex: start, maxIndex: max, closedOnly: true });
            if (xrefStmIndexProp) {
                const streamXrefIndex = parser.parseNumberAt(xrefStmIndexProp.end + 1);
                if (!streamXrefIndex) {
                    return null;
                }
                start = streamXrefIndex.value;
            }
            else {
                const xrefTable = XRefTable.parse(parser, start, offset);
                return xrefTable === null || xrefTable === void 0 ? void 0 : xrefTable.value;
            }
        }
        const id = ObjectId.parse(parser, start, false);
        if (!id) {
            return null;
        }
        const xrefStreamBounds = parser.getIndirectObjectBoundsAt(id.end + 1);
        if (!xrefStreamBounds) {
            return null;
        }
        const xrefStream = XRefStream.parse({ parser: parser, bounds: xrefStreamBounds }, offset);
        return xrefStream === null || xrefStream === void 0 ? void 0 : xrefStream.value;
    }
    static parseAllXrefs(parser, start) {
        const xrefs = [];
        let max = parser.maxIndex;
        let xref;
        while (start) {
            xref = DocumentData.parseXref(parser, start, max);
            if (xref) {
                xrefs.push(xref);
                max = start;
                start = xref.prev;
            }
            else {
                break;
            }
        }
        return xrefs;
    }
    tryAuthenticate(password = "") {
        if (!this.authenticated) {
            return this.authenticate(password);
        }
        return true;
    }
    getPlainData() {
        return this._data.slice();
    }
    getDataWithoutSupportedAnnotations() {
        const annotationMap = this.getSupportedAnnotationMap();
        const annotationMarkedToDelete = [];
        if (annotationMap === null || annotationMap === void 0 ? void 0 : annotationMap.size) {
            annotationMap.forEach((v, k) => {
                const annotations = v.slice();
                annotations.forEach(x => {
                    if (!x.deleted) {
                        x.markAsDeleted(true);
                        annotationMarkedToDelete.push(x);
                    }
                });
            });
        }
        const refined = this.getDataWithUpdatedAnnotations();
        annotationMarkedToDelete.forEach(x => x.markAsDeleted(false));
        return refined;
    }
    getDataWithUpdatedAnnotations() {
        const annotationMap = this.getSupportedAnnotationMap();
        const updaterData = [];
        annotationMap.forEach((pageAnnotations, pageId) => {
            const page = this._pageById.get(pageId);
            if (!page) {
                throw new Error(`Page with id '${pageId}' not found`);
            }
            const allAnnotationIds = this._annotIdsByPageId.get(pageId).slice() || [];
            updaterData.push({
                page,
                allAnnotationIds,
                supportedAnnotations: pageAnnotations || [],
            });
        });
        const updater = new DocumentDataUpdater(this._data, this._xrefs[0], this._referenceData, this._authResult);
        const updatedBytes = updater.getDataWithUpdatedAnnotations(updaterData);
        return updatedBytes;
    }
    getPageAnnotations(pageId) {
        const annotations = this.getSupportedAnnotationMap().get(pageId);
        return annotations || [];
    }
    createStampAnnotation(type) {
        switch (type) {
            case "draft":
                return StampAnnotation.createStandard("/Draft");
            default:
                throw new Error("Unsupported stamp type");
        }
    }
    appendAnnotationToPage(pageId, annotation) {
        const pageAnnotations = this.getSupportedAnnotationMap().get(pageId);
        if (pageAnnotations) {
            pageAnnotations.push(annotation);
        }
        else {
            this.getSupportedAnnotationMap().set(pageId, [annotation]);
        }
    }
    removeAnnotation(annotation) {
        annotation.markAsDeleted(true);
    }
    authenticate(password) {
        if (this.authenticated) {
            return true;
        }
        const cryptOptions = this._encryption.toCryptOptions();
        const fileId = this._xrefs[0].id[0].hex;
        const cryptorSource = new DataCryptHandler(cryptOptions, fileId);
        this._authResult = cryptorSource.authenticate(password);
        return this.authenticated;
    }
    checkAuthentication() {
        if (!this.authenticated) {
            throw new Error("Unauthorized access to file data");
        }
    }
    parseEncryption() {
        const encryptionId = this._xrefs[0].encrypt;
        if (!encryptionId) {
            return;
        }
        const encryptionParseInfo = this.getObjectParseInfo(encryptionId.id);
        const encryption = EncryptionDict.parse(encryptionParseInfo);
        if (!encryption) {
            throw new Error("Encryption dict can't be parsed");
        }
        this._encryption = encryption.value;
    }
    parsePages(output, tree) {
        if (!tree.Kids.length) {
            return;
        }
        for (const kid of tree.Kids) {
            const parseInfo = this.getObjectParseInfo(kid.id);
            if (!parseInfo) {
                continue;
            }
            const type = parseInfo.parser.parseDictType(parseInfo.bounds);
            if (type === dictTypes.PAGE_TREE) {
                const kidTree = PageTreeDict.parse(parseInfo);
                if (kidTree) {
                    this.parsePages(output, kidTree.value);
                }
            }
            else if (type === dictTypes.PAGE) {
                const kidPage = PageDict.parse(parseInfo);
                if (kidPage) {
                    output.push(kidPage.value);
                }
            }
        }
    }
    ;
    parsePageTree() {
        const catalogId = this._xrefs[0].root;
        const catalogParseInfo = this.getObjectParseInfo(catalogId.id);
        const catalog = CatalogDict.parse(catalogParseInfo);
        if (!catalog) {
            throw new Error("Document root catalog not found");
        }
        this._catalog = catalog.value;
        const pageRootId = catalog.value.Pages;
        const pageRootParseInfo = this.getObjectParseInfo(pageRootId.id);
        const pageRootTree = PageTreeDict.parse(pageRootParseInfo);
        if (!pageRootTree) {
            throw new Error("Document root page tree not found");
        }
        const pages = [];
        this.parsePages(pages, pageRootTree.value);
        this._pages = pages;
        this._pageById.clear();
        pages.forEach(x => this._pageById.set(x.ref.id, x));
    }
    getSupportedAnnotations() {
        var _a;
        this.checkAuthentication();
        if (!this._catalog) {
            this.parsePageTree();
        }
        const annotIdsByPageId = new Map();
        const annotationMap = new Map();
        for (const page of this._pages) {
            const annotationIds = [];
            if (Array.isArray(page.Annots)) {
                annotationIds.push(...page.Annots);
            }
            else if (page.Annots instanceof ObjectId) {
                const parseInfo = this.getObjectParseInfo(page.Annots.id);
                if (parseInfo) {
                    const annotationRefs = ObjectId.parseRefArray(parseInfo.parser, parseInfo.bounds.contentStart);
                    if ((_a = annotationRefs === null || annotationRefs === void 0 ? void 0 : annotationRefs.value) === null || _a === void 0 ? void 0 : _a.length) {
                        annotationIds.push(...annotationRefs.value);
                    }
                }
            }
            annotIdsByPageId.set(page.ref.id, annotationIds);
            const annotations = [];
            for (const objectId of annotationIds) {
                const info = this.getObjectParseInfo(objectId.id);
                info.rect = page.MediaBox;
                const annotationType = info.parser.parseDictSubtype(info.bounds);
                let annot;
                switch (annotationType) {
                    case annotationTypes.STAMP:
                        annot = StampAnnotation.parse(info);
                        break;
                }
                if (annot) {
                    annotations.push(annot.value);
                    console.log(annot.value);
                }
            }
            annotationMap.set(page.id, annotations);
        }
        this._annotIdsByPageId = annotIdsByPageId;
        this._supportedAnnotsByPageId = annotationMap;
        return this._supportedAnnotsByPageId;
    }
    getSupportedAnnotationMap() {
        this.checkAuthentication();
        if (this._supportedAnnotsByPageId) {
            return this._supportedAnnotsByPageId;
        }
        this._supportedAnnotsByPageId = this.getSupportedAnnotations();
        return this._supportedAnnotsByPageId;
    }
}

var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PageTextView {
    constructor(pageProxy) {
        this.onMouseDown = (e) => {
            var _a;
            if (this._divModeTimer) {
                clearTimeout(this._divModeTimer);
                this._divModeTimer = null;
            }
            (_a = this._renderTask) === null || _a === void 0 ? void 0 : _a.expandTextDivs(true);
        };
        this.onMouseUp = (e) => {
            this._divModeTimer = setTimeout(() => {
                var _a;
                (_a = this._renderTask) === null || _a === void 0 ? void 0 : _a.expandTextDivs(false);
                this._divModeTimer = null;
            }, 300);
        };
        if (!pageProxy) {
            throw new Error("Page proxy is not defined");
        }
        this._pageProxy = pageProxy;
        this._container = document.createElement("div");
        this._container.classList.add("page-text");
        this._container.addEventListener("mousedown", this.onMouseDown);
        this._container.addEventListener("mouseup", this.onMouseUp);
    }
    static appendPageTextAsync(pageProxy, parent, scale) {
        return __awaiter$3(this, void 0, void 0, function* () {
            const textObj = new PageTextView(pageProxy);
            yield textObj.renderTextLayerAsync(scale);
            parent.append(textObj._container);
            return textObj;
        });
    }
    destroy() {
        this.destroyRenderTask();
        if (this._container) {
            this._container.remove();
            this._container = null;
        }
    }
    renderTextLayerAsync(scale) {
        return __awaiter$3(this, void 0, void 0, function* () {
            this.clear();
            this.destroyRenderTask();
            const viewport = this._pageProxy.getViewport({ scale });
            const textContentStream = this._pageProxy.streamTextContent();
            this._renderTask = renderTextLayer({
                container: this._container,
                textContentStream,
                viewport,
                enhanceTextSelection: true,
            });
            try {
                yield this._renderTask.promise;
            }
            catch (error) {
                if (error.message === "TextLayer task cancelled.") {
                    return false;
                }
                else {
                    throw error;
                }
            }
            return true;
        });
    }
    clear() {
        this._container.innerHTML = "";
    }
    destroyRenderTask() {
        if (this._renderTask) {
            this._renderTask.cancel();
            this._renderTask = null;
        }
    }
}

var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PageAnnotationView {
    constructor(docData, pageId, pageDimensions) {
        this._rendered = new Map();
        if (!docData || isNaN(pageId) || !pageDimensions) {
            throw new Error("Required argument not found");
        }
        this._pageId = pageId;
        this._pageDimensions = pageDimensions;
        this._docData = docData;
        this._container = document.createElement("div");
        this._container.classList.add("page-annotations");
        this._svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        this._svg.classList.add("stretch");
        this._svg.setAttribute("data-page-id", pageId + "");
        this._svg.setAttribute("viewBox", `0 0 ${pageDimensions.x} ${pageDimensions.y}`);
        this._svg.setAttribute("transform", "scale(1, -1)");
        this._svg.addEventListener("pointerdown", (e) => {
            if (e.target === this._svg) {
                this.switchSelectedAnnotation(null);
            }
        });
        this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        this._container.append(this._svg);
    }
    destroy() {
        this.remove();
        this._container = null;
    }
    remove() {
        var _a;
        (_a = this._container) === null || _a === void 0 ? void 0 : _a.remove();
    }
    appendAsync(parent) {
        return __awaiter$4(this, void 0, void 0, function* () {
            yield this.renderAnnotationsAsync();
            parent.append(this._container);
        });
    }
    switchSelectedAnnotation(annotation) {
        var _a, _b;
        if (annotation === this._selectedAnnotation) {
            return;
        }
        if (this._selectedAnnotation) {
            const oldSelectedSvg = (_a = this._rendered.get(this._selectedAnnotation)) === null || _a === void 0 ? void 0 : _a.svg;
            oldSelectedSvg === null || oldSelectedSvg === void 0 ? void 0 : oldSelectedSvg.classList.remove("selected");
        }
        const newSelectedSvg = (_b = this._rendered.get(annotation)) === null || _b === void 0 ? void 0 : _b.svg;
        if (!newSelectedSvg) {
            this._selectedAnnotation = null;
            return;
        }
        newSelectedSvg.classList.add("selected");
        this._svg.append(newSelectedSvg);
        this._selectedAnnotation = annotation;
    }
    renderAnnotationsAsync() {
        return __awaiter$4(this, void 0, void 0, function* () {
            this.clear();
            const annotations = this._docData.getPageAnnotations(this._pageId) || [];
            for (let i = 0; i < annotations.length || 0; i++) {
                const annotation = annotations[i];
                let renderResult;
                if (!this._rendered.has(annotation)) {
                    yield new Promise(resolve => {
                        setTimeout(() => __awaiter$4(this, void 0, void 0, function* () {
                            renderResult = yield annotation.renderAsync();
                            resolve();
                        }), 0);
                    });
                }
                else {
                    renderResult = this._rendered.get(annotation);
                }
                if (!renderResult) {
                    continue;
                }
                this._rendered.set(annotation, renderResult);
                const { svg, clipPaths } = renderResult;
                this._svg.append(svg);
                clipPaths === null || clipPaths === void 0 ? void 0 : clipPaths.forEach(x => this._defs.append(x));
                svg.addEventListener("pointerdown", () => this.switchSelectedAnnotation(annotation));
            }
            this._svg.append(this._defs);
            return true;
        });
    }
    clear() {
        this._svg.innerHTML = "";
    }
}

var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PageView {
    constructor(pageProxy, docData, maxScale, previewWidth) {
        if (!pageProxy) {
            throw new Error("Page proxy is not defined");
        }
        if (!docData) {
            throw new Error("Annotation data is not defined");
        }
        this._pageProxy = pageProxy;
        this._viewport = pageProxy.getViewport({ scale: 1 });
        this._maxScale = Math.max(maxScale, 1);
        this._docData = docData;
        this.number = pageProxy.pageNumber;
        this.id = pageProxy.ref["num"];
        this.generation = pageProxy.ref["gen"];
        const { width, height } = this._viewport;
        previewWidth = Math.max(previewWidth !== null && previewWidth !== void 0 ? previewWidth : 0, 50);
        const previewHeight = previewWidth * (height / width);
        this._dimensions = { width, height, previewWidth, previewHeight };
        this._previewContainer = document.createElement("div");
        this._previewContainer.classList.add("page-preview");
        this._previewContainer.setAttribute("data-page-number", this.number + "");
        this._previewContainer.setAttribute("data-page-id", this.id + "");
        this._previewContainer.setAttribute("data-page-gen", this.generation + "");
        this._previewContainer.style.width = this._dimensions.previewWidth + "px";
        this._previewContainer.style.height = this._dimensions.previewHeight + "px";
        this._viewContainer = document.createElement("div");
        this._viewContainer.classList.add("page");
        this._viewContainer.setAttribute("data-page-number", this.number + "");
        this._viewContainer.setAttribute("data-page-id", this.id + "");
        this._viewContainer.setAttribute("data-page-gen", this.generation + "");
        this.scale = 1;
    }
    get previewContainer() {
        return this._previewContainer;
    }
    get viewContainer() {
        return this._viewContainer;
    }
    set _viewRendered(value) {
        this.$viewRendered = value;
        this._viewContainer.setAttribute("data-loaded", value + "");
    }
    get _viewRendered() {
        return this.$viewRendered;
    }
    set scale(value) {
        if (value <= 0 || this._scale === value) {
            return;
        }
        this._scale = value;
        const dpr = window.devicePixelRatio;
        this._dimensions.scaledWidth = this._dimensions.width * this._scale;
        this._dimensions.scaledHeight = this._dimensions.height * this._scale;
        this._dimensions.scaledDprWidth = this._dimensions.scaledWidth * dpr;
        this._dimensions.scaledDprHeight = this._dimensions.scaledHeight * dpr;
        this._viewContainer.style.width = this._dimensions.scaledWidth + "px";
        this._viewContainer.style.height = this._dimensions.scaledHeight + "px";
        if (this._viewCanvas) {
            this._viewCanvas.style.width = this._dimensions.scaledWidth + "px";
            this._viewCanvas.style.height = this._dimensions.scaledHeight + "px";
        }
        this._scaleIsValid = false;
    }
    get viewValid() {
        return this._scaleIsValid && this._viewRendered;
    }
    destroy() {
        this._previewContainer.remove();
        this._viewContainer.remove();
        this._pageProxy.cleanup();
    }
    renderPreviewAsync(force = false) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (this._renderPromise) {
                if (force) {
                    this.cancelRenderTask();
                }
                yield this._renderPromise;
            }
            if (!force && this._previewRendered) {
                return;
            }
            this._renderPromise = this.runPreviewRenderAsync();
            return this._renderPromise;
        });
    }
    renderViewAsync(force = false) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (this._renderPromise) {
                if (force) {
                    this.cancelRenderTask();
                }
                yield this._renderPromise;
            }
            if (!force && this.viewValid) {
                return;
            }
            this._renderPromise = this.runViewRenderAsync();
            return this._renderPromise;
        });
    }
    clearPreview() {
        this._previewContainer.innerHTML = "";
    }
    clearView() {
        var _a, _b, _c;
        (_a = this._annotations) === null || _a === void 0 ? void 0 : _a.destroy();
        this._annotations = null;
        (_b = this._text) === null || _b === void 0 ? void 0 : _b.destroy();
        this._text = null;
        (_c = this._viewCanvas) === null || _c === void 0 ? void 0 : _c.remove();
        this._viewRendered = false;
    }
    clearAnnotationSelection() {
        var _a;
        (_a = this._annotations) === null || _a === void 0 ? void 0 : _a.switchSelectedAnnotation(null);
    }
    cancelRenderTask() {
        if (this._renderTask) {
            this._renderTask.cancel();
            this._renderTask = null;
        }
    }
    runRenderTaskAsync(renderParams) {
        return __awaiter$5(this, void 0, void 0, function* () {
            this.cancelRenderTask();
            this._renderTask = this._pageProxy.render(renderParams);
            try {
                yield this._renderTask.promise;
            }
            catch (error) {
                if (error instanceof RenderingCancelledException) {
                    return false;
                }
                else {
                    throw error;
                }
            }
            finally {
                this._renderTask = null;
            }
            return true;
        });
    }
    createPreviewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("page-canvas");
        const dpr = window.devicePixelRatio;
        const { previewWidth: width, previewHeight: height } = this._dimensions;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        return canvas;
    }
    createViewCanvas() {
        const canvas = document.createElement("canvas");
        canvas.classList.add("page-canvas");
        canvas.style.width = this._dimensions.scaledWidth + "px";
        canvas.style.height = this._dimensions.scaledHeight + "px";
        canvas.width = this._dimensions.scaledDprWidth;
        canvas.height = this._dimensions.scaledDprHeight;
        return canvas;
    }
    scaleCanvasImage(sourceCanvas, targetCanvas) {
        let ratio = this._scale / this._maxScale;
        let tempSource = sourceCanvas;
        let tempTarget;
        while (ratio < 0.5) {
            tempTarget = document.createElement("canvas");
            tempTarget.width = tempSource.width * 0.5;
            tempTarget.height = tempSource.height * 0.5;
            tempTarget.getContext("2d").drawImage(tempSource, 0, 0, tempTarget.width, tempTarget.height);
            tempSource = tempTarget;
            ratio *= 2;
        }
        targetCanvas.getContext("2d").drawImage(tempSource, 0, 0, targetCanvas.width, targetCanvas.height);
    }
    runPreviewRenderAsync() {
        return __awaiter$5(this, void 0, void 0, function* () {
            const canvas = this.createPreviewCanvas();
            const params = {
                canvasContext: canvas.getContext("2d"),
                viewport: this._viewport.clone({ scale: canvas.width / this._dimensions.width }),
            };
            const result = yield this.runRenderTaskAsync(params);
            if (!result) {
                this._previewRendered = false;
                return;
            }
            this._previewContainer.innerHTML = "";
            this._previewContainer.append(canvas);
            this._previewRendered = true;
        });
    }
    runViewRenderAsync() {
        var _a, _b;
        return __awaiter$5(this, void 0, void 0, function* () {
            const scale = this._scale;
            (_a = this._text) === null || _a === void 0 ? void 0 : _a.destroy();
            this._text = null;
            const canvas = this.createViewCanvas();
            const params = {
                canvasContext: canvas.getContext("2d"),
                viewport: this._viewport.clone({ scale: scale * window.devicePixelRatio }),
                enableWebGL: true,
            };
            const result = yield this.runRenderTaskAsync(params);
            if (!result || scale !== this._scale) {
                return;
            }
            (_b = this._viewCanvas) === null || _b === void 0 ? void 0 : _b.remove();
            this._viewContainer.append(canvas);
            this._viewCanvas = canvas;
            this._viewRendered = true;
            this._text = yield PageTextView.appendPageTextAsync(this._pageProxy, this._viewContainer, scale);
            if (!this._annotations) {
                const { width: x, height: y } = this._dimensions;
                this._annotations = new PageAnnotationView(this._docData, this.id, new Vec2(x, y));
            }
            yield this._annotations.appendAsync(this.viewContainer);
            if (scale === this._scale) {
                this._scaleIsValid = true;
            }
        });
    }
}

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class TsPdfViewer {
    constructor(containerSelector, workerSrc) {
        this._visibleAdjPages = 0;
        this._previewWidth = 100;
        this._minScale = 0.25;
        this._maxScale = 4;
        this._scale = 1;
        this._previewerHidden = true;
        this._pages = [];
        this._renderedPages = [];
        this._currentPage = 0;
        this._pointerInfo = {
            lastPos: null,
            downPos: null,
            downScroll: null,
        };
        this._timers = {
            hidePanels: 0,
        };
        this._pinchInfo = {
            active: false,
            lastDist: 0,
            minDist: 10,
            sensitivity: 0.025,
            target: null,
        };
        this.onPdfLoadingProgress = (progressData) => {
        };
        this.onPdfLoadedAsync = (doc, docData) => __awaiter$6(this, void 0, void 0, function* () {
            this._pdfDocument = doc;
            this._docData = docData;
            yield this.refreshPagesAsync();
            this.renderVisiblePreviews();
            this.renderVisiblePages();
            this._shadowRoot.querySelector("#bottom-panel").classList.remove("disabled");
        });
        this.onPdfClosedAsync = () => __awaiter$6(this, void 0, void 0, function* () {
            this._shadowRoot.querySelector("#bottom-panel").classList.add("disabled");
            this.setViewerMode("text");
            if (this._pdfDocument) {
                this._pdfDocument = null;
                this._docData = null;
            }
            yield this.refreshPagesAsync();
        });
        this.onPreviewerToggleClick = () => {
            if (this._previewerHidden) {
                this._mainContainer.classList.remove("hide-previewer");
                this._shadowRoot.querySelector("div#toggle-previewer").classList.add("on");
                this._previewerHidden = false;
                setTimeout(() => this.renderVisiblePreviews(), 1000);
            }
            else {
                this._mainContainer.classList.add("hide-previewer");
                this._shadowRoot.querySelector("div#toggle-previewer").classList.remove("on");
                this._previewerHidden = true;
            }
        };
        this.onPreviewerPageClick = (e) => {
            let target = e.target;
            let pageNumber;
            while (target && !pageNumber) {
                const data = target.dataset["pageNumber"];
                if (data) {
                    pageNumber = +data;
                }
                else {
                    target = target.parentElement;
                }
            }
            if (pageNumber) {
                this.scrollToPage(pageNumber - 1);
            }
        };
        this.onPreviewerScroll = (e) => {
            this.renderVisiblePreviews();
        };
        this.onViewerPointerMove = (event) => {
            const { clientX, clientY } = event;
            const { x: rectX, y: rectY, width, height } = this._viewer.getBoundingClientRect();
            const l = clientX - rectX;
            const t = clientY - rectY;
            const r = width - l;
            const b = height - t;
            if (Math.min(l, r, t, b) > 100) {
                if (!this._panelsHidden && !this._timers.hidePanels) {
                    this._timers.hidePanels = setTimeout(() => {
                        this._mainContainer.classList.add("hide-panels");
                        this._panelsHidden = true;
                        this._timers.hidePanels = null;
                    }, 5000);
                }
            }
            else {
                if (this._timers.hidePanels) {
                    clearTimeout(this._timers.hidePanels);
                    this._timers.hidePanels = null;
                }
                if (this._panelsHidden) {
                    this._mainContainer.classList.remove("hide-panels");
                    this._panelsHidden = false;
                }
            }
            this._pointerInfo.lastPos = new Vec2(clientX, clientY);
        };
        this.onTextModeButtonClick = () => {
            this.setViewerMode("text");
        };
        this.onHandModeButtonClick = () => {
            this.setViewerMode("hand");
        };
        this.onAnnotationModeButtonClick = () => {
            this.setViewerMode("annotation");
        };
        this.onViewerScroll = (e) => {
            this.renderVisiblePages();
        };
        this.onViewerPointerDownScroll = (event) => {
            if (this._viewerMode !== "hand") {
                return;
            }
            const { clientX, clientY } = event;
            this._pointerInfo.downPos = new Vec2(clientX, clientY);
            this._pointerInfo.downScroll = new Vec2(this._viewer.scrollLeft, this._viewer.scrollTop);
            const onPointerMove = (moveEvent) => {
                const { x, y } = this._pointerInfo.downPos;
                const { x: left, y: top } = this._pointerInfo.downScroll;
                const dX = moveEvent.clientX - x;
                const dY = moveEvent.clientY - y;
                this._viewer.scrollTo(left - dX, top - dY);
            };
            const onPointerUp = (upEvent) => {
                this._pointerInfo.downPos = null;
                this._pointerInfo.downScroll = null;
                window.removeEventListener("pointermove", onPointerMove);
                window.removeEventListener("pointerup", onPointerUp);
                window.removeEventListener("pointerout", onPointerUp);
            };
            window.addEventListener("pointermove", onPointerMove);
            window.addEventListener("pointerup", onPointerUp);
            window.addEventListener("pointerout", onPointerUp);
        };
        this.onViewerWheelZoom = (event) => {
            if (!event.ctrlKey) {
                return;
            }
            event.preventDefault();
            if (event.deltaY > 0) {
                this.zoomOut(this._pointerInfo.lastPos);
            }
            else {
                this.zoomIn(this._pointerInfo.lastPos);
            }
        };
        this.onViewerTouchZoom = (event) => {
            if (event.touches.length !== 2) {
                return;
            }
            const a = event.touches[0];
            const b = event.touches[1];
            this._pinchInfo.active = true;
            this._pinchInfo.lastDist = getDistance(a.clientX, a.clientY, b.clientX, b.clientY);
            const onTouchMove = (moveEvent) => {
                if (moveEvent.touches.length !== 2) {
                    return;
                }
                const mA = moveEvent.touches[0];
                const mB = moveEvent.touches[1];
                const dist = getDistance(mA.clientX, mA.clientY, mB.clientX, mB.clientY);
                const delta = dist - this._pinchInfo.lastDist;
                const factor = Math.floor(delta / this._pinchInfo.minDist);
                if (factor) {
                    const center = new Vec2((mB.clientX + mA.clientX) / 2, (mB.clientY + mA.clientY) / 2);
                    this._pinchInfo.lastDist = dist;
                    this.zoom(factor * this._pinchInfo.sensitivity, center);
                }
            };
            const onTouchEnd = (endEvent) => {
                this._pinchInfo.active = false;
                this._pinchInfo.lastDist = 0;
                event.target.removeEventListener("touchmove", onTouchMove);
                event.target.removeEventListener("touchend", onTouchEnd);
                event.target.removeEventListener("touchcancel", onTouchEnd);
            };
            event.target.addEventListener("touchmove", onTouchMove);
            event.target.addEventListener("touchend", onTouchEnd);
            event.target.addEventListener("touchcancel", onTouchEnd);
        };
        this.onZoomOutClick = () => {
            this.zoomOut();
        };
        this.onZoomInClick = () => {
            this.zoomIn();
        };
        this.onZoomFitViewerClick = () => {
            const cWidth = this._viewer.getBoundingClientRect().width;
            const pWidth = this._pages[this._currentPage].viewContainer.getBoundingClientRect().width;
            const scale = clamp((cWidth - 20) / pWidth * this._scale, this._minScale, this._maxScale);
            this.setScale(scale);
            this.scrollToPage(this._currentPage);
        };
        this.onZoomFitPageClick = () => {
            const { width: cWidth, height: cHeight } = this._viewer.getBoundingClientRect();
            const { width: pWidth, height: pHeight } = this._pages[this._currentPage].viewContainer.getBoundingClientRect();
            const hScale = clamp((cWidth - 20) / pWidth * this._scale, this._minScale, this._maxScale);
            const vScale = clamp((cHeight - 20) / pHeight * this._scale, this._minScale, this._maxScale);
            this.setScale(Math.min(hScale, vScale));
            this.scrollToPage(this._currentPage);
        };
        this.onPaginatorInput = (event) => {
            if (event.target instanceof HTMLInputElement) {
                event.target.value = event.target.value.replace(/[^\d]+/g, "");
            }
        };
        this.onPaginatorChange = (event) => {
            if (event.target instanceof HTMLInputElement) {
                const pageNumber = Math.max(Math.min(+event.target.value, this._pdfDocument.numPages), 1);
                if (pageNumber + "" !== event.target.value) {
                    event.target.value = pageNumber + "";
                }
                this.scrollToPage(pageNumber - 1);
            }
        };
        this.onPaginatorPrevClick = () => {
            const pageNumber = clamp(this._currentPage - 1, 0, this._pages.length - 1);
            this.scrollToPage(pageNumber);
        };
        this.onPaginatorNextClick = () => {
            const pageNumber = clamp(this._currentPage + 1, 0, this._pages.length - 1);
            this.scrollToPage(pageNumber);
        };
        this.onAnnotationSelectModeButtonClick = () => {
            this.setAnnotationMode("select");
        };
        this.onAnnotationStampModeButtonClick = () => {
            this.setAnnotationMode("stamp");
        };
        this.onAnnotationPenModeButtonClick = () => {
            this.setAnnotationMode("pen");
        };
        this.onAnnotationGeometricModeButtonClick = () => {
            this.setAnnotationMode("geometric");
        };
        this.onStampAnnotationOverlayPointerMove = (e) => {
            const { clientX: cx, clientY: cy } = e;
            const { height: oh, top, left: ox } = this._viewer.getBoundingClientRect();
            const oy = top + oh;
            const offsetX = (cx - ox) / this._scale;
            const offsetY = (oy - cy) / this._scale;
            const [x1, y1, x2, y2] = this._annotationToAdd.Rect;
            this._annotationOverlaySvg.setAttribute("transform", `translate(${offsetX - (x2 - x1) / 2} ${offsetY - (y2 - y1) / 2})`);
            const pageCoords = this.getPageCoordsUnderPointer(cx, cy);
            if (!pageCoords) {
                this._annotationOverlaySvg.classList.add("out");
            }
            else {
                this._annotationOverlaySvg.classList.remove("out");
            }
            this._annotationOverlayPageCoords = pageCoords;
        };
        this.onStampAnnotationOverlayPointerUp = (e) => {
            var _a;
            const { clientX: cx, clientY: cy } = e;
            const pageCoords = this.getPageCoordsUnderPointer(cx, cy);
            this._annotationOverlayPageCoords = pageCoords;
            if (!pageCoords || !this._annotationToAdd) {
                return;
            }
            const { pageId, pageX, pageY } = this._annotationOverlayPageCoords;
            this._annotationToAdd.moveTo(pageX, pageY);
            this._docData.appendAnnotationToPage(pageId, this._annotationToAdd);
            (_a = this._renderedPages.find(x => x.id === pageId)) === null || _a === void 0 ? void 0 : _a.renderViewAsync(true);
            this.createTempStampAnnotationAsync();
        };
        this.onDownloadFileButtonClick = () => {
            var _a;
            const data = (_a = this._docData) === null || _a === void 0 ? void 0 : _a.getDataWithUpdatedAnnotations();
            if (data === null || data === void 0 ? void 0 : data.length) {
                TsPdfViewer.downloadFile(data, `file_${new Date().toISOString()}.pdf`);
            }
        };
        const container = document.querySelector(containerSelector);
        if (!container) {
            throw new Error("Container not found");
        }
        else if (!(container instanceof HTMLDivElement)) {
            throw new Error("Container is not a DIV element");
        }
        else {
            this._outerContainer = container;
        }
        if (!workerSrc) {
            throw new Error("Worker source path not defined");
        }
        GlobalWorkerOptions.workerSrc = workerSrc;
        this.initViewerGUI();
    }
    static downloadFile(data, name, mime = "application/pdf") {
        const blob = new Blob([data], {
            type: mime,
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("download", name);
        link.href = url;
        document.body.appendChild(link);
        link.click();
        link.remove();
        setTimeout(() => URL.revokeObjectURL(url), 10000);
    }
    destroy() {
        var _a, _b, _c, _d;
        (_a = this._pdfLoadingTask) === null || _a === void 0 ? void 0 : _a.destroy();
        this._pages.forEach(x => x.destroy());
        if (this._pdfDocument) {
            this._pdfDocument.cleanup();
            this._pdfDocument.destroy();
        }
        (_b = this._mainContainerRObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this._annotationOverlayMObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
        (_d = this._annotationOverlayRObserver) === null || _d === void 0 ? void 0 : _d.disconnect();
        this._shadowRoot.innerHTML = "";
    }
    openPdfAsync(src) {
        return __awaiter$6(this, void 0, void 0, function* () {
            let data;
            let doc;
            try {
                if (src instanceof Uint8Array) {
                    data = src;
                }
                else {
                    let blob;
                    if (typeof src === "string") {
                        const res = yield fetch(src);
                        blob = yield res.blob();
                    }
                    else {
                        blob = src;
                    }
                    const buffer = yield blob.arrayBuffer();
                    data = new Uint8Array(buffer);
                }
            }
            catch (e) {
                throw new Error(`Cannot load file data: ${e.message}`);
            }
            const docData = new DocumentData(data);
            let password;
            while (true) {
                const authenticated = docData.tryAuthenticate(password);
                if (!authenticated) {
                    password = yield this.showPasswordDialogAsync();
                    if (password === null) {
                        throw new Error("File loading cancelled: authentication aborted");
                    }
                    continue;
                }
                break;
            }
            data = docData.getDataWithoutSupportedAnnotations();
            try {
                if (this._pdfLoadingTask) {
                    yield this.closePdfAsync();
                    return this.openPdfAsync(data);
                }
                this._pdfLoadingTask = getDocument({ data, password });
                this._pdfLoadingTask.onProgress = this.onPdfLoadingProgress;
                doc = yield this._pdfLoadingTask.promise;
                this._pdfLoadingTask = null;
            }
            catch (e) {
                throw new Error(`Cannot open PDF: ${e.message}`);
            }
            yield this.onPdfLoadedAsync(doc, docData);
        });
    }
    closePdfAsync() {
        return __awaiter$6(this, void 0, void 0, function* () {
            if (this._pdfLoadingTask) {
                if (!this._pdfLoadingTask.destroyed) {
                    yield this._pdfLoadingTask.destroy();
                }
                this._pdfLoadingTask = null;
            }
            yield this.onPdfClosedAsync();
        });
    }
    initViewerGUI() {
        this._shadowRoot = this._outerContainer.attachShadow({ mode: "open" });
        this._shadowRoot.innerHTML = styles + html;
        this.initMainDivs();
        this.initViewControls();
        this.initModeSwitches();
        this.initAnnotationOverlay();
    }
    initMainDivs() {
        const mainContainer = this._shadowRoot.querySelector("div#main-container");
        const mcResizeObserver = new ResizeObserver((entries) => {
            const { width } = this._mainContainer.getBoundingClientRect();
            if (width < 721) {
                this._mainContainer.classList.add("mobile");
            }
            else {
                this._mainContainer.classList.remove("mobile");
            }
        });
        mcResizeObserver.observe(mainContainer);
        this._mainContainer = mainContainer;
        this._mainContainerRObserver = mcResizeObserver;
        this._previewer = this._shadowRoot.querySelector("#previewer");
        this._viewer = this._shadowRoot.querySelector("#viewer");
    }
    initViewControls() {
        const paginatorInput = this._shadowRoot.getElementById("paginator-input");
        paginatorInput.addEventListener("input", this.onPaginatorInput);
        paginatorInput.addEventListener("change", this.onPaginatorChange);
        this._shadowRoot.querySelector("#paginator-prev")
            .addEventListener("click", this.onPaginatorPrevClick);
        this._shadowRoot.querySelector("#paginator-next")
            .addEventListener("click", this.onPaginatorNextClick);
        this._shadowRoot.querySelector("#zoom-out")
            .addEventListener("click", this.onZoomOutClick);
        this._shadowRoot.querySelector("#zoom-in")
            .addEventListener("click", this.onZoomInClick);
        this._shadowRoot.querySelector("#zoom-fit-viewer")
            .addEventListener("click", this.onZoomFitViewerClick);
        this._shadowRoot.querySelector("#zoom-fit-page")
            .addEventListener("click", this.onZoomFitPageClick);
        this._shadowRoot.querySelector("#toggle-previewer")
            .addEventListener("click", this.onPreviewerToggleClick);
        this._previewer.addEventListener("scroll", this.onPreviewerScroll);
        this._viewer.addEventListener("scroll", this.onViewerScroll);
        this._viewer.addEventListener("wheel", this.onViewerWheelZoom);
        this._viewer.addEventListener("pointermove", this.onViewerPointerMove);
        this._viewer.addEventListener("pointerdown", this.onViewerPointerDownScroll);
        this._viewer.addEventListener("touchstart", this.onViewerTouchZoom);
        this._shadowRoot.querySelector("#button-download-file")
            .addEventListener("click", this.onDownloadFileButtonClick);
    }
    initModeSwitches() {
        this._shadowRoot.querySelector("#button-mode-text")
            .addEventListener("click", this.onTextModeButtonClick);
        this._shadowRoot.querySelector("#button-mode-hand")
            .addEventListener("click", this.onHandModeButtonClick);
        this._shadowRoot.querySelector("#button-mode-annotation")
            .addEventListener("click", this.onAnnotationModeButtonClick);
        this.setViewerMode("text");
        this._shadowRoot.querySelector("#button-annotation-mode-select")
            .addEventListener("click", this.onAnnotationSelectModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-stamp")
            .addEventListener("click", this.onAnnotationStampModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-pen")
            .addEventListener("click", this.onAnnotationPenModeButtonClick);
        this._shadowRoot.querySelector("#button-annotation-mode-geometric")
            .addEventListener("click", this.onAnnotationGeometricModeButtonClick);
        this.setAnnotationMode("select");
    }
    initAnnotationOverlay() {
        const annotationOverlay = document.createElement("div");
        annotationOverlay.classList.add("absolute", "stretch", "no-margin", "no-padding");
        annotationOverlay.id = "annotation-overlay";
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add("abs-stretch", "no-margin", "no-padding");
        svg.setAttribute("transform", "matrix(1 0 0 -1 0 0)");
        svg.setAttribute("opacity", "0.5");
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svg.append(g);
        annotationOverlay.append(svg);
        this._viewer.addEventListener("scroll", () => {
            annotationOverlay.style.left = this._viewer.scrollLeft + "px";
            annotationOverlay.style.top = this._viewer.scrollTop + "px";
        });
        let lastScale;
        const updateSvgViewBox = () => {
            const { width: w, height: h } = annotationOverlay.getBoundingClientRect();
            if (!w || !h) {
                return;
            }
            const viewBoxWidth = w / this._scale;
            const viewBoxHeight = h / this._scale;
            svg.setAttribute("viewBox", `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
            lastScale = this._scale;
        };
        updateSvgViewBox();
        const onPossibleViewerSizeChanged = () => {
            if (this._scale === lastScale) {
                return;
            }
            updateSvgViewBox();
        };
        const viewerRObserver = new ResizeObserver((entries) => {
            onPossibleViewerSizeChanged();
        });
        const viewerMObserver = new MutationObserver((mutations) => {
            const record = mutations[0];
            if (!record) {
                return;
            }
            record.addedNodes.forEach(x => {
                const element = x;
                if (element.classList.contains("page")) {
                    viewerRObserver.observe(x);
                }
            });
            record.removedNodes.forEach(x => viewerRObserver.unobserve(x));
            onPossibleViewerSizeChanged();
        });
        viewerMObserver.observe(this._viewer, {
            attributes: false,
            childList: true,
            subtree: false,
        });
        this._annotationOverlayMObserver = viewerMObserver;
        this._annotationOverlayRObserver = viewerRObserver;
        this._annotationOverlay = annotationOverlay;
        this._annotationOverlaySvg = g;
    }
    refreshPagesAsync() {
        var _a;
        return __awaiter$6(this, void 0, void 0, function* () {
            this._pages.forEach(x => {
                x.previewContainer.removeEventListener("click", this.onPreviewerPageClick);
                x.destroy();
            });
            this._pages.length = 0;
            const docPagesNumber = ((_a = this._pdfDocument) === null || _a === void 0 ? void 0 : _a.numPages) || 0;
            this._shadowRoot.getElementById("paginator-total").innerHTML = docPagesNumber + "";
            if (!docPagesNumber) {
                return;
            }
            for (let i = 0; i < docPagesNumber; i++) {
                const pageProxy = yield this._pdfDocument.getPage(i + 1);
                const page = new PageView(pageProxy, this._docData, this._maxScale, this._previewWidth);
                page.scale = this._scale;
                page.previewContainer.addEventListener("click", this.onPreviewerPageClick);
                this._previewer.append(page.previewContainer);
                this._viewer.append(page.viewContainer);
                this._pages.push(page);
            }
        });
    }
    scrollToPreview(pageNumber) {
        const { top: cTop, height: cHeight } = this._previewer.getBoundingClientRect();
        const { top: pTop, height: pHeight } = this._pages[pageNumber].previewContainer.getBoundingClientRect();
        const cCenter = cTop + cHeight / 2;
        const pCenter = pTop + pHeight / 2;
        const scroll = pCenter - cCenter + this._previewer.scrollTop;
        this._previewer.scrollTo(0, scroll);
    }
    setViewerMode(mode) {
        if (!mode || mode === this._viewerMode) {
            return;
        }
        this.disableCurrentViewerMode();
        switch (mode) {
            case "text":
                this._mainContainer.classList.add("mode-text");
                this._shadowRoot.querySelector("#button-mode-text").classList.add("on");
                break;
            case "hand":
                this._mainContainer.classList.add("mode-hand");
                this._shadowRoot.querySelector("#button-mode-hand").classList.add("on");
                break;
            case "annotation":
                this._mainContainer.classList.add("mode-annotation");
                this._shadowRoot.querySelector("#button-mode-annotation").classList.add("on");
                break;
            default:
                throw new Error(`Invalid viewer mode: ${mode}`);
        }
        this._viewerMode = mode;
    }
    disableCurrentViewerMode() {
        switch (this._viewerMode) {
            case "text":
                this._mainContainer.classList.remove("mode-text");
                this._shadowRoot.querySelector("#button-mode-text").classList.remove("on");
                break;
            case "hand":
                this._mainContainer.classList.remove("mode-hand");
                this._shadowRoot.querySelector("#button-mode-hand").classList.remove("on");
                break;
            case "annotation":
                this._mainContainer.classList.remove("mode-annotation");
                this._shadowRoot.querySelector("#button-mode-annotation").classList.remove("on");
                this.setAnnotationMode("select");
                break;
        }
    }
    scrollToPage(pageNumber) {
        const { top: cTop } = this._viewer.getBoundingClientRect();
        const { top: pTop } = this._pages[pageNumber].viewContainer.getBoundingClientRect();
        const scroll = pTop - (cTop - this._viewer.scrollTop);
        this._viewer.scrollTo(this._viewer.scrollLeft, scroll);
    }
    setScale(scale, cursorPosition = null) {
        if (!scale || scale === this._scale) {
            return;
        }
        let pageContainerUnderPivot;
        let xPageRatio;
        let yPageRatio;
        if (cursorPosition) {
            for (const page of this._pages) {
                const { x: x, y: y } = cursorPosition;
                const { x: pX, y: pY, width: pWidth, height: pHeight } = page.viewContainer.getBoundingClientRect();
                if (pX <= x
                    && pX + pWidth >= x
                    && pY <= y
                    && pY + pHeight >= y) {
                    pageContainerUnderPivot = page.viewContainer;
                    xPageRatio = (x - pX) / pWidth;
                    yPageRatio = (y - pY) / pHeight;
                    break;
                }
            }
        }
        this._scale = scale;
        this._pages.forEach(x => x.scale = this._scale);
        if (pageContainerUnderPivot
            &&
                (this._viewer.scrollHeight > this._viewer.clientHeight
                    || this._viewer.scrollWidth > this._viewer.clientWidth)) {
            const { x: initialX, y: initialY } = cursorPosition;
            const { x: pX, y: pY, width: pWidth, height: pHeight } = pageContainerUnderPivot.getBoundingClientRect();
            const resultX = pX + (pWidth * xPageRatio);
            const resultY = pY + (pHeight * yPageRatio);
            let scrollLeft = this._viewer.scrollLeft + (resultX - initialX);
            let scrollTop = this._viewer.scrollTop + (resultY - initialY);
            scrollLeft = scrollLeft < 0
                ? 0
                : scrollLeft;
            scrollTop = scrollTop < 0
                ? 0
                : scrollTop;
            if (scrollTop !== this._viewer.scrollTop
                || scrollLeft !== this._viewer.scrollLeft) {
                this._viewer.scrollTo(scrollLeft, scrollTop);
                return;
            }
        }
        setTimeout(() => this.renderVisiblePages(), 0);
    }
    zoom(diff, cursorPosition = null) {
        const scale = clamp(this._scale + diff, this._minScale, this._maxScale);
        this.setScale(scale, cursorPosition || this.getViewerCenterPosition());
    }
    zoomOut(cursorPosition = null) {
        this.zoom(-0.25, cursorPosition);
    }
    zoomIn(cursorPosition = null) {
        this.zoom(0.25, cursorPosition);
    }
    getViewerCenterPosition() {
        const { x, y, width, height } = this._viewer.getBoundingClientRect();
        return new Vec2(x + width / 2, y + height / 2);
    }
    getVisiblePages(container, pages, preview = false) {
        const pagesVisible = new Set();
        if (!pages.length) {
            return pagesVisible;
        }
        const cRect = container.getBoundingClientRect();
        const cTop = cRect.top;
        const cBottom = cRect.top + cRect.height;
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            const pRect = preview
                ? page.previewContainer.getBoundingClientRect()
                : page.viewContainer.getBoundingClientRect();
            const pTop = pRect.top;
            const pBottom = pRect.top + pRect.height;
            if (pTop < cBottom && pBottom > cTop) {
                pagesVisible.add(i);
            }
            else if (pagesVisible.size) {
                break;
            }
        }
        return pagesVisible;
    }
    getCurrentPage(container, pages, visiblePageNumbers) {
        const visiblePageNumbersArray = [...visiblePageNumbers];
        if (!visiblePageNumbersArray.length) {
            return -1;
        }
        else if (visiblePageNumbersArray.length === 1) {
            return visiblePageNumbersArray[0];
        }
        const cRect = container.getBoundingClientRect();
        const cTop = cRect.top;
        const cMiddle = cRect.top + cRect.height / 2;
        for (const i of visiblePageNumbersArray) {
            const pRect = pages[i].viewContainer.getBoundingClientRect();
            const pTop = pRect.top;
            if (pTop > cTop) {
                if (pTop > cMiddle) {
                    return i - 1;
                }
                else {
                    return i;
                }
            }
        }
        throw new Error("Incorrect argument");
    }
    getPageCoordsUnderPointer(clientX, clientY) {
        for (const page of this._renderedPages) {
            const { left: pxMin, top: pyMin, width: pw, height: ph } = page.viewContainer.getBoundingClientRect();
            const pxMax = pxMin + pw;
            const pyMax = pyMin + ph;
            if (clientX < pxMin || clientX > pxMax) {
                continue;
            }
            if (clientY < pyMin || clientY > pyMax) {
                continue;
            }
            const x = (clientX - pxMin) / this._scale;
            const y = (pyMax - clientY) / this._scale;
            return {
                pageId: page.id,
                pageX: x,
                pageY: y,
            };
        }
        return null;
    }
    renderVisiblePreviews() {
        if (this._previewerHidden) {
            return;
        }
        const pages = this._pages;
        const visiblePreviewNumbers = this.getVisiblePages(this._previewer, pages, true);
        const minPageNumber = Math.max(Math.min(...visiblePreviewNumbers) - this._visibleAdjPages, 0);
        const maxPageNumber = Math.min(Math.max(...visiblePreviewNumbers) + this._visibleAdjPages, pages.length - 1);
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            if (i >= minPageNumber && i <= maxPageNumber) {
                page.renderPreviewAsync();
            }
        }
    }
    renderVisiblePages() {
        var _a, _b;
        const pages = this._pages;
        const visiblePageNumbers = this.getVisiblePages(this._viewer, pages);
        const prevCurrent = this._currentPage;
        const current = this.getCurrentPage(this._viewer, pages, visiblePageNumbers);
        if (!prevCurrent || prevCurrent !== current) {
            (_a = pages[prevCurrent]) === null || _a === void 0 ? void 0 : _a.previewContainer.classList.remove("current");
            (_b = pages[current]) === null || _b === void 0 ? void 0 : _b.previewContainer.classList.add("current");
            this._shadowRoot.getElementById("paginator-input").value = current + 1 + "";
            this.scrollToPreview(current);
            this._currentPage = current;
        }
        if (current === -1) {
            return;
        }
        const minPageNumber = Math.max(Math.min(...visiblePageNumbers) - this._visibleAdjPages, 0);
        const maxPageNumber = Math.min(Math.max(...visiblePageNumbers) + this._visibleAdjPages, pages.length - 1);
        const renderedPages = [];
        for (let i = 0; i < pages.length; i++) {
            const page = pages[i];
            renderedPages.push(page);
            if (i >= minPageNumber && i <= maxPageNumber) {
                page.renderViewAsync();
            }
            else {
                page.clearView();
            }
        }
        this._renderedPages = renderedPages;
    }
    setAnnotationMode(mode) {
        if (!mode || mode === this._annotationMode) {
            return;
        }
        this.disableCurrentAnnotationMode();
        switch (mode) {
            case "select":
                this._shadowRoot.querySelector("#button-annotation-mode-select").classList.add("on");
                break;
            case "stamp":
                this._shadowRoot.querySelector("#button-annotation-mode-stamp").classList.add("on");
                this._viewer.append(this._annotationOverlay);
                this._viewer.addEventListener("pointermove", this.onStampAnnotationOverlayPointerMove);
                this._viewer.addEventListener("pointerup", this.onStampAnnotationOverlayPointerUp);
                this.createTempStampAnnotationAsync();
                break;
            case "pen":
                this._shadowRoot.querySelector("#button-annotation-mode-pen").classList.add("on");
                this._viewer.append(this._annotationOverlay);
                break;
            case "geometric":
                this._shadowRoot.querySelector("#button-annotation-mode-geometric").classList.add("on");
                this._viewer.append(this._annotationOverlay);
                break;
            default:
                throw new Error(`Invalid annotation mode: ${mode}`);
        }
        this._annotationMode = mode;
    }
    disableCurrentAnnotationMode() {
        if (this._annotationMode) {
            this._annotationToAdd = null;
            this._annotationOverlay.remove();
            this._annotationOverlaySvg.innerHTML = "";
            switch (this._annotationMode) {
                case "select":
                    this._shadowRoot.querySelector("#button-annotation-mode-select").classList.remove("on");
                    this._pages.forEach(x => x.clearAnnotationSelection());
                    break;
                case "stamp":
                    this._shadowRoot.querySelector("#button-annotation-mode-stamp").classList.remove("on");
                    this._viewer.removeEventListener("pointermove", this.onStampAnnotationOverlayPointerMove);
                    this._viewer.removeEventListener("pointerup", this.onStampAnnotationOverlayPointerUp);
                    break;
                case "pen":
                    this._shadowRoot.querySelector("#button-annotation-mode-pen").classList.remove("on");
                    break;
                case "geometric":
                    this._shadowRoot.querySelector("#button-annotation-mode-geometric").classList.remove("on");
                    break;
            }
        }
    }
    createTempStampAnnotationAsync() {
        return __awaiter$6(this, void 0, void 0, function* () {
            const stamp = this._docData.createStampAnnotation("draft");
            const renderResult = yield stamp.renderAsync();
            this._annotationOverlaySvg.innerHTML = "";
            this._annotationOverlaySvg.append(...renderResult.clipPaths || []);
            this._annotationOverlaySvg.append(renderResult.svg);
            this._annotationToAdd = stamp;
        });
    }
    showPasswordDialogAsync() {
        return __awaiter$6(this, void 0, void 0, function* () {
            const passwordPromise = new Promise((resolve, reject) => {
                const dialogContainer = document.createElement("div");
                dialogContainer.id = "password-dialog";
                dialogContainer.innerHTML = passwordDialogHtml;
                this._mainContainer.append(dialogContainer);
                let value = "";
                const input = this._shadowRoot.getElementById("password-input");
                input.placeholder = "Enter password...";
                input.addEventListener("change", () => value = input.value);
                const ok = () => {
                    dialogContainer.remove();
                    resolve(value);
                };
                const cancel = () => {
                    dialogContainer.remove();
                    resolve(null);
                };
                dialogContainer.addEventListener("click", (e) => {
                    if (e.target === dialogContainer) {
                        cancel();
                    }
                });
                this._shadowRoot.getElementById("password-ok").addEventListener("click", ok);
                this._shadowRoot.getElementById("password-cancel").addEventListener("click", cancel);
            });
            return passwordPromise;
        });
    }
}

export { TsPdfViewer };
